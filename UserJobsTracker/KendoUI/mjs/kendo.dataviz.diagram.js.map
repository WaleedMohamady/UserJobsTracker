{"version":3,"sources":["raw-mjs/kendo.dataviz.diagram.js"],"names":["$","undefined$1","kendo","window","diagram","dataviz","deepExtend","isArray","Array","Utils","isNearZero","num","Math","abs","isDefined","obj","isUndefined","isObject","Object","has","key","hasOwnProperty","call","isString","prototype","toString","isBoolean","isType","type","isNumber","isNaN","parseFloat","isFinite","isEmpty","length","simpleExtend","destination","source","name","initArray","size","value","array","i","serializePoints","points","res","p","push","x","y","join","deserializePoints","s","v","split","Point","parseInt","randomInteger","lower","upper","floor","random","DFT","el","func","childNodes","item","this","getMatrixAngle","m","d","atan2","b","PI","getMatrixScaling","sqrt","a","c","sign","number","findAngle","center","end","start","sngXComp","sngYComp","atan","findRadian","forEach","arr","iterator","thisRef","any","predicate","remove","what","ax","indexOf","splice","contains","inArray","fold","list","acc","context","initial","arguments","find","result","index","first","constraint","insert","element","position","all","clear","bisort","sortfunc","sort","n","addRange","range","apply","Easing","pos","cos","Ticker","Class","extend","init","adapters","target","tick","interval","duration","lastTime","handlers","_this","transition","timerDelegate","onTimerEvent","addAdapter","onComplete","handler","removeHandler","grep","h","trigger","caller","onStep","seekTo","to","seekFromTo","from","max","min","Date","getTime","intervalId","setInterval","stop","clearInterval","play","origin","initState","reverse","propagate","update","now","timePassed","movement","ui","Range","step","Infinity","j","k","rangeIntegerScale","jQuery","Point2D","isFunction","map","EPSILON","fn","plus","minus","offset","times","normalize","lengthSquared","middleOf","q","toPolar","useDegrees","factor","halfpi","len","Polar","isOnLine","temp","o1","u1","r1","Rect","inflate","r2","union","height","width","parse","str","xy","slice","PathDefiner","left","right","point","dx","dy","r","x1","y1","x2","y2","top","bottom","topLeft","topRight","bottomLeft","bottomRight","clone","equals","rect","rotatedBounds","angle","rotatedPoints","tl","tr","br","bl","rotate","delimiter","scale","scaleX","scaleY","staicPoint","adornerCenter","thisCenter","delta","scaled","zoom","overlaps","rectBottomRight","Size","intersectLine","start1","end1","start2","end2","isSegment","tangensdiff","Empty","toRect","empty","fromPoints","Intersect","lines","segments","rectWithLine","rects","rect1","rect2","intersect","reverseAngle","RectAlign","container","align","content","alignment","alignValues","toLowerCase","_singleAlign","_align","_left","_center","_right","stretch","_stretch","_top","middle","_middle","_bottom","alignCalc","Matrix","e","f","applyRect","fromSVGMatrix","vm","fromMatrixVector","fromList","translation","unit","rotation","sin","scaling","parts","nums","trim","substr","MatrixVector","fromMatrix","randomId","chars","charAt","round","Geometry","_distanceToLineSquared","d2","pt1","pt2","vx","vy","dot","distanceToLine","distanceToPolyline","minimum","Number","MAX_VALUE","p1","p2","HashTable","_buckets","add","_createGetBucket","get","_bucketExists","set","containsKey","hashId","_hash","hashes","_hashes","hash","bucket","ht","_hashString","_objectHashId","charCodeAt","id","_hashId","Dictionary","Observable","dictionary","_hashTable","entry","Error","forEachValue","forEachKey","keys","Queue","_tail","_head","enqueue","next","dequeue","current","Set","resource","kv","toArray","Node","shape","links","outgoing","incoming","weight","associatedShape","bounds","data","shortForm","isVirtual","isIsolated","isLinkedTo","node","that","link","getComplement","getChildren","children","getParents","parents","copy","balance","owner","adjacentTo","removeLink","hasLinkTo","degree","incidentWith","getLinksWith","getNeighbors","neighbors","Link","connection","sourceFound","targetFound","associatedConnection","getCommonNode","isBridging","v1","v2","getNodes","changeSource","changeTarget","changesNodes","w","oldSource","oldTarget","directTo","createReverseEdge","reversed","Graph","idOrDiagram","nodes","_nodeMap","_root","_hasCachedRelationships","cacheRelationships","forceRebuild","assignLevels","startNode","visited","level","child","root","found","getConnectedComponents","componentIndex","setItemIndices","componentId","_collectConnectedNodes","components","addNodeAndOutgoings","setIds","nodeIndex","nextId","calcBounds","getSpanningTree","tree","remaining","_addNode","levelCount","pop","ni","cn","newLink","addLink","treeLevels","takeRandomNode","excludedNodes","incidenceLessThan","pool","isHealthy","hasNode","sourceOrLink","addExistingLink","foundSource","getNode","addNode","foundTarget","removeAllLinks","hasLink","t","linkOrId","nodeOrId","_removeNode","removeNode","areConnected","n1","n2","layoutRect","newNode","newLinks","saveMapping","save","nodeMap","linkMap","nOriginal","nCopy","linkOriginal","linkCopy","linearize","addIds","depthFirstTraversal","action","foundNode","_dftIterator","breadthFirstTraversal","queue","_stronglyConnectedComponents","excludeSingleItems","indices","lowLinks","connected","stack","component","findCycles","isAcyclic","isSubGraph","other","otherArray","thisArray","makeAcyclic","oneNode","rev","N","intensityCatalog","flowIntensity","catalogEqualIntensity","intensity","sourceStack","targetStack","targets","li","targetLink","unshift","sources","si","sourceLink","ri","ril","u","concat","vertexOrder","kk","reversedEdges","Predefined","EightGraph","Mindmap","ThreeGraph","BinaryTree","levels","createBalancedTree","Linear","Tree","siblingsCount","Forest","trees","createBalancedForest","Workflow","Grid","g","previous","graphString","previousLink","graph","part","lin","_addShape","kendoDiagram","shapeDefaults","radius","fill","undoable","addShape","_addConnection","options","connect","createDiagramFromGraph","doLayout","randomSize","clientWidth","clientHeight","opt","color","gli","sourceShape","targetShape","SpringLayout","layoutGraph","limitToView","shi","news","counter","lastAdded","parent","treeCount","createRandomConnectedGraph","nodeCount","maxIncidence","isTree","poolNode","randomAdditions","randomDiagram","shapeCount","normalVariable","mean","deviation","log","geometry","drawing","defined","util","TRANSPARENT","Markers","none","arrowStart","filledCircle","arrowEnd","START","END","WIDTH","HEIGHT","diffNumericOptions","fields","field","elementOptions","hasChanges","Scale","toMatrix","format","invert","Translation","toMatrixVector","Length","Rotation","ZERO","create","values","CompositeTransform","translate","transform","render","visual","_transform","_renderTransform","rotateMatrix","scaleMatrix","translatePoint","AutoSizeableMixin","_setScale","originWidth","_originWidth","originHeight","_originHeight","_setTranslate","_initSize","autoSize","_measure","_updateSize","_diffNumericOptions","Element","_originSize","visible","drawingContainer","redraw","drawingElement","matrix","_hover","force","_measured","box","_boundingBox","startPoint","rawBBox","VisualBase","normalizeDrawingOptions","stroke","opacity","_fill","getColor","_stroke","show","hover","strokeOptions","dashType","fillOptions","gradient","GradientClass","RadialGradient","LinearGradient","TextBlock","_textColor","_font","_initText","fontSize","fontFamily","Text","text","font","fontOptions","fontStyle","fontWeight","sizeChanged","textOptions","Rectangle","_initPath","_setPosition","_drawPath","Path","closed","sizeOptions","sizeOptionsOrDefault","elements","createSegment","MarkerBase","anchor","createElement","_transformToPath","path","transformCopy","CircleMarker","Circle","positionMarker","targetSegment","ArrowMarker","xDiff","yDiff","_linePoints","deg","endPoint","controlOut","nextSegment","controlIn","prevSegment","MarkerPathMixin","_getPath","MultiPath","paths","_normalizeMarkerOptions","startCap","endCap","_removeMarker","marker","_markers","_createMarkers","_createMarker","markerType","append","_positionMarker","_capMap","_redrawMarker","pathChange","pathOptions","cap","pathCapType","optionsCap","created","_redrawMarkers","Group","_createElements","_setData","multipath","Line","Polyline","_updatePath","_pointsDiffer","currentPoints","differ","Image","_initImage","src","_rect","_childrenChange","_remove","removeAt","toFront","visuals","toBack","_reorderChildren","toIndex","group","drawingChildren","fixedPosition","boundingBox","childBoundingBox","_includeInBBox","clippedBBox","Layout","toDrawingRect","drawingRect","reflow","_initCircle","circleOptions","move","_circle","setRadius","Canvas","surface","Surface","_translate","_viewBox","viewBox","setSize","draw","insertBefore","destroy","clearHtml","drawingOptions","Color","toHex","Segment","Movable","Cursors","arrow","grip","cross","select","south","east","west","north","rowresize","colresize","HIT_TEST_DISTANCE","AUTO","TOP","RIGHT","LEFT","BOTTOM","DRAG_START","DRAG","DRAG_END","ITEMBOUNDSCHANGE","ROTATED","TARGET","HANDLE_NAMES","PositionAdapter","layoutState","froms","tos","subjects","getShapeById","LayoutUndoUnit","initialState","finalState","animate","_initialState","_finalState","title","undo","setState","redo","state","conn","ticker","CompositeUnit","units","undoUnit","ConnectionEditUnit","redoSource","redoTarget","_redoSource","_redoTarget","_undoSource","_undoTarget","_updateConnector","updateModel","ConnectionEditUndoUnit","undoSource","undoTarget","DeleteConnectionUnit","targetConnector","DeleteShapeUnit","TransformUnit","shapes","undoStates","adorner","redoStates","layout","refreshBounds","refresh","AddConnectionUnit","AddShapeUnit","deselect","PanUndoUnit","initialPosition","finalPosition","finalPos","pan","RotateUnit","undoRotates","redoRotates","redoAngle","_angle","_innerBounds","_initialize","ToFrontUnit","items","initialIndices","_toIndex","ToBackUnit","UndoRedoService","bind","events","capacity","begin","composite","cancel","commit","execute","_restart","addCompositeItem","count","EmptyTool","toolService","tryActivate","getCursor","ScrollerTool","tool","friction","support","mobileOS","canvas","scroller","scrollable","kendoMobileScroller","velocityMultiplier","mousewheelScrolling","scroll","_move","movableCanvas","virtualScroll","dimension","makeVirtual","virtualSize","dimensions","disable","meta","pannable","enabled","ctrlKey","noMeta","hoveredItem","hoveredAdorner","_hoveredConnector","enable","args","scrollPos","scrollLeft","scrollTop","_storePan","moveTo","_pan","PointerTool","selectSingle","handle","_hitTest","_resizingAdorner","isDragHandle","connections","undoRedoService","_getCursor","SelectionTool","selectable","multiple","selector","isSelected","selectArea","ConnectionTool","connector","_createConnection","_c","canDrag","connectionHandle","_connectionManipulation","_removeHover","activeConnection","_cachedTouchTarget","cachedTouchTarget","sourceConnector","Shape","getConnector","_syncConnectionChanges","_connectorsAdorner","ConnectionEditTool","isActive","handleName","testKey","toUpperCase","ToolService","tools","activeTool","_updateHoveredItem","_activateTool","_updateCursor","focus","suspendTracking","updateHovered","resumeTracking","keyDown","metaKey","altKey","toRemove","_triggerRemove","_syncChanges","_destroyToolBar","_discardNewConnection","selectAll","cut","paste","wheel","z","zoomRate","zoomOptions","zoomMin","zoomMax","setTool","addToSelection","newConnection","cursor","css","disabledShape","isNew","hit","_visible","selectedConnections","_selectedItems","Connection","_hitTestItems","_hitTestElements","shapeHit","connectionHit","idx","connectors","hitTestShapeConnectors","mainLayer","ConnectionRouterBase","LinearConnectionRouter","hitTest","getBounds","allPoints","PolylineRouter","route","CascadingRouter","SAME_SIDE_DISTANCE_RATIO","routePoints","_connectorPoints","_floatingPoints","_resolvedSourceConnector","_resolvedTargetConnector","sourcePoint","targetPoint","_connectorSides","axis","boundsPoint","secondarySign","_connectorSide","sideDistance","minSide","side","shapeBounds","sides","MAX_NUM","_sameSideDistance","pointX","pointY","sourceConnectorSide","targetConnectorSide","deltaX","deltaY","sameSideDistance","shiftX","shiftY","cascadeStartHorizontal","_startHorizontal","sourceSide","AdornerBase","_adorners","ConnectionEditAdorner","_ts","sp","tp","spVisual","handles","epVisual","_initialSource","_initialTarget","ts","radiusX","radiusY","sourcePointDistance","distanceTo","targetPointDistance","sourceHandle","targetHandle","modelToLayer","ConnectorsAdorner","_refreshHandler","ctr","_clearVisual","ConnectorVisual","_keepCachedTouchTarget","visualChildren","childrenCount","unbind","each","ResizingAdorner","_manipulating","_initSelection","_createHandles","selected","_internalChange","_rotatedHandler","_resizable","editable","resize","_handleOptions","_bounds","handleBounds","handlesCount","_getHandleBounds","_rotationOffset","_startAngle","_rotates","_positions","initialRotates","initialStates","handleOptions","_sp","_cp","_lp","shapeStates","visibleHandles","currentAngle","dragging","newBounds","staticPoint","dtl","dbr","changed","_truncateAngle","_rotating","shouldSnap","thr","_truncateDistance","hitToOppositeSide","_displaceBounds","newCenter","minWidth","minHeight","oldBounds","states","_truncatePositionToGuides","ruler","truncatePositionToGuides","_truncateSizeToGuides","truncateSizeToGuides","snap","snapOptions","snapAngle","snapSize","drag","_diffStates","_syncShapeChanges","rotationThumb","thumb","_rotationThumbBounds","Selector","_ep","_adorn","visualBounds","modelToView","relative","_visualBounds","shiftKey","HyperTree","DEG_TO_RAD","LayoutBase","defaultOptions","subtype","roots","nodeDistance","iterations","horizontalSeparation","verticalSeparation","underneathVerticalTopOffset","underneathHorizontalOffset","underneathVerticalSeparation","grid","offsetX","offsetY","componentSpacingX","componentSpacingY","layerSeparation","layeredIterations","startRadialAngle","endRadialAngle","radialSeparation","radialFirstLevelSeparation","keepComponentsInOneRadialLayout","ignoreContainers","layoutContainerChildren","ignoreInvisible","animateTransitions","gridLayoutComponents","maxWidth","startX","resultLinkSet","resultNodeSet","moveToOffset","boundingRect","currentHeight","currentWidth","deltax","deltay","nodeBounds","newpoints","pt","currentHorizontalOffset","transferOptions","DiagramToHyperTreeAdapter","shapeMap","edges","edgeMap","finalNodes","finalLinks","ignoredConnections","ignoredShapes","hyperMap","hyperTree","finalGraph","convert","_renormalizeShapes","_renormalizeConnections","l","mapConnection","mapShape","getEdge","listToRoot","containerGraph","parentContainer","firstNonIgnorableContainer","isContainer","_isIgnorableItem","isContainerConnection","isDescendantOf","scope","containers","isIgnorableItem","isCollapsed","_isVisible","_isTop","isShapeMapped","leastCommonAncestor","al","xa","xb","_isCollapsed","sink","sourceNode","sinkNode","areConnectedAlready","newEdge","finalNodeSet","LayoutState","initialTemperature","temperature","guessBounds","_expectedBounds","refineStage","_repulsion","_attraction","_shake","rho","alpha","_InverseSquareForce","wn","hn","wm","hm","pow","_SquareForce","distance","squareSize","area","ceil","TreeLayoutProcessor","treeGraph","layoutSwitch","layoutLeft","setChildrenDirection","setChildrenLayout","TreeDirection","measure","Width","arrange","layoutRight","layoutUp","up","layoutDown","down","treeDirection","layoutRadialTree","previousRoot","startAngle","endAngle","maxDepth","calculateAngularWidth","radialLayout","Angle","tipOverTree","startFromLevel","aw","diameter","sectorAngle","sortChildren","basevalue","pl","nl","normalizeAngle","col","deltaTheta","deltaThetaHalf","parentSector","fraction","sorted","childNode","cp","childAngleFraction","setPolarLocation","BoundingRectangle","direction","includeStart","rootDirection","rootLayout","childrenLayout","givenSize","shapeWidth","shapeHeight","AngleToParent","SectorAngle","pp","childrenwidth","selfLocation","single","male","female","leftcount","tipOverTreeStartLevel","TreeLayout","adapter","layoutComponents","getTree","getTreeForRoot","LayeredLayout","_initRuntimeProperties","layer","downstreamLinkCount","upstreamLinkCount","uBaryCenter","dBaryCenter","upstreamPriority","downstreamPriority","gridPosition","_prepare","targetLayer","layerMap","layerCount","shift","sortedNodes","o2","o1layer","o2layer","minLayer","layers","linksTo","_dummify","_optimizeCrossings","_swapPairs","arrangeNodes","_moveThingsAround","_dedummify","setMinDist","minDist","layerIndex","minDistances","getMinDist","dist","i1","i2","placeLeftToRight","leftClasses","leftPos","classNodes","placeLeft","POSITIVE_INFINITY","rightSibling","nodeLeftClass","D","upNodes","downNodes","neighbor","intDiv","placeRightToLeft","rightClasses","rightPos","placeRight","NEGATIVE_INFINITY","leftSibling","nodeRightClass","_getLeftWing","leftWing","computeClasses","_getRightWing","rightWing","wingPair","currentWing","wing","ndsinl","_nodesInLink","vnode","wings","classIndex","_isVerticalLayout","_isHorizontalLayout","_isIncreasingLayout","_gridPositionComparer","dest","currentNode","currDown","downNode","order","placed","sequenceStart","virtualStartIndex","_firstVirtualNode","virtualStart","sequence","_sequencer","virtualEnd","nextVirtualNode","virtualEndIndex","adjustDirections","ctx","fromLayerIndex","layerIncrement","maximumHeight","MIN_VALUE","prevBridge","prevBridgeTarget","nextBridge","nextBridgeTarget","getNeighborOnLayer","clayer","j1","j2","dir","_sequenceSingle","combineSequences","pair","leftHeap","_positionDescendingComparer","rightHeap","_positionAscendingComparer","leftRes","rightRes","leftClass","_getComposite","rightClass","it","layoutLayer","gridPos","iconsidered","considered","n1Priority","n2Priority","nodeGridPos","nodeBaryCenter","calcBaryCenter","nodePriority","moveRight","moveLeft","calcDownData","calcUpData","priority","rightNode","rightNodePriority","leftNode","leftNodePriority","mapVirtualNode","nodeToLinkMap","linkToNodeMap","addLinkBetweenLayers","upLayer","downLayer","o","oLayer","dLayer","oPos","dPos","depthOfDumminess","dedum","prevLink","moves","iter","optimizeLayerCrossings","sum","total","presorted","n1BaryCenter","n2BaryCenter","compareByIndex","compareValue","inode","maxIterations","downwards","secondPass","hasSwapped","calcCrossings","memCrossings","crossBefore","countLinksCrossingBetweenTwoLayers","node1","node2","node1GridPos","node2GridPos","crossAfter","ulayer","dlayer","link1","link2","n11","n12","n21","n22","l1","l2","crossings","n11gp","n12gp","numerator","denominator","graphOrNodes","capture","diagramOrGraphOrNodes","GraphAdapter","geom","Widget","outerWidth","_outerWidth","outerHeight","_outerHeight","HierarchicalDataSource","isPlainObject","math","NS","CASCADING","CHANGE","CLICK","ERROR","MAXINT","SELECT","ITEMROTATE","PAN","ZOOM_START","ZOOM_END","NONE","TRANSFORMED","MOUSEWHEEL_NS","BUTTON_TEMPLATE","className","icon","themeColor","html","renderButton","DefaultConnectors","getPosition","defaultButtons","imageClass","isAutoConnector","closestConnector","resCtr","minimumDistance","indicesOfItems","extra","defaults","DiagramElement","dataItem","_template","serializable","serialize","json","_content","contentOptions","_contentVisual","_updateContentVisual","_createContentVisual","template","elementTemplate","paramName","_canSelect","toJSON","Connector","shapeId","tempStr","updateOptionsFromModel","createShapeVisual","updateBounds","_createConnectors","_setOptionsFromModel","model","modelOptions","filterShapeDataItem","redrawVisual","_isEditable","_redrawVisual","syncChanges","_suspendModelRefresh","_resumeModelRefresh","_rotate","_alignContent","contentVisual","containerRect","aligner","contentBounds","bbox","contentRect","alignedBounds","connectorDefaults","_transformedBounds","_rotatedBounds","_setBounds","_triggerBoundsChange","_layouting","refreshConnections","cloneDataItem","deselected","_internalSelection","_selectionChanged","deltaAngle","newPosition","sc","con","cons","nameOrPoint","toLocaleLowerCase","fnName","_transformPoint","boundsChange","shapeOptions","shapeVisual","_visualOptions","_updateConnectors","_showConnectors","rotatedPoint","visualOptions","visualTemplate","_initRouter","_sourcePoint","_targetPoint","_setSource","_setTarget","definers","fromConnector","toConnector","dataMap","_dataMap","fromX","fromY","toX","toY","filterConnectionDataItem","connectionsDataSource","getByUid","uid","clearField","shapeSource","defaultConnector","_removeFromSourceConnector","_clearSourceConnector","_setFromOptions","fromPoint","sourceDefiner","_sourceDefiner","shapeTarget","_removeFromTargetConnector","_clearTargetConnector","_setToOptions","toPoint","targetDefiner","_targetDefiner","instance","connectorName","setNewTarget","inactiveItem","_inactiveShapeItems","_deferredConnectionUpdates","onActivate","endIdx","startIdx","alignToPath","midIdx","selection","_router","pts","definition","_resolveConnectors","_refreshPath","sourceConnectors","targetConnectors","_resolveAutoConnectors","minNonConflictSource","minNonConflictTarget","minSource","minTarget","sourceIdx","targetIdx","minNonConflict","_testRoutePoints","router","passRoute","exclude","_getRouteExclude","_shapesQuadTree","hitTestRect","_isPointInsideShape","boundsX","boundsY","Diagram","userOptions","_initTheme","_initElements","_extendLayoutOptions","_initDefaults","_interactionDefaults","_initCanvas","ShapesQuadTree","adornerLayer","_createHandlers","_clipboard","pauseMouseHandlers","_fetchFreshData","_createGlobalToolBar","_createOptionElements","theme","dataSource","draggable","autoBind","tooltip","connectionDefaults","toolBar","DiagramToolBar","click","_toolBarClick","modal","textAlign","prepend","_resize","createShape","editor","view","createModel","_createShape","edit","createConnection","_connectionsDataMap","addConnection","editModel","editorType","editors","cancelEdit","shapeEditors","shapeTemplate","connectionSelectorHandler","connectionSelector","connectionEditors","connectionTemplate","PopupEditor","_update","_cancel","_editArgs","_getEditDataSource","cancelChanges","_destroyEditor","saveEdit","sync","wrapper","close","attr","addClass","appendTo","userShapeDefaults","copyDefaultOptions","mobile","canvasContainer","viewPort","viewport","on","_wheel","_keydown","_userEvents","UserEvents","multiTouch","fastTap","tap","_tap","_dragStart","_drag","_dragEnd","gesturestart","_gestureStart","gesturechange","_gestureChange","gestureend","_gestureEnd","doubleTap","_doubleTap","supportDoubleTap","_mouseover","_mouseout","_mouseMove","_mouseDown","_mouseUp","_syncHandler","_resizeHandler","onResize","_pauseMouseHandlers","_eventPositions","event","_meta","preventDefault","_createToolBar","focused","ctrlPressed","keyCode","origEvent","originalEvent","wheelDelta","detail","mwDelta","touch","pageX","pageY","documentToModel","initialCenter","eventArgs","_gesture","_initialCenter","previousGesture","documentToView","scaleDelta","_zoom","updateZoom","_getValidZoom","zoomedPoint","_panTransform","_updateAdorners","pointPosition","_kendoNode","srcElement","themeOptions","themeName","themes","SASS_THEMES","autoTheme","shapesLength","_createShapes","_createConnections","_findConnectionTarget","unbindResize","off","destroyScroller","_destroyGlobalToolBar","is","_activeElement","scrollContainer","offsets","documentElement","document","parentNode","scrollHeight","load","setOptions","added","removed","_parseBounds","splitDiagramElements","_removeItem","_removeShapeDataItem","_removeConnectionDataItem","_getDiagramItems","_fixOrdering","bringIntoView","original","newPan","_zoomMainLayer","alignShapes","val","raw","hideTooltip","_getPan","animatedScrollTo","scrollTo","_copyOffset","copied","mapping","_updateCopiedConnection","sourceConnection","di","_containerOffset","containerOffset","viewToDocument","viewToModel","_transformWithMatrix","_matrixInvert","_matrix","_layerMatrix","layerToModel","_layerMatrixInvert","viewPoint","modelToDocument","setDataSource","_dataSource","fetch","setConnectionsDataSource","_connectionDataSource","_redrawConnections","getShapeByModelId","getShapeByModelUid","getConnectionByModelId","getConnectionByModelUid","_transformMainLayer","_finishPan","NaN","_storeViewMatrix","_storeLayerMatrix","canvasTransform","shapePos","conPos","removedConnections","_removeShape","_removeConnection","_removeDataItems","recursive","_removeShapeConnections","hasChildren","loaded","_addDataItem","_addDataItemByUid","_addDataItems","parentShape","_refreshSource","dataBound","_bindingRoots","_addItem","preventClosing","singleToolBar","popupZIndex","closest","popupWidth","_popup","popupHeight","connectionBounds","showAt","one","_normalizePointZoom","InactiveItemsCollection","undone","redone","_loadingShapes","_loadingConnections","dsOptions","ds","_shapesRefreshHandler","_shapesRequestStartHandler","_shapesErrorHandler","_refreshShapes","_shapesRequestStart","_error","DataSource","_treeDataSource","_connectionsRefreshHandler","_connectionsRequestStartHandler","_connectionsErrorHandler","_refreshConnections","_connectionsRequestStart","_connectionsError","_shouldRefresh","_removeShapes","_updateShapes","_syncShapes","_suspended","_rebindShapesAndConnections","_addShapes","_addConnections","inactiveItems","activate","dataItems","_removeConnections","_updateConnections","_addConnectionDataItem","_validateConnector","_unbindDataSource","_errorHandler","adorners","_refresh","hide","exportDOMVisual","scrollOffset","viewRect","clipPath","fromRect","wrap","clipWrap","clip","exportVisual","when","then","deferredConnectionUpdates","ExportMixin","PDFMixin","_tools","createToolBar","createTools","appendTools","createPopup","kendoPopup","getKendoPopup","buttons","_toolBar","kendoToolBar","resizable","getKendoToolBar","createTool","toolName","attributes","_setAttributes","open","newGroup","editTool","showText","deleteTool","rotateAnticlockwiseTool","_appendGroup","_rotateGroup","rotateClockwiseTool","createShapeTool","_createGroup","createConnectionTool","undoTool","_historyGroup","redoTool","prop","_getAttributes","eventData","selectedElements","delete","selectedElemens","rotateClockwise","rotateAnticlockwise","Editor","_getFields","_initContainer","createEditable","Editable","clearContainer","modelFields","columns","formContent","_renderTemplate","_renderFields","_renderButtons","Window","userTriggered","sender","_cancelClick","_attachButtonEvents","unescape","form","_createButton","_cancelClickHandler","_updateClickHandler","_updateClick","_editUpdateClickHandler","reader","textField","idField","kendoDropDownList","dataValueField","dataTextField","optionLabel","valuePrimitive","InactiveItem","callbacks","callback","deffered","Deferred","deferred","resolve","QuadRoot","_add","_quadNode","_testRect","QuadNode","inBounds","nodeRect","nodeBottomRight","overlapsBounds","inserted","_initChildren","childIdx","shapeIdx","halfWidth","halfHeight","ROOT_SIZE","boundsChangeHandler","_boundsChange","initRoots","rootMap","rootSize","sectors","getSectors","inRoot","bottomX","bottomY","xIdx","yIdx","Model","_defaultId","ObservableObject","mainOptions","plugin","__meta__","category","description","depends","features","kendo$1"],"mappings":"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","file":"kendo.dataviz.diagram.js","sourcesContent":["import './kendo.data.js';\nimport './kendo.draganddrop.js';\nimport './kendo.userevents.js';\nimport './kendo.mobile.scroller.js';\nimport './kendo.drawing.js';\nimport './kendo.core.js';\nimport './kendo.dataviz.core.js';\nimport './kendo.toolbar.js';\nimport './kendo.editable.js';\nimport './kendo.window.js';\nimport './kendo.dropdownlist.js';\nimport './kendo.dataviz.themes.js';\nimport './kendo.html.button.js';\n\n(function($, undefined$1) {\n    var kendo = window.kendo,\n        diagram = kendo.dataviz.diagram = {},\n        deepExtend = kendo.deepExtend,\n        isArray = Array.isArray,\n        EPSILON = 1e-06;\n\n    /*-------------------Diverse utilities----------------------------*/\n    var Utils = {\n    };\n\n    deepExtend(Utils, {\n        isNearZero: function(num) {\n            return Math.abs(num) < EPSILON;\n        },\n        isDefined: function(obj) {\n            return typeof obj !== 'undefined';\n        },\n\n        isUndefined: function(obj) {\n            return (typeof obj === 'undefined') || obj === null;\n        },\n        /**\n         * Returns whether the given object is an object or a value.\n         */\n        isObject: function(obj) {\n            return obj === Object(obj);\n        },\n        /**\n         * Returns whether the object has a property with the given name.\n         */\n        has: function(obj, key) {\n            return Object.hasOwnProperty.call(obj, key);\n        },\n        /**\n         * Returns whether the given object is a string.\n         */\n        isString: function(obj) {\n            return Object.prototype.toString.call(obj) == '[object String]';\n        },\n        isBoolean: function(obj) {\n            return Object.prototype.toString.call(obj) == '[object Boolean]';\n        },\n        isType: function(obj, type) {\n            return Object.prototype.toString.call(obj) == '[object ' + type + ']';\n        },\n        /**\n         * Returns whether the given object is a number.\n         */\n        isNumber: function(obj) {\n            return !isNaN(parseFloat(obj)) && isFinite(obj);\n        },\n        /**\n         * Return whether the given object (array or dictionary).\n         */\n        isEmpty: function(obj) {\n            if (obj === null) {\n                return true;\n            }\n            if (isArray(obj) || Utils.isString(obj)) {\n                return obj.length === 0;\n            }\n            for (var key in obj) {\n                if (Utils.has(obj, key)) {\n                    return false;\n                }\n            }\n            return true;\n        },\n        simpleExtend: function(destination, source) {\n            if (!Utils.isObject(source)) {\n                return;\n            }\n\n            for (var name in source) {\n                destination[name] = source[name];\n            }\n        },\n        /**\n         * Returns an array of the specified size and with each entry set to the given value.\n         * @param size\n         * @param value\n         * @returns {Array}\n         */\n        initArray: function createIdArray(size, value) {\n            var array = [];\n            for (var i = 0; i < size; ++i) {\n                array[i] = value;\n            }\n            return array;\n        },\n        serializePoints: function(points) {\n            var res = [];\n            for (var i = 0; i < points.length; i++) {\n                var p = points[i];\n                res.push(p.x + \";\" + p.y);\n            }\n            return res.join(\";\");\n        },\n        deserializePoints: function(s) {\n            var v = s.split(\";\"), points = [];\n            if (v.length % 2 !== 0) {\n                throw \"Not an array of points.\";\n            }\n            for (var i = 0; i < v.length; i += 2) {\n                points.push(new diagram.Point(\n                    parseInt(v[i], 10),\n                    parseInt(v[i + 1], 10)\n                ));\n            }\n            return points;\n        },\n        /**\n         * Returns an integer within the given bounds.\n         * @param lower The inclusive lower bound.\n         * @param upper The exclusive upper bound.\n         * @returns {number}\n         */\n        randomInteger: function(lower, upper) {\n            return parseInt(Math.floor(Math.random() * upper) + lower, 10);\n        } ,\n        /*\n         Depth-first traversal of the given node.\n         */\n        DFT: function(el, func) {\n            func(el);\n            if (el.childNodes) {\n                for (var i = 0; i < el.childNodes.length; i++) {\n                    var item = el.childNodes[i];\n                    this.DFT(item, func);\n                }\n            }\n        },\n        /*\n         Returns the angle in degrees for the given matrix\n         */\n        getMatrixAngle: function(m) {\n            if (m === null || m.d === 0) {\n                return 0;\n            }\n            return Math.atan2(m.b, m.d) * 180 / Math.PI;\n        },\n\n        /*\n         Returns the scaling factors for the given matrix.\n         */\n        getMatrixScaling: function(m) {\n            var sX = Math.sqrt(m.a * m.a + m.c * m.c);\n            var sY = Math.sqrt(m.b * m.b + m.d * m.d);\n            return [sX, sY];\n        }\n\n    });\n\n    /**\n     * The Range defines an array of equally separated numbers.\n     * @param start The start-value of the Range.\n     * @param stop The end-value of the Range.\n     * @param step The separation between the values (default:1).\n     * @returns {Array}\n     */\n    function Range(start, stop, step) {\n        if (typeof start == 'undefined' || typeof stop == 'undefined') {\n            return [];\n        }\n        if (step && Utils.sign(stop - start) != Utils.sign(step)) {\n            throw \"The sign of the increment should allow to reach the stop-value.\";\n        }\n        step = step || 1;\n        start = start || 0;\n        stop = stop || start;\n        if ((stop - start) / step === Infinity) {\n            throw \"Infinite range defined.\";\n        }\n        var range = [], i = -1, j;\n\n        function rangeIntegerScale(x) {\n            var k = 1;\n            while (x * k % 1) {\n                k *= 10;\n            }\n            return k;\n        }\n\n        var k = rangeIntegerScale(Math.abs(step));\n        start *= k;\n        stop *= k;\n        step *= k;\n        if (start > stop && step > 0) {\n            step = -step;\n        }\n        if (step < 0) {\n            while ((j = start + step * ++i) >= stop) {\n                range.push(j / k);\n            }\n        }\n        else {\n            while ((j = start + step * ++i) <= stop) {\n                range.push(j / k);\n            }\n        }\n        return range;\n    }\n\n    /*-------------------Diverse math functions----------------------------*/\n\n    function findRadian(start, end) {\n        if (start == end) {\n            return 0;\n        }\n        var sngXComp = end.x - start.x,\n            sngYComp = start.y - end.y,\n            atan = Math.atan(sngXComp / sngYComp);\n        if (sngYComp >= 0) {\n            return sngXComp < 0 ? atan + (2 * Math.PI) : atan;\n        }\n        return atan + Math.PI;\n    }\n\n    Utils.sign = function(number) {\n        return number ? number < 0 ? -1 : 1 : 0;\n    };\n\n    Utils.findAngle = function(center, end) {\n        return findRadian(center, end) * 180 / Math.PI;\n    };\n\n    /*-------------------Array Helpers ----------------------------*/\n\n    Utils.forEach = function(arr, iterator, thisRef) {\n        for (var i = 0; i < arr.length; i++) {\n            iterator.call(thisRef, arr[i], i, arr);\n        }\n    };\n\n    Utils.any = function(arr, predicate) {\n        for (var i = 0; i < arr.length; ++i) {\n            if (predicate(arr[i])) {\n                return arr[i];\n            }\n        }\n        return null;\n    };\n\n    Utils.remove = function(arr, what) {\n        var ax;\n        while ((ax = Utils.indexOf(arr, what)) !== -1) {\n            arr.splice(ax, 1);\n        }\n        return arr;\n    };\n\n    Utils.contains = function(arr, obj) {\n        return Utils.indexOf(arr, obj) !== -1;\n    };\n\n    Utils.indexOf = function(arr, what) {\n        return $.inArray(what, arr);\n    };\n\n    Utils.fold = function(list, iterator, acc, context) {\n        var initial = arguments.length > 2;\n\n        for (var i = 0; i < list.length; i++) {\n            var value = list[i];\n            if (!initial) {\n                acc = value;\n                initial = true;\n            }\n            else {\n                acc = iterator.call(context, acc, value, i, list);\n            }\n        }\n\n        if (!initial) {\n            throw 'Reduce of empty array with no initial value';\n        }\n\n        return acc;\n    };\n\n    Utils.find = function(arr, iterator, context) {\n        var result;\n        Utils.any(arr, function(value, index, list) {\n            if (iterator.call(context, value, index, list)) {\n                result = value;\n                return true;\n            }\n            return false;\n        });\n        return result;\n    };\n\n    Utils.first = function(arr, constraint, context) {\n        if (arr.length === 0) {\n            return null;\n        }\n        if (Utils.isUndefined(constraint)) {\n            return arr[0];\n        }\n\n        return Utils.find(arr, constraint, context);\n    };\n\n    /**\n     * Inserts the given element at the specified position and returns the result.\n     */\n    Utils.insert = function(arr, element, position) {\n        arr.splice(position, 0, element);\n        return arr;\n    };\n\n    Utils.all = function(arr, iterator, context) {\n        var result = true;\n        var value;\n\n        for (var i = 0; i < arr.length; i++) {\n            value = arr[i];\n            result = result && iterator.call(context, value, i, arr);\n\n            if (!result) {\n                break;\n            }\n        }\n\n        return result;\n    };\n\n    Utils.clear = function(arr) {\n        arr.splice(0, arr.length);\n    };\n\n    /**\n     * Sort the arrays on the basis of the first one (considered as keys and the other array as values).\n     * @param a\n     * @param b\n     * @param sortfunc (optiona) sorting function for the values in the first array\n     */\n    Utils.bisort = function(a, b, sortfunc) {\n        if (Utils.isUndefined(a)) {\n            throw \"First array is not specified.\";\n        }\n        if (Utils.isUndefined(b)) {\n            throw \"Second array is not specified.\";\n        }\n        if (a.length != b.length) {\n            throw \"The two arrays should have equal length\";\n        }\n\n        var all = [], i;\n\n        for (i = 0; i < a.length; i++) {\n            all.push({ 'x': a[i], 'y': b[i] });\n        }\n        if (Utils.isUndefined(sortfunc)) {\n            all.sort(function(m, n) {\n                return m.x - n.x;\n            });\n        }\n        else {\n            all.sort(function(m, n) {\n                return sortfunc(m.x, n.x);\n            });\n        }\n\n        Utils.clear(a);\n        Utils.clear(b);\n\n        for (i = 0; i < all.length; i++) {\n            a.push(all[i].x);\n            b.push(all[i].y);\n        }\n    };\n\n    Utils.addRange = function(arr, range) {\n        arr.push.apply(arr, range);\n    };\n\n    var Easing = {\n        easeInOut: function(pos) {\n            return ((-Math.cos(pos * Math.PI) / 2) + 0.5);\n        }\n    };\n\n    /**\n     * An animation ticker driving an adapter which sets a particular\n     * property in function of the tick.\n     * @type {*}\n     */\n    var Ticker = kendo.Class.extend({\n        init: function() {\n            this.adapters = [];\n            this.target = 0;\n            this.tick = 0;\n            this.interval = 20;\n            this.duration = 800;\n            this.lastTime = null;\n            this.handlers = [];\n            var _this = this;\n            this.transition = Easing.easeInOut;\n            this.timerDelegate = function() {\n                _this.onTimerEvent();\n            };\n        },\n        addAdapter: function(a) {\n            this.adapters.push(a);\n        },\n        onComplete: function(handler) {\n            this.handlers.push(handler);\n        },\n        removeHandler: function(handler) {\n            this.handlers = $.grep(this.handlers, function(h) {\n                return h !== handler;\n            });\n        },\n        trigger: function() {\n            var _this = this;\n            if (this.handlers) {\n                Utils.forEach(this.handlers, function(h) {\n                    return h.call(_this.caller !== null ? _this.caller : _this);\n                });\n            }\n        },\n        onStep: function() {\n        },\n        seekTo: function(to) {\n            this.seekFromTo(this.tick, to);\n        },\n        seekFromTo: function(from, to) {\n            this.target = Math.max(0, Math.min(1, to));\n            this.tick = Math.max(0, Math.min(1, from));\n            this.lastTime = new Date().getTime();\n            if (!this.intervalId) {\n                this.intervalId = window.setInterval(this.timerDelegate, this.interval);\n            }\n        },\n        stop: function() {\n            if (this.intervalId) {\n                window.clearInterval(this.intervalId);\n                this.intervalId = null;\n\n                //this.trigger.call(this);\n                this.trigger();\n                // this.next();\n            }\n        },\n        play: function(origin) {\n            if (this.adapters.length === 0) {\n                return;\n            }\n            if (origin !== null) {\n                this.caller = origin;\n            }\n            this.initState();\n            this.seekFromTo(0, 1);\n        },\n        reverse: function() {\n            this.seekFromTo(1, 0);\n        },\n        initState: function() {\n            if (this.adapters.length === 0) {\n                return;\n            }\n            for (var i = 0; i < this.adapters.length; i++) {\n                this.adapters[i].initState();\n            }\n        },\n        propagate: function() {\n            var value = this.transition(this.tick);\n\n            for (var i = 0; i < this.adapters.length; i++) {\n                this.adapters[i].update(value);\n            }\n        },\n        onTimerEvent: function() {\n            var now = new Date().getTime();\n            var timePassed = now - this.lastTime;\n            this.lastTime = now;\n            var movement = (timePassed / this.duration) * (this.tick < this.target ? 1 : -1);\n            if (Math.abs(movement) >= Math.abs(this.tick - this.target)) {\n                this.tick = this.target;\n            } else {\n                this.tick += movement;\n            }\n\n            try {\n                this.propagate();\n            } finally {\n                this.onStep.call(this);\n                if (this.target == this.tick) {\n                    this.stop();\n                }\n            }\n        }\n    });\n\n    kendo.deepExtend(diagram, {\n        init: function(element) {\n            kendo.init(element, diagram.ui);\n        },\n\n        Utils: Utils,\n        Range: Range,\n        Ticker: Ticker\n    });\n})(window.kendo.jQuery);\n\n(function($, undefined$1) {\n    // Imports ================================================================\n    var kendo = window.kendo,\n        diagram = kendo.dataviz.diagram,\n        Class = kendo.Class,\n        deepExtend = kendo.deepExtend,\n        dataviz = kendo.dataviz,\n        Utils = diagram.Utils,\n        Point = dataviz.Point2D,\n        isFunction = kendo.isFunction,\n        contains = Utils.contains,\n        map = $.map;\n\n    // Constants ==============================================================\n    var HITTESTAREA = 3,\n        EPSILON = 1e-06;\n\n    deepExtend(Point.fn, {\n        plus: function(p) {\n            return new Point(this.x + p.x, this.y + p.y);\n        },\n        minus: function(p) {\n            return new Point(this.x - p.x, this.y - p.y);\n        },\n        offset: function(value) {\n            return new Point(this.x - value, this.y - value);\n        },\n        times: function(s) {\n            return new Point(this.x * s, this.y * s);\n        },\n        normalize: function() {\n            if (this.length() === 0) {\n                return new Point();\n            }\n            return this.times(1 / this.length());\n        },\n        length: function() {\n            return Math.sqrt(this.x * this.x + this.y * this.y);\n        },\n        toString: function() {\n            return \"(\" + this.x + \",\" + this.y + \")\";\n        },\n        lengthSquared: function() {\n            return (this.x * this.x + this.y * this.y);\n        },\n        middleOf: function MiddleOf(p, q) {\n            return new Point(q.x - p.x, q.y - p.y).times(0.5).plus(p);\n        },\n        toPolar: function(useDegrees) {\n            var factor = 1;\n            if (useDegrees) {\n                factor = 180 / Math.PI;\n            }\n            var a = Math.atan2(Math.abs(this.y), Math.abs(this.x));\n            var halfpi = Math.PI / 2;\n            var len = this.length();\n            if (this.x === 0) {\n                // note that the angle goes down and not the usual mathematical convention\n\n                if (this.y === 0) {\n                    return new Polar(0, 0);\n                }\n                if (this.y > 0) {\n                    return new Polar(len, factor * halfpi);\n                }\n                if (this.y < 0) {\n                    return new Polar(len, factor * 3 * halfpi);\n                }\n            }\n            else if (this.x > 0) {\n                if (this.y === 0) {\n                    return new Polar(len, 0);\n                }\n                if (this.y > 0) {\n                    return new Polar(len, factor * a);\n                }\n                if (this.y < 0) {\n                    return new Polar(len, factor * (4 * halfpi - a));\n                }\n            }\n            else {\n                if (this.y === 0) {\n                    return new Polar(len, 2 * halfpi);\n                }\n                if (this.y > 0) {\n                    return new Polar(len, factor * (2 * halfpi - a));\n                }\n                if (this.y < 0) {\n                    return new Polar(len, factor * (2 * halfpi + a));\n                }\n            }\n        },\n        isOnLine: function(from, to) {\n            if (from.x > to.x) { // from must be the leftmost point\n                var temp = to;\n                to = from;\n                from = temp;\n            }\n            var r1 = new Rect(from.x, from.y).inflate(HITTESTAREA, HITTESTAREA),\n                r2 = new Rect(to.x, to.y).inflate(HITTESTAREA, HITTESTAREA), o1, u1;\n            if (r1.union(r2).contains(this)) {\n                if (from.x === to.x || from.y === to.y) {\n                    return true;\n                }\n                else if (from.y < to.y) {\n                    o1 = r1.x + (((r2.x - r1.x) * (this.y - (r1.y + r1.height))) / ((r2.y + r2.height) - (r1.y + r1.height)));\n                    u1 = (r1.x + r1.width) + ((((r2.x + r2.width) - (r1.x + r1.width)) * (this.y - r1.y)) / (r2.y - r1.y));\n                }\n                else {\n                    o1 = r1.x + (((r2.x - r1.x) * (this.y - r1.y)) / (r2.y - r1.y));\n                    u1 = (r1.x + r1.width) + ((((r2.x + r2.width) - (r1.x + r1.width)) * (this.y - (r1.y + r1.height))) / ((r2.y + r2.height) - (r1.y + r1.height)));\n                }\n                return (this.x > o1 && this.x < u1);\n            }\n            return false;\n        }\n    });\n\n    deepExtend(Point, {\n        parse: function(str) {\n            var tempStr = str.slice(1, str.length - 1),\n                xy = tempStr.split(\",\"),\n                x = parseInt(xy[0], 10),\n                y = parseInt(xy[1], 10);\n            if (!isNaN(x) && !isNaN(y)) {\n                return new Point(x, y);\n            }\n        }\n    });\n\n    /**\n     * Structure combining a Point with two additional points representing the handles or tangents attached to the first point.\n     * If the additional points are null or equal to the first point the path will be sharp.\n     * Left and right correspond to the direction of the underlying path.\n     */\n    var PathDefiner = Class.extend(\n        {\n            init: function(p, left, right) {\n                this.point = p;\n                this.left = left;\n                this.right = right;\n            }\n        }\n    );\n\n    /**\n     * Defines a rectangular region.\n     */\n    var Rect = Class.extend({\n        init: function(x, y, width, height) {\n            this.x = x || 0;\n            this.y = y || 0;\n            this.width = width || 0;\n            this.height = height || 0;\n        },\n        contains: function(point) {\n            return ((point.x >= this.x) && (point.x <= (this.x + this.width)) && (point.y >= this.y) && (point.y <= (this.y + this.height)));\n        },\n        inflate: function(dx, dy) {\n            if (dy === undefined$1) {\n                dy = dx;\n            }\n\n            this.x -= dx;\n            this.y -= dy;\n            this.width += 2 * dx + 1;\n            this.height += 2 * dy + 1;\n            return this;\n        },\n        offset: function(dx, dy) {\n            var x = dx, y = dy;\n            if (dx instanceof Point) {\n                x = dx.x;\n                y = dx.y;\n            }\n            this.x += x;\n            this.y += y;\n            return this;\n        },\n        union: function(r) {\n            var x1 = Math.min(this.x, r.x);\n            var y1 = Math.min(this.y, r.y);\n            var x2 = Math.max((this.x + this.width), (r.x + r.width));\n            var y2 = Math.max((this.y + this.height), (r.y + r.height));\n            return new Rect(x1, y1, x2 - x1, y2 - y1);\n        },\n        center: function() {\n            return new Point(this.x + this.width / 2, this.y + this.height / 2);\n        },\n        top: function() {\n            return new Point(this.x + this.width / 2, this.y);\n        },\n        right: function() {\n            return new Point(this.x + this.width, this.y + this.height / 2);\n        },\n        bottom: function() {\n            return new Point(this.x + this.width / 2, this.y + this.height);\n        },\n        left: function() {\n            return new Point(this.x, this.y + this.height / 2);\n        },\n        topLeft: function() {\n            return new Point(this.x, this.y);\n        },\n        topRight: function() {\n            return new Point(this.x + this.width, this.y);\n        },\n        bottomLeft: function() {\n            return new Point(this.x, this.y + this.height);\n        },\n        bottomRight: function() {\n            return new Point(this.x + this.width, this.y + this.height);\n        },\n        clone: function() {\n            return new Rect(this.x, this.y, this.width, this.height);\n        },\n        isEmpty: function() {\n            return !this.width && !this.height;\n        },\n        equals: function(rect) {\n            return this.x === rect.x && this.y === rect.y && this.width === rect.width && this.height === rect.height;\n        },\n        rotatedBounds: function(angle) {\n            var rect = this.clone(),\n                points = this.rotatedPoints(angle),\n                tl = points[0],\n                tr = points[1],\n                br = points[2],\n                bl = points[3];\n\n            rect.x = Math.min(br.x, tl.x, tr.x, bl.x);\n            rect.y = Math.min(br.y, tl.y, tr.y, bl.y);\n            rect.width = Math.max(br.x, tl.x, tr.x, bl.x) - rect.x;\n            rect.height = Math.max(br.y, tl.y, tr.y, bl.y) - rect.y;\n\n            return rect;\n        },\n        rotatedPoints: function(angle) {\n            var rect = this,\n                c = rect.center(),\n                br = rect.bottomRight().rotate(c, 360 - angle),\n                tl = rect.topLeft().rotate(c, 360 - angle),\n                tr = rect.topRight().rotate(c, 360 - angle),\n                bl = rect.bottomLeft().rotate(c, 360 - angle);\n\n            return [tl, tr, br, bl];\n        },\n        toString: function(delimiter) {\n            delimiter = delimiter || \" \";\n\n            return this.x + delimiter + this.y + delimiter + this.width + delimiter + this.height;\n        },\n        scale: function(scaleX, scaleY, staicPoint, adornerCenter, angle) {\n            var tl = this.topLeft();\n            var thisCenter = this.center();\n            tl.rotate(thisCenter, 360 - angle).rotate(adornerCenter, angle);\n\n            var delta = staicPoint.minus(tl);\n            var scaled = new Point(delta.x * scaleX, delta.y * scaleY);\n            var position = delta.minus(scaled);\n            tl = tl.plus(position);\n            tl.rotate(adornerCenter, 360 - angle).rotate(thisCenter, angle);\n\n            this.x = tl.x;\n            this.y = tl.y;\n\n            this.width *= scaleX;\n            this.height *= scaleY;\n        },\n\n        zoom: function(zoom) {\n            this.x *= zoom;\n            this.y *= zoom;\n            this.width *= zoom;\n            this.height *= zoom;\n            return this;\n        },\n\n        overlaps: function(rect) {\n            var bottomRight = this.bottomRight();\n            var rectBottomRight = rect.bottomRight();\n            var overlaps = !(bottomRight.x < rect.x || bottomRight.y < rect.y ||\n                rectBottomRight.x < this.x || rectBottomRight.y < this.y);\n            return overlaps;\n        }\n    });\n\n    var Size = Class.extend({\n        init: function(width, height) {\n            this.width = width;\n            this.height = height;\n        }\n    });\n\n    Size.prototype.Empty = new Size(0, 0);\n\n    Rect.toRect = function(rect) {\n        if (!(rect instanceof Rect)) {\n            rect = new Rect(rect.x, rect.y, rect.width, rect.height);\n        }\n\n        return rect;\n    };\n\n    Rect.empty = function() {\n        return new Rect(0, 0, 0, 0);\n    };\n\n    Rect.fromPoints = function(p, q) {\n        if (isNaN(p.x) || isNaN(p.y) || isNaN(q.x) || isNaN(q.y)) {\n            throw \"Some values are NaN.\";\n        }\n        return new Rect(Math.min(p.x, q.x), Math.min(p.y, q.y), Math.abs(p.x - q.x), Math.abs(p.y - q.y));\n    };\n\n    function isNearZero(num) {\n        return Math.abs(num) < EPSILON;\n    }\n\n    function intersectLine(start1, end1, start2, end2, isSegment) {\n        var tangensdiff = ((end1.x - start1.x) * (end2.y - start2.y)) - ((end1.y - start1.y) * (end2.x - start2.x));\n        if (isNearZero(tangensdiff)) {\n            //parallel lines\n            return;\n        }\n\n        var num1 = ((start1.y - start2.y) * (end2.x - start2.x)) - ((start1.x - start2.x) * (end2.y - start2.y));\n        var num2 = ((start1.y - start2.y) * (end1.x - start1.x)) - ((start1.x - start2.x) * (end1.y - start1.y));\n        var r = num1 / tangensdiff;\n        var s = num2 / tangensdiff;\n\n        if (isSegment && (r < 0 || r > 1 || s < 0 || s > 1)) {\n            //r < 0 => line 1 is below line 2\n            //r > 1 => line 1 is above line 2\n            //s < 0 => line 2 is below line 1\n            //s > 1 => line 2 is above line 1\n            return;\n        }\n\n        return new Point(start1.x + (r * (end1.x - start1.x)), start1.y + (r * (end1.y - start1.y)));\n    }\n\n    var Intersect = {\n        lines: function(start1, end1, start2, end2) {\n            return intersectLine(start1, end1, start2, end2);\n        },\n        segments: function(start1, end1, start2, end2) {\n            return intersectLine(start1, end1, start2, end2, true);\n        },\n        rectWithLine: function(rect, start, end) {\n            return Intersect.segments(start, end, rect.topLeft(), rect.topRight()) ||\n                Intersect.segments(start, end, rect.topRight(), rect.bottomRight()) ||\n                Intersect.segments(start, end, rect.bottomLeft(), rect.bottomRight()) ||\n                Intersect.segments(start, end, rect.topLeft(), rect.bottomLeft());\n        },\n        rects: function(rect1, rect2, angle) {\n            var tl = rect2.topLeft(),\n                tr = rect2.topRight(),\n                bl = rect2.bottomLeft(),\n                br = rect2.bottomRight();\n            var center = rect2.center();\n            if (angle) {\n                tl = tl.rotate(center, angle);\n                tr = tr.rotate(center, angle);\n                bl = bl.rotate(center, angle);\n                br = br.rotate(center, angle);\n            }\n\n            var intersect = rect1.contains(tl) ||\n                rect1.contains(tr) ||\n                rect1.contains(bl) ||\n                rect1.contains(br) ||\n                Intersect.rectWithLine(rect1, tl, tr) ||\n                Intersect.rectWithLine(rect1, tl, bl) ||\n                Intersect.rectWithLine(rect1, tr, br) ||\n                Intersect.rectWithLine(rect1, bl, br);\n\n            if (!intersect) {//last possible case is rect1 to be completely within rect2\n                tl = rect1.topLeft();\n                tr = rect1.topRight();\n                bl = rect1.bottomLeft();\n                br = rect1.bottomRight();\n\n                if (angle) {\n                    var reverseAngle = 360 - angle;\n                    tl = tl.rotate(center, reverseAngle);\n                    tr = tr.rotate(center, reverseAngle);\n                    bl = bl.rotate(center, reverseAngle);\n                    br = br.rotate(center, reverseAngle);\n                }\n\n                intersect = rect2.contains(tl) ||\n                    rect2.contains(tr) ||\n                    rect2.contains(bl) ||\n                    rect2.contains(br);\n            }\n\n            return intersect;\n        }\n    };\n\n    /**\n     * Aligns two rectangles, where one is the container and the other is content.\n     */\n    var RectAlign = Class.extend({\n        init: function(container) {\n            this.container = Rect.toRect(container);\n        },\n\n        align: function(content, alignment) {\n            var alignValues = alignment.toLowerCase().split(\" \");\n\n            for (var i = 0; i < alignValues.length; i++) {\n                content = this._singleAlign(content, alignValues[i]);\n            }\n\n            return content;\n        },\n        _singleAlign: function(content, alignment) {\n            if (isFunction(this[alignment])) {\n                return this[alignment](content);\n            }\n            else {\n                return content;\n            }\n        },\n\n        left: function(content) {\n            return this._align(content, this._left);\n        },\n        center: function(content) {\n            return this._align(content, this._center);\n        },\n        right: function(content) {\n            return this._align(content, this._right);\n        },\n        stretch: function(content) {\n            return this._align(content, this._stretch);\n        },\n        top: function(content) {\n            return this._align(content, this._top);\n        },\n        middle: function(content) {\n            return this._align(content, this._middle);\n        },\n        bottom: function(content) {\n            return this._align(content, this._bottom);\n        },\n\n        _left: function(container, content) {\n            content.x = container.x;\n        },\n        _center: function(container, content) {\n            content.x = ((container.width - content.width) / 2) || 0;\n        },\n        _right: function(container, content) {\n            content.x = container.width - content.width;\n        },\n        _top: function(container, content) {\n            content.y = container.y;\n        },\n        _middle: function(container, content) {\n            content.y = ((container.height - content.height) / 2) || 0;\n        },\n        _bottom: function(container, content) {\n            content.y = container.height - content.height;\n        },\n        _stretch: function(container, content) {\n            content.x = 0;\n            content.y = 0;\n            content.height = container.height;\n            content.width = container.width;\n        },\n        _align: function(content, alignCalc) {\n            content = Rect.toRect(content);\n            alignCalc(this.container, content);\n\n            return content;\n        }\n    });\n\n    var Polar = Class.extend({\n        init: function(r, a) {\n            this.r = r;\n            this.angle = a;\n        }\n    });\n\n    /**\n     * SVG transformation matrix.\n     */\n    var Matrix = Class.extend({\n        init: function(a, b, c, d, e, f) {\n            this.a = a || 0;\n            this.b = b || 0;\n            this.c = c || 0;\n            this.d = d || 0;\n            this.e = e || 0;\n            this.f = f || 0;\n        },\n        plus: function(m) {\n            this.a += m.a;\n            this.b += m.b;\n            this.c += m.c;\n            this.d += m.d;\n            this.e += m.e;\n            this.f += m.f;\n        },\n        minus: function(m) {\n            this.a -= m.a;\n            this.b -= m.b;\n            this.c -= m.c;\n            this.d -= m.d;\n            this.e -= m.e;\n            this.f -= m.f;\n        },\n        times: function(m) {\n            return new Matrix(\n                this.a * m.a + this.c * m.b,\n                this.b * m.a + this.d * m.b,\n                this.a * m.c + this.c * m.d,\n                this.b * m.c + this.d * m.d,\n                this.a * m.e + this.c * m.f + this.e,\n                this.b * m.e + this.d * m.f + this.f\n            );\n        },\n        apply: function(p) {\n            return new Point(this.a * p.x + this.c * p.y + this.e, this.b * p.x + this.d * p.y + this.f);\n        },\n        applyRect: function(r) {\n            return Rect.fromPoints(this.apply(r.topLeft()), this.apply(r.bottomRight()));\n        },\n        toString: function() {\n            return \"matrix(\" + this.a + \" \" + this.b + \" \" + this.c + \" \" + this.d + \" \" + this.e + \" \" + this.f + \")\";\n        }\n    });\n\n    deepExtend(Matrix, {\n        fromSVGMatrix: function(vm) {\n            var m = new Matrix();\n            m.a = vm.a;\n            m.b = vm.b;\n            m.c = vm.c;\n            m.d = vm.d;\n            m.e = vm.e;\n            m.f = vm.f;\n            return m;\n        },\n        fromMatrixVector: function(v) {\n            var m = new Matrix();\n            m.a = v.a;\n            m.b = v.b;\n            m.c = v.c;\n            m.d = v.d;\n            m.e = v.e;\n            m.f = v.f;\n            return m;\n        },\n        fromList: function(v) {\n            if (v.length !== 6) {\n                throw \"The given list should consist of six elements.\";\n            }\n            var m = new Matrix();\n            m.a = v[0];\n            m.b = v[1];\n            m.c = v[2];\n            m.d = v[3];\n            m.e = v[4];\n            m.f = v[5];\n            return m;\n        },\n        translation: function(x, y) {\n            var m = new Matrix();\n            m.a = 1;\n            m.b = 0;\n            m.c = 0;\n            m.d = 1;\n            m.e = x;\n            m.f = y;\n            return m;\n        },\n        unit: function() {\n            return new Matrix(1, 0, 0, 1, 0, 0);\n        },\n        rotation: function(angle, x, y) {\n            var m = new Matrix();\n            m.a = Math.cos(angle * Math.PI / 180);\n            m.b = Math.sin(angle * Math.PI / 180);\n            m.c = -m.b;\n            m.d = m.a;\n            m.e = (x - x * m.a + y * m.b) || 0;\n            m.f = (y - y * m.a - x * m.b) || 0;\n            return m;\n        },\n        scaling: function(scaleX, scaleY) {\n            var m = new Matrix();\n            m.a = scaleX;\n            m.b = 0;\n            m.c = 0;\n            m.d = scaleY;\n            m.e = 0;\n            m.f = 0;\n            return m;\n        },\n        parse: function(v) {\n            var parts, nums;\n            if (v) {\n                v = v.trim();\n                // of the form \"matrix(...)\"\n                if (v.slice(0, 6).toLowerCase() === \"matrix\") {\n                    nums = v.slice(7, v.length - 1).trim();\n                    parts = nums.split(\",\");\n                    if (parts.length === 6) {\n                        return Matrix.fromList(map(parts, function(p) {\n                            return parseFloat(p);\n                        }));\n                    }\n                    parts = nums.split(\" \");\n                    if (parts.length === 6) {\n                        return Matrix.fromList(map(parts, function(p) {\n                            return parseFloat(p);\n                        }));\n                    }\n                }\n                // of the form \"(...)\"\n                if (v.slice(0, 1) === \"(\" && v.slice(v.length - 1) === \")\") {\n                    v = v.substr(1, v.length - 1);\n                }\n                if (v.indexOf(\",\") > 0) {\n                    parts = v.split(\",\");\n                    if (parts.length === 6) {\n                        return Matrix.fromList(map(parts, function(p) {\n                            return parseFloat(p);\n                        }));\n                    }\n                }\n                if (v.indexOf(\" \") > 0) {\n                    parts = v.split(\" \");\n                    if (parts.length === 6) {\n                        return Matrix.fromList(map(parts, function(p) {\n                            return parseFloat(p);\n                        }));\n                    }\n                }\n            }\n            return parts;\n        }\n    });\n\n    /**\n     * SVG transformation represented as a vector.\n     */\n    var MatrixVector = Class.extend({\n        init: function(a, b, c, d, e, f) {\n            this.a = a || 0;\n            this.b = b || 0;\n            this.c = c || 0;\n            this.d = d || 0;\n            this.e = e || 0;\n            this.f = f || 0;\n        },\n        fromMatrix: function FromMatrix(m) {\n            var v = new MatrixVector();\n            v.a = m.a;\n            v.b = m.b;\n            v.c = m.c;\n            v.d = m.d;\n            v.e = m.e;\n            v.f = m.f;\n            return v;\n        }\n    });\n\n    /**\n     * Returns a value with Gaussian (normal) distribution.\n     * @param mean The mean value of the distribution.\n     * @param deviation The deviation (spreading at half-height) of the distribution.\n     * @returns {number}\n     */\n    function normalVariable(mean, deviation) {\n        var x, y, r;\n        do {\n            x = Math.random() * 2 - 1;\n            y = Math.random() * 2 - 1;\n            r = x * x + y * y;\n        }\n        while (!r || r > 1);\n        return mean + deviation * x * Math.sqrt(-2 * Math.log(r) / r);\n    }\n\n    /**\n     * Returns a random identifier which can be used as an ID of objects, eventually augmented with a prefix.\n     * @returns {string}\n     */\n    function randomId(length) {\n        if (Utils.isUndefined(length)) {\n            length = 10;\n        }\n        // old version return Math.floor((1 + Math.random()) * 0x1000000).toString(16).substring(1);\n        var result = '';\n        var chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n        for (var i = length; i > 0; --i) {\n            result += chars.charAt(Math.round(Math.random() * (chars.length - 1)));\n        }\n        return result;\n    }\n\n    var Geometry = {\n\n        /**\n         * Returns the squared distance to the line defined by the two given Points.\n         * @param p An arbitrary Point.\n         * @param a An endpoint of the line or segment.\n         * @param b The complementary endpoint of the line or segment.\n         */\n        _distanceToLineSquared: function(p, a, b) {\n            function d2(pt1, pt2) {\n                return (pt1.x - pt2.x) * (pt1.x - pt2.x) + (pt1.y - pt2.y) * (pt1.y - pt2.y);\n            }\n\n            if (a === b) { // returns the distance of p to a\n                return d2(p, a);\n            }\n\n            var vx = b.x - a.x,\n                vy = b.y - a.y,\n                dot = (p.x - a.x) * vx + (p.y - a.y) * vy;\n            if (dot < 0) {\n                return d2(a, p); // sits on side of a\n            }\n\n            dot = (b.x - p.x) * vx + (b.y - p.y) * vy;\n            if (dot < 0) {\n                return d2(b, p); // sits on side of b\n            }\n            // regular case, use crossproduct to get the sine out\n            dot = (b.x - p.x) * vy - (b.y - p.y) * vx;\n            return dot * dot / (vx * vx + vy * vy);\n        },\n\n        /**\n         * Returns the distance to the line defined by the two given Points.\n         * @param p An arbitrary Point.\n         * @param a An endpoint of the line or segment.\n         * @param b The complementary endpoint of the line or segment.\n         */\n        distanceToLine: function(p, a, b) {\n            return Math.sqrt(this._distanceToLineSquared(p, a, b));\n        },\n\n        /**\n         * Returns the distance of the given points to the polyline defined by the points.\n         * @param p An arbitrary point.\n         * @param points The points defining the polyline.\n         * @returns {Number}\n         */\n        distanceToPolyline: function(p, points) {\n            var minimum = Number.MAX_VALUE;\n            if (Utils.isUndefined(points) || points.length === 0) {\n                return Number.MAX_VALUE;\n            }\n            for (var s = 0; s < points.length - 1; s++) {\n                var p1 = points[s];\n                var p2 = points[s + 1];\n\n                var d = this._distanceToLineSquared(p, p1, p2);\n                if (d < minimum) {\n                    minimum = d;\n                }\n            }\n            return Math.sqrt(minimum);\n        }\n    };\n\n    /*---------------The HashTable structure--------------------------------*/\n\n    /**\n     * Represents a collection of key-value pairs that are organized based on the hash code of the key.\n     * _buckets[hashId] = {key: key, value:...}\n     * Important: do not use the standard Array access method, use the get/set methods instead.\n     * See http://en.wikipedia.org/wiki/Hash_table\n     */\n    var HashTable = kendo.Class.extend({\n        init: function() {\n            this._buckets = [];\n            this.length = 0;\n        },\n\n        /**\n         * Adds the literal object with the given key (of the form {key: key,....}).\n         */\n        add: function(key, value) {\n\n            var obj = this._createGetBucket(key);\n            if (Utils.isDefined(value)) {\n                obj.value = value;\n            }\n            return obj;\n        },\n\n        /**\n         * Gets the literal object with the given key.\n         */\n        get: function(key) {\n            if (this._bucketExists(key)) {\n                return this._createGetBucket(key);\n            }\n            return null;\n        },\n\n        /**\n         * Set the key-value pair.\n         * @param key The key of the entry.\n         * @param value The value to set. If the key already exists the value will be overwritten.\n         */\n        set: function(key, value) {\n            this.add(key, value);\n        },\n\n        /**\n         * Determines whether the HashTable contains a specific key.\n         */\n        containsKey: function(key) {\n            return this._bucketExists(key);\n        },\n\n        /**\n         * Removes the element with the specified key from the hashtable.\n         * Returns the removed bucket.\n         */\n        remove: function(key) {\n            if (this._bucketExists(key)) {\n                var hashId = this._hash(key);\n                delete this._buckets[hashId];\n                this.length--;\n                return key;\n            }\n        },\n\n        /**\n         * Foreach with an iterator working on the key-value pairs.\n         * @param func\n         */\n        forEach: function(func) {\n            var hashes = this._hashes();\n            for (var i = 0, len = hashes.length; i < len; i++) {\n                var hash = hashes[i];\n                var bucket = this._buckets[hash];\n                if (Utils.isUndefined(bucket)) {\n                    continue;\n                }\n                func(bucket);\n            }\n        },\n\n        /**\n         * Returns a (shallow) clone of the current HashTable.\n         * @returns {HashTable}\n         */\n        clone: function() {\n            var ht = new HashTable();\n            var hashes = this._hashes();\n            for (var i = 0, len = hashes.length; i < len; i++) {\n                var hash = hashes[i];\n                var bucket = this._buckets[hash];\n                if (Utils.isUndefined(bucket)) {\n                    continue;\n                }\n                ht.add(bucket.key, bucket.value);\n            }\n            return ht;\n        },\n\n        /**\n         * Returns the hashes of the buckets.\n         * @returns {Array}\n         * @private\n         */\n        _hashes: function() {\n            var hashes = [];\n            for (var hash in this._buckets) {\n                if (this._buckets.hasOwnProperty(hash)) {\n                    hashes.push(hash);\n                }\n            }\n            return hashes;\n        },\n\n        _bucketExists: function(key) {\n            var hashId = this._hash(key);\n            return Utils.isDefined(this._buckets[hashId]);\n        },\n\n        /**\n         * Returns-adds the createGetBucket with the given key. If not present it will\n         * be created and returned.\n         * A createGetBucket is a literal object of the form {key: key, ...}.\n         */\n        _createGetBucket: function(key) {\n            var hashId = this._hash(key);\n            var bucket = this._buckets[hashId];\n            if (Utils.isUndefined(bucket)) {\n                bucket = { key: key };\n                this._buckets[hashId] = bucket;\n                this.length++;\n            }\n            return bucket;\n        },\n\n        /**\n         * Hashing of the given key.\n         */\n        _hash: function(key) {\n            if (Utils.isNumber(key)) {\n                return key;\n            }\n            if (Utils.isString(key)) {\n                return this._hashString(key);\n            }\n            if (Utils.isObject(key)) {\n                return this._objectHashId(key);\n            }\n            throw \"Unsupported key type.\";\n        },\n\n        /**\n         * Hashing of a string.\n         */\n        _hashString: function(s) {\n            // see for example http://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery\n            var result = 0;\n            if (s.length === 0) {\n                return result;\n            }\n            for (var i = 0; i < s.length; i++) {\n                var ch = s.charCodeAt(i);\n                result = ((result * 32) - result) + ch;\n            }\n            return result;\n        },\n\n        /**\n         * Returns the unique identifier for an object. This is automatically assigned and add on the object.\n         */\n        _objectHashId: function(key) {\n            var id = key._hashId;\n            if (Utils.isUndefined(id)) {\n                id = randomId();\n                key._hashId = id;\n            }\n            return id;\n        }\n    });\n\n    /*---------------The Dictionary structure--------------------------------*/\n\n    /**\n     * Represents a collection of key-value pairs.\n     * Important: do not use the standard Array access method, use the get/Set methods instead.\n     */\n    var Dictionary = kendo.Observable.extend({\n        /**\n         * Initializes a new instance of the Dictionary class.\n         * @param dictionary Loads the content of the given dictionary into this new one.\n         */\n        init: function(dictionary) {\n            var that = this;\n            kendo.Observable.fn.init.call(that);\n            this._hashTable = new HashTable();\n            this.length = 0;\n            if (Utils.isDefined(dictionary)) {\n                if (Array.isArray(dictionary)) {\n                    for (var i = 0; i < dictionary.length; i++) {\n                        this.add(dictionary[i]);\n                    }\n                } else {\n                    dictionary.forEach(function(k, v) {\n                        this.add(k, v);\n                    }, this);\n                }\n            }\n        },\n\n        /**\n         * Adds a key-value to the dictionary.\n         * If the key already exists this will assign the given value to the existing entry.\n         */\n        add: function(key, value) {\n            var entry = this._hashTable.get(key);\n            if (!entry) {\n                entry = this._hashTable.add(key);\n                this.length++;\n                this.trigger('changed');\n            }\n            entry.value = value;\n        },\n\n        /**\n         * Set the key-value pair.\n         * @param key The key of the entry.\n         * @param value The value to set. If the key already exists the value will be overwritten.\n         */\n        set: function(key, value) {\n            this.add(key, value);\n        },\n\n        /**\n         * Gets the value associated with the given key in the dictionary.\n         */\n        get: function(key) {\n            var entry = this._hashTable.get(key);\n            if (entry) {\n                return entry.value;\n            }\n            throw new Error(\"Cannot find key \" + key);\n        },\n\n        /**\n         * Returns whether the dictionary contains the given key.\n         */\n        containsKey: function(key) {\n            return this._hashTable.containsKey(key);\n        },\n\n        /**\n         * Removes the element with the specified key from the dictionary.\n         */\n        remove: function(key) {\n            if (this.containsKey(key)) {\n                this.trigger(\"changed\");\n                this.length--;\n                return this._hashTable.remove(key);\n            }\n        },\n\n        /**\n         * The functional gets the key and value as parameters.\n         */\n        forEach: function(func, thisRef) {\n            this._hashTable.forEach(function(entry) {\n                func.call(thisRef, entry.key, entry.value);\n            });\n        },\n\n        /**\n         * Same as forEach except that only the value is passed to the functional.\n         */\n        forEachValue: function(func, thisRef) {\n            this._hashTable.forEach(function(entry) {\n                func.call(thisRef, entry.value);\n            });\n        },\n\n        /**\n         * Calls a defined callback function for each key in the dictionary.\n         */\n        forEachKey: function(func, thisRef) {\n            this._hashTable.forEach(function(entry) {\n                func.call(thisRef, entry.key);\n            });\n        },\n\n        /**\n         * Gets an array with all keys in the dictionary.\n         */\n        keys: function() {\n            var keys = [];\n            this.forEachKey(function(key) {\n                keys.push(key);\n            });\n            return keys;\n        }\n    });\n\n    /*---------------Queue structure--------------------------------*/\n\n    var Queue = kendo.Class.extend({\n\n        init: function() {\n            this._tail = null;\n            this._head = null;\n            this.length = 0;\n        },\n\n        /**\n         * Enqueues an object to the end of the queue.\n         */\n        enqueue: function(value) {\n            var entry = { value: value, next: null };\n            if (!this._head) {\n                this._head = entry;\n                this._tail = this._head;\n            }\n            else {\n                this._tail.next = entry;\n                this._tail = this._tail.next;\n            }\n            this.length++;\n        },\n\n        /**\n         * Removes and returns the object at top of the queue.\n         */\n        dequeue: function() {\n            if (this.length < 1) {\n                throw new Error(\"The queue is empty.\");\n            }\n            var value = this._head.value;\n            this._head = this._head.next;\n            this.length--;\n            return value;\n        },\n\n        contains: function(item) {\n            var current = this._head;\n            while (current) {\n                if (current.value === item) {\n                    return true;\n                }\n                current = current.next;\n            }\n            return false;\n        }\n    });\n\n\n    /**\n     * While other data structures can have multiple times the same item a Set owns only\n     * once a particular item.\n     * @type {*}\n     */\n    var Set = kendo.Observable.extend({\n        init: function(resource) {\n            var that = this;\n            kendo.Observable.fn.init.call(that);\n            this._hashTable = new HashTable();\n            this.length = 0;\n            if (Utils.isDefined(resource)) {\n                if (resource instanceof HashTable) {\n                    resource.forEach(function(d) {\n                        this.add(d);\n                    });\n                }\n                else if (resource instanceof Dictionary) {\n                    resource.forEach(function(k, v) {\n                        this.add({ key: k, value: v });\n                    }, this);\n                }\n            }\n        },\n\n        contains: function(item) {\n            return this._hashTable.containsKey(item);\n        },\n\n        add: function(item) {\n            var entry = this._hashTable.get(item);\n            if (!entry) {\n                this._hashTable.add(item, item);\n                this.length++;\n                this.trigger('changed');\n            }\n        },\n\n        get: function(item) {\n            if (this.contains(item)) {\n                return this._hashTable.get(item).value;\n            }\n            else {\n                return null;\n            }\n        },\n\n        /**\n         * Returns the hash of the item.\n         * @param item\n         * @returns {*}\n         */\n        hash: function(item) {\n            return this._hashTable._hash(item);\n        },\n\n        /**\n         * Removes the given item from the set. No exception is thrown if the item is not in the Set.\n         * @param item\n         */\n        remove: function(item) {\n            if (this.contains(item)) {\n                this._hashTable.remove(item);\n                this.length--;\n                this.trigger('changed');\n            }\n        },\n        /**\n         * Foreach with an iterator working on the key-value pairs.\n         * @param func\n         */\n        forEach: function(func, context) {\n            this._hashTable.forEach(function(kv) {\n                func(kv.value);\n            }, context);\n        },\n        toArray: function() {\n            var r = [];\n            this.forEach(function(d) {\n                r.push(d);\n            });\n            return r;\n        }\n    });\n\n    /*----------------Node-------------------------------*/\n\n    /**\n     * Defines the node (vertex) of a Graph.\n     */\n    var Node = kendo.Class.extend({\n\n        init: function(id, shape) {\n\n            /**\n             * Holds all the links incident with the current node.\n             * Do not use this property to manage the incoming links, use the appropriate add/remove methods instead.\n             */\n            this.links = [];\n\n            /**\n             * Holds the links from the current one to another Node .\n             * Do not use this property to manage the incoming links, use the appropriate add/remove methods instead.\n             */\n            this.outgoing = [];\n\n            /**\n             * Holds the links from another Node to the current one.\n             * Do not use this property to manage the incoming links, use the appropriate add/remove methods instead.\n             */\n            this.incoming = [];\n\n            /**\n             * Holds the weight of this Node.\n             */\n            this.weight = 1;\n\n            if (Utils.isDefined(id)) {\n                this.id = id;\n            }\n            else {\n                this.id = randomId();\n            }\n            if (Utils.isDefined(shape)) {\n                this.associatedShape = shape;\n                // transfer the shape's bounds to the runtime props\n                var b = shape.bounds();\n                this.width = b.width;\n                this.height = b.height;\n                this.x = b.x;\n                this.y = b.y;\n            }\n            else {\n                this.associatedShape = null;\n            }\n            /**\n             * The payload of the node.\n             * @type {null}\n             */\n            this.data = null;\n            this.type = \"Node\";\n            this.shortForm = \"Node '\" + this.id + \"'\";\n            /**\n             * Whether this is an injected node during the analysis or layout process.\n             * @type {boolean}\n             */\n            this.isVirtual = false;\n        },\n\n        /**\n         * Returns whether this node has no links attached.\n         */\n        isIsolated: function() {\n            return Utils.isEmpty(this.links);\n        },\n\n        /**\n         * Gets or sets the bounding rectangle of this node.\n         * This should be considered as runtime data, the property is not hotlinked to a SVG item.\n         */\n        bounds: function(r) {\n            if (!Utils.isDefined(r)) {\n                return new diagram.Rect(this.x, this.y, this.width, this.height);\n            }\n\n            this.x = r.x;\n            this.y = r.y;\n            this.width = r.width;\n            this.height = r.height;\n        },\n\n        /**\n         * Returns whether there is at least one link with the given (complementary) node. This can be either an\n         * incoming or outgoing link.\n         */\n        isLinkedTo: function(node) {\n            var that = this;\n            return Utils.any(that.links, function(link) {\n                return link.getComplement(that) === node;\n            });\n        },\n\n        /**\n         * Gets the children of this node, defined as the adjacent nodes with a link from this node to the adjacent one.\n         * @returns {Array}\n         */\n        getChildren: function() {\n            if (this.outgoing.length === 0) {\n                return [];\n            }\n            var children = [];\n            for (var i = 0, len = this.outgoing.length; i < len; i++) {\n                var link = this.outgoing[i];\n                children.push(link.getComplement(this));\n            }\n            return children;\n        },\n\n        /**\n         * Gets the parents of this node, defined as the adjacent nodes with a link from the adjacent node to this one.\n         * @returns {Array}\n         */\n        getParents: function() {\n            if (this.incoming.length === 0) {\n                return [];\n            }\n            var parents = [];\n            for (var i = 0, len = this.incoming.length; i < len; i++) {\n                var link = this.incoming[i];\n                parents.push(link.getComplement(this));\n            }\n            return parents;\n        },\n\n        /**\n         * Returns a clone of the Node. Note that the identifier is not cloned since it's a different Node instance.\n         * @returns {Node}\n         */\n        clone: function() {\n            var copy = new Node();\n            if (Utils.isDefined(this.weight)) {\n                copy.weight = this.weight;\n            }\n            if (Utils.isDefined(this.balance)) {\n                copy.balance = this.balance;\n            }\n            if (Utils.isDefined(this.owner)) {\n                copy.owner = this.owner;\n            }\n            copy.associatedShape = this.associatedShape;\n            copy.x = this.x;\n            copy.y = this.y;\n            copy.width = this.width;\n            copy.height = this.height;\n            return copy;\n        },\n\n        /**\n         * Returns whether there is a link from the current node to the given node.\n         */\n        adjacentTo: function(node) {\n            return this.isLinkedTo(node) !== null;\n        },\n\n        /**\n         * Removes the given link from the link collection this node owns.\n         * @param link\n         */\n        removeLink: function(link) {\n            if (link.source === this) {\n                Utils.remove(this.links, link);\n                Utils.remove(this.outgoing, link);\n                link.source = null;\n            }\n\n            if (link.target === this) {\n                Utils.remove(this.links, link);\n                Utils.remove(this.incoming, link);\n                link.target = null;\n            }\n        },\n\n        /**\n         * Returns whether there is a (outgoing) link from the current node to the given one.\n         */\n        hasLinkTo: function(node) {\n            return Utils.any(this.outgoing, function(link) {\n                return link.target === node;\n            });\n        },\n\n        /**\n         * Returns the degree of this node, i.e. the sum of incoming and outgoing links.\n         */\n        degree: function() {\n            return this.links.length;\n        },\n\n        /**\n         * Returns whether this node is either the source or the target of the given link.\n         */\n        incidentWith: function(link) {\n            return contains(this.links, link);\n        },\n\n        /**\n         * Returns the links between this node and the given one.\n         */\n        getLinksWith: function(node) {\n            return Utils.all(this.links, function(link) {\n                return link.getComplement(this) === node;\n            }, this);\n        },\n\n        /**\n         * Returns the nodes (either parent or child) which are linked to the current one.\n         */\n        getNeighbors: function() {\n            var neighbors = [];\n            Utils.forEach(this.incoming, function(e) {\n                neighbors.push(e.getComplement(this));\n            }, this);\n            Utils.forEach(this.outgoing, function(e) {\n                neighbors.push(e.getComplement(this));\n            }, this);\n            return neighbors;\n        }\n    });\n\n    /**\n     * Defines a directed link (edge, connection) of a Graph.\n     */\n    var Link = kendo.Class.extend({\n\n        init: function(source, target, id, connection) {\n            if (Utils.isUndefined(source)) {\n                throw \"The source of the new link is not set.\";\n            }\n            if (Utils.isUndefined(target)) {\n                throw \"The target of the new link is not set.\";\n            }\n            var sourceFound, targetFound;\n            if (Utils.isString(source)) {\n                sourceFound = new Node(source);\n            }\n            else {\n                sourceFound = source;\n            }\n            if (Utils.isString(target)) {\n                targetFound = new Node(target);\n            }\n            else {\n                targetFound = target;\n            }\n\n            this.source = sourceFound;\n            this.target = targetFound;\n            this.source.links.push(this);\n            this.target.links.push(this);\n            this.source.outgoing.push(this);\n            this.target.incoming.push(this);\n            if (Utils.isDefined(id)) {\n                this.id = id;\n            }\n            else {\n                this.id = randomId();\n            }\n            if (Utils.isDefined(connection)) {\n                this.associatedConnection = connection;\n            }\n            else {\n                this.associatedConnection = null;\n            }\n            this.type = \"Link\";\n            this.shortForm = \"Link '\" + this.source.id + \"->\" + this.target.id + \"'\";\n        },\n\n        /**\n         * Returns the complementary node of the given one, if any.\n         */\n        getComplement: function(node) {\n            if (this.source !== node && this.target !== node) {\n                throw \"The given node is not incident with this link.\";\n            }\n            return this.source === node ? this.target : this.source;\n        },\n\n        /**\n         * Returns the overlap of the current link with the given one, if any.\n         */\n        getCommonNode: function(link) {\n            if (this.source === link.source || this.source === link.target) {\n                return this.source;\n            }\n            if (this.target === link.source || this.target === link.target) {\n                return this.target;\n            }\n            return null;\n        },\n\n        /**\n         * Returns whether the current link is bridging the given nodes.\n         */\n        isBridging: function(v1, v2) {\n            return this.source === v1 && this.target === v2 || this.source === v2 && this.target === v1;\n        },\n\n        /**\n         * Returns the source and target of this link as a tuple.\n         */\n        getNodes: function() {\n            return [this.source, this.target];\n        },\n\n        /**\n         * Returns whether the given node is either the source or the target of the current link.\n         */\n        incidentWith: function(node) {\n            return this.source === node || this.target === node;\n        },\n\n        /**\n         * Returns whether the given link is a continuation of the current one. This can be both\n         * via an incoming or outgoing link.\n         */\n        adjacentTo: function(link) {\n            return contains(this.source.links, link) || contains(this.target.links, link);\n        },\n\n        /**\n         * Changes the source-node of this link.\n         */\n        changeSource: function(node) {\n            Utils.remove(this.source.links, this);\n            Utils.remove(this.source.outgoing, this);\n\n            node.links.push(this);\n            node.outgoing.push(this);\n\n            this.source = node;\n        },\n\n        /**\n         * Changes the target-node of this link.\n         * @param node\n         */\n        changeTarget: function(node) {\n            Utils.remove(this.target.links, this);\n            Utils.remove(this.target.incoming, this);\n\n            node.links.push(this);\n            node.incoming.push(this);\n\n            this.target = node;\n        },\n\n        /**\n         * Changes both the source and the target nodes of this link.\n         */\n        changesNodes: function(v, w) {\n            if (this.source === v) {\n                this.changeSource(w);\n            }\n            else if (this.target === v) {\n                this.changeTarget(w);\n            }\n        },\n\n        /**\n         * Reverses the direction of this link.\n         */\n        reverse: function() {\n            var oldSource = this.source;\n            var oldTarget = this.target;\n\n            this.source = oldTarget;\n            Utils.remove(oldSource.outgoing, this);\n            this.source.outgoing.push(this);\n\n            this.target = oldSource;\n            Utils.remove(oldTarget.incoming, this);\n            this.target.incoming.push(this);\n            return this;\n        },\n\n        /**\n         * Ensures that the given target defines the endpoint of this link.\n         */\n        directTo: function(target) {\n            if (this.source !== target && this.target !== target) {\n                throw \"The given node is not incident with this link.\";\n            }\n            if (this.target !== target) {\n                this.reverse();\n            }\n        },\n\n        /**\n         * Returns a reversed clone of this link.\n         */\n        createReverseEdge: function() {\n            var r = this.clone();\n            r.reverse();\n            r.reversed = true;\n            return r;\n        },\n\n        /**\n         * Returns a clone of this link.\n         */\n        clone: function() {\n            var clone = new Link(this.source, this.target);\n            return clone;\n        }\n    });\n\n    /*--------------Graph structure---------------------------------*/\n    /**\n     * Defines a directed graph structure.\n     * Note that the incidence structure resides in the nodes through the incoming and outgoing links collection, rahter than\n     * inside the Graph.\n     */\n    var Graph = kendo.Class.extend({\n        init: function(idOrDiagram) {\n            /**\n             * The links or edge collection of this Graph.\n             * @type {Array}\n             */\n            this.links = [];\n            /**\n             * The node or vertex collection of this Graph.\n             * @type {Array}\n             */\n            this.nodes = [];\n\n            this._nodeMap = new Dictionary();\n            /**\n             * The optional reference to the Diagram on which this Graph is based.\n             * @type {null}\n             */\n            this.diagram = null;\n\n            /**\n             * The root of this Graph. If not set explicitly the first Node with zero incoming links will be taken.\n             * @type {null}\n             * @private\n             */\n            this._root = null;\n            if (Utils.isDefined(idOrDiagram)) {\n                if (Utils.isString(idOrDiagram)) {\n                    this.id = idOrDiagram;\n                }\n                else {\n                    this.diagram = idOrDiagram;\n                    this.id = idOrDiagram.id;\n                }\n            }\n            else {\n                this.id = randomId();\n            }\n\n            /**\n             * The bounds of this graph if the nodes have spatial extension defined.\n             * @type {Rect}\n             */\n            this.bounds = new Rect();\n            // keeps track whether the children & parents have been created\n            this._hasCachedRelationships = false;\n            this.type = \"Graph\";\n        },\n        /**\n         * Caches the relational information of parents and children in the 'parents' and 'children'\n         * properties.\n         * @param forceRebuild If set to true the relational info will be rebuild even if already present.\n         */\n        cacheRelationships: function(forceRebuild) {\n            if (Utils.isUndefined(forceRebuild)) {\n                forceRebuild = false;\n            }\n            if (this._hasCachedRelationships && !forceRebuild) {\n                return;\n            }\n            for (var i = 0, len = this.nodes.length; i < len; i++) {\n                var node = this.nodes[i];\n                node.children = this.getChildren(node);\n                node.parents = this.getParents(node);\n            }\n            this._hasCachedRelationships = true;\n        },\n\n        /**\n         * Assigns tree-levels to the nodes assuming this is a tree graph.\n         * If not connected or not a tree the process will succeed but\n         * will have little meaning.\n         * @param startNode The node from where the level numbering starts, usually the root of the tree.\n         * @param visited The collection of visited nodes.\n         * @param offset The offset or starting counter of the level info.\n         */\n        assignLevels: function(startNode, offset, visited) {\n            if (!startNode) {\n                throw \"Start node not specified.\";\n            }\n            if (Utils.isUndefined(offset)) {\n                offset = 0;\n            }\n            // if not done before, cache the parents and children\n            this.cacheRelationships();\n            if (Utils.isUndefined(visited)) {\n                visited = new Dictionary();\n                Utils.forEach(this.nodes, function(n) {\n                    visited.add(n, false);\n                });\n            }\n            visited.set(startNode, true);\n            startNode.level = offset;\n            var children = startNode.children;\n            for (var i = 0, len = children.length; i < len; i++) {\n                var child = children[i];\n                if (!child || visited.get(child)) {\n                    continue;\n                }\n                this.assignLevels(child, offset + 1, visited);\n            }\n        },\n\n        /**\n         * Gets or set the root of this graph.\n         * If not set explicitly the first Node with zero incoming links will be taken.\n         * @param value\n         * @returns {*}\n         */\n        root: function(value) {\n            if (Utils.isUndefined(value)) {\n                if (!this._root) {\n                    // TODO: better to use the longest path for the most probable root?\n                    var found = Utils.first(this.nodes, function(n) {\n                        return n.incoming.length === 0;\n                    });\n                    if (found) {\n                        return found;\n                    }\n                    return Utils.first(this.nodes);\n                }\n                else {\n                    return this._root;\n                }\n            }\n            else {\n                this._root = value;\n            }\n        },\n\n        /**\n         * Returns the connected components of this graph.\n         * Note that the returned graphs are made up of the nodes and links of this graph, i.e. a pointer to the items of this graph.\n         * If you alter the items of the components you'll alter the original graph and vice versa.\n         * @returns {Array}\n         */\n        getConnectedComponents: function() {\n            this.componentIndex = 0;\n            this.setItemIndices();\n            var componentId = Utils.initArray(this.nodes.length, -1);\n\n            for (var v = 0; v < this.nodes.length; v++) {\n                if (componentId[v] === -1) {\n                    this._collectConnectedNodes(componentId, v);\n                    this.componentIndex++;\n                }\n            }\n\n            var components = [], i;\n            for (i = 0; i < this.componentIndex; ++i) {\n                components[i] = new Graph();\n            }\n            for (i = 0; i < componentId.length; ++i) {\n                var graph = components[componentId[i]];\n                graph.addNodeAndOutgoings(this.nodes[i]);\n            }\n            // sorting the components in decreasing order of node count\n            components.sort(function(a, b) {\n                return b.nodes.length - a.nodes.length;\n            });\n            return components;\n        },\n\n        _collectConnectedNodes: function(setIds, nodeIndex) {\n            setIds[nodeIndex] = this.componentIndex; // part of the current component\n            var node = this.nodes[nodeIndex];\n            Utils.forEach(node.links,\n                function(link) {\n                    var next = link.getComplement(node);\n                    var nextId = next.index;\n                    if (setIds[nextId] === -1) {\n                        this._collectConnectedNodes(setIds, nextId);\n                    }\n                }, this);\n        },\n\n        /**\n         * Calculates the bounds of this Graph if the Nodes have spatial dimensions defined.\n         * @returns {Rect}\n         */\n        calcBounds: function() {\n            if (this.isEmpty()) {\n                this.bounds = new Rect();\n                return this.bounds;\n            }\n            var b = null;\n            for (var i = 0, len = this.nodes.length; i < len; i++) {\n                var node = this.nodes[i];\n                if (!b) {\n                    b = node.bounds();\n                }\n                else {\n                    b = b.union(node.bounds());\n                }\n            }\n            this.bounds = b;\n            return this.bounds;\n        },\n\n        /**\n         * Creates a spanning tree for the current graph.\n         * Important: this will not return a spanning forest if the graph is disconnected.\n         * Prim's algorithm  finds a minimum-cost spanning tree of an edge-weighted, connected, undirected graph;\n         * see http://en.wikipedia.org/wiki/Prim%27s_algorithm .\n         * @param root The root of the spanning tree.\n         * @returns {Graph}\n         */\n        getSpanningTree: function(root) {\n            var tree = new Graph();\n            var map = new Dictionary(), source, target;\n            tree.root = root.clone();\n            tree.root.level = 0;\n            tree.root.id = root.id;\n            map.add(root, tree.root);\n            root.level = 0;\n\n            var visited = [];\n            var remaining = [];\n            tree._addNode(tree.root);\n            visited.push(root);\n            remaining.push(root);\n\n            var levelCount = 1;\n            while (remaining.length > 0) {\n                var next = remaining.pop();\n                for (var ni = 0; ni < next.links.length; ni++) {\n                    var link = next.links[ni];\n                    var cn = link.getComplement(next);\n                    if (contains(visited, cn)) {\n                        continue;\n                    }\n\n                    cn.level = next.level + 1;\n                    if (levelCount < cn.level + 1) {\n                        levelCount = cn.level + 1;\n                    }\n                    if (!contains(remaining, cn)) {\n                        remaining.push(cn);\n                    }\n                    if (!contains(visited, cn)) {\n                        visited.push(cn);\n                    }\n                    if (map.containsKey(next)) {\n                        source = map.get(next);\n                    }\n                    else {\n                        source = next.clone();\n                        source.level = next.level;\n                        source.id = next.id;\n                        map.add(next, source);\n                    }\n                    if (map.containsKey(cn)) {\n                        target = map.get(cn);\n                    }\n                    else {\n                        target = cn.clone();\n                        target.level = cn.level;\n                        target.id = cn.id;\n                        map.add(cn, target);\n                    }\n                    var newLink = new Link(source, target);\n                    tree.addLink(newLink);\n                }\n\n            }\n\n            var treeLevels = [];\n            for (var i = 0; i < levelCount; i++) {\n                treeLevels.push([]);\n            }\n\n            Utils.forEach(tree.nodes, function(node) {\n                treeLevels[node.level].push(node);\n            });\n\n            tree.treeLevels = treeLevels;\n            tree.cacheRelationships();\n            return tree;\n        },\n\n        /**\n         * Returns a random node in this graph.\n         * @param excludedNodes The collection of nodes which should not be considered.\n         * @param incidenceLessThan The maximum degree or incidence the random node should have.\n         * @returns {*}\n         */\n        takeRandomNode: function(excludedNodes, incidenceLessThan) {\n            if (Utils.isUndefined(excludedNodes)) {\n                excludedNodes = [];\n            }\n            if (Utils.isUndefined(incidenceLessThan)) {\n                incidenceLessThan = 4;\n            }\n            if (this.nodes.length === 0) {\n                return null;\n            }\n            if (this.nodes.length === 1) {\n                return contains(excludedNodes, this.nodes[0]) ? null : this.nodes[0];\n            }\n            var pool = $.grep(this.nodes, function(node) {\n                return !contains(excludedNodes, node) && node.degree() <= incidenceLessThan;\n            });\n            if (Utils.isEmpty(pool)) {\n                return null;\n            }\n            return pool[Utils.randomInteger(0, pool.length)];\n        },\n\n        /**\n         * Returns whether this is an empty graph.\n         */\n        isEmpty: function() {\n            return Utils.isEmpty(this.nodes);\n        },\n\n        /**\n         * Checks whether the endpoints of the links are all in the nodes collection.\n         */\n        isHealthy: function() {\n            return Utils.all(this.links, function(link) {\n                return contains(this.nodes, link.source) && contains(this.nodes, link.target);\n            }, this);\n        },\n\n        /**\n         * Gets the parents of this node, defined as the adjacent nodes with a link from the adjacent node to this one.\n         * @returns {Array}\n         */\n        getParents: function(n) {\n            if (!this.hasNode(n)) {\n                throw \"The given node is not part of this graph.\";\n            }\n            return n.getParents();\n        },\n\n        /**\n         * Gets the children of this node, defined as the adjacent nodes with a link from this node to the adjacent one.\n         * @returns {Array}\n         */\n        getChildren: function(n) {\n            if (!this.hasNode(n)) {\n                throw \"The given node is not part of this graph.\";\n            }\n            return n.getChildren();\n        },\n\n        /**\n         * Adds a new link to the graph between the given nodes.\n         */\n        addLink: function(sourceOrLink, target, owner) {\n\n            if (Utils.isUndefined(sourceOrLink)) {\n                throw \"The source of the link is not defined.\";\n            }\n            if (Utils.isUndefined(target)) {\n                // can only be undefined if the first one is a Link\n                if (Utils.isDefined(sourceOrLink.type) && sourceOrLink.type === \"Link\") {\n                    this.addExistingLink(sourceOrLink);\n                    return;\n                }\n                else {\n                    throw \"The target of the link is not defined.\";\n                }\n            }\n\n            var foundSource = this.getNode(sourceOrLink);\n            if (Utils.isUndefined(foundSource)) {\n                foundSource = this.addNode(sourceOrLink);\n            }\n            var foundTarget = this.getNode(target);\n            if (Utils.isUndefined(foundTarget)) {\n                foundTarget = this.addNode(target);\n            }\n\n            var newLink = new Link(foundSource, foundTarget);\n\n            if (Utils.isDefined(owner)) {\n                newLink.owner = owner;\n            }\n\n            /*newLink.source.outgoing.push(newLink);\n             newLink.source.links.push(newLink);\n             newLink.target.incoming.push(newLink);\n             newLink.target.links.push(newLink);*/\n\n            this.links.push(newLink);\n\n            return newLink;\n        },\n\n        /**\n         * Removes all the links in this graph.\n         */\n        removeAllLinks: function() {\n            while (this.links.length > 0) {\n                var link = this.links[0];\n                this.removeLink(link);\n            }\n        },\n\n        /**\n         * Adds the given link to the current graph.\n         */\n        addExistingLink: function(link) {\n\n            if (this.hasLink(link)) {\n                return;\n            }\n            this.links.push(link);\n            if (this.hasNode(link.source.id)) {\n                // priority to the existing node with the id even if other props are different\n                var s = this.getNode(link.source.id);\n                link.changeSource(s);\n            }\n            else {\n                this.addNode(link.source);\n            }\n\n            if (this.hasNode(link.target.id)) {\n                var t = this.getNode(link.target.id);\n                link.changeTarget(t);\n            }\n            else {\n                this.addNode(link.target);\n            }\n\n            /*  if (!link.source.outgoing.contains(link)) {\n             link.source.outgoing.push(link);\n             }\n             if (!link.source.links.contains(link)) {\n             link.source.links.push(link);\n             }\n             if (!link.target.incoming.contains(link)) {\n             link.target.incoming.push(link);\n             }\n             if (!link.target.links.contains(link)) {\n             link.target.links.push(link);\n             }*/\n        },\n\n        /**\n         * Returns whether the given identifier or Link is part of this graph.\n         * @param linkOrId An identifier or a Link object.\n         * @returns {*}\n         */\n        hasLink: function(linkOrId) {\n            if (Utils.isString(linkOrId)) {\n                return Utils.any(this.links, function(link) {\n                    return link.id === linkOrId;\n                });\n            }\n            if (linkOrId.type === \"Link\") {\n                return contains(this.links, linkOrId);\n            }\n            throw \"The given object is neither an identifier nor a Link.\";\n        },\n        /**\n         * Gets the node with the specified Id or null if not part of this graph.\n         */\n        getNode: function(nodeOrId) {\n            var id = nodeOrId.id || nodeOrId;\n            if (this._nodeMap.containsKey(id)) {\n                return this._nodeMap.get(id);\n            }\n        },\n\n        /**\n         * Returns whether the given node or node Id is part of this graph.\n         */\n        hasNode: function(nodeOrId) {\n            var id = nodeOrId.id || nodeOrId;\n            return this._nodeMap.containsKey(id);\n        },\n\n        _addNode: function(node) {\n            this.nodes.push(node);\n            this._nodeMap.add(node.id, node);\n        },\n\n        _removeNode: function(node) {\n            Utils.remove(this.nodes, node);\n            this._nodeMap.remove(node.id);\n        },\n\n        /**\n         * Removes the given node from this graph.\n         * The node can be specified as an object or as an identifier (string).\n         */\n        removeNode: function(nodeOrId) {\n            var n = nodeOrId;\n            if (Utils.isString(nodeOrId)) {\n                n = this.getNode(nodeOrId);\n            }\n\n            if (Utils.isDefined(n)) {\n                var links = n.links;\n                n.links = [];\n                for (var i = 0, len = links.length; i < len; i++) {\n                    var link = links[i];\n                    this.removeLink(link);\n                }\n                this._removeNode(n);\n            }\n            else {\n                throw \"The identifier should be a Node or the Id (string) of a node.\";\n            }\n        },\n\n        /**\n         * Returns whether the given nodes are connected with a least one link independently of the direction.\n         */\n        areConnected: function(n1, n2) {\n            return Utils.any(this.links, function(link) {\n                return link.source == n1 && link.target == n2 || link.source == n2 && link.target == n1;\n            });\n        },\n\n        /**\n         * Removes the given link from this graph.\n         */\n        removeLink: function(link) {\n            /*    if (!this.links.contains(link)) {\n             throw \"The given link is not part of the Graph.\";\n             }\n             */\n            Utils.remove(this.links, link);\n\n            Utils.remove(link.source.outgoing, link);\n            Utils.remove(link.source.links, link);\n            Utils.remove(link.target.incoming, link);\n            Utils.remove(link.target.links, link);\n        },\n\n        /**\n         * Adds a new node to this graph, if not already present.\n         * The node can be an existing Node or the identifier of a new node.\n         * No error is thrown if the node is already there and the existing one is returned.\n         */\n        addNode: function(nodeOrId, layoutRect, owner) {\n\n            var newNode = null;\n\n            if (!Utils.isDefined(nodeOrId)) {\n                throw \"No Node or identifier for a new Node is given.\";\n            }\n\n            if (Utils.isString(nodeOrId)) {\n                if (this.hasNode(nodeOrId)) {\n                    return this.getNode(nodeOrId);\n                }\n                newNode = new Node(nodeOrId);\n            }\n            else {\n                if (this.hasNode(nodeOrId)) {\n                    return this.getNode(nodeOrId);\n                }\n                // todo: ensure that the param is a Node?\n                newNode = nodeOrId;\n            }\n\n            if (Utils.isDefined(layoutRect)) {\n                newNode.bounds(layoutRect);\n            }\n\n            if (Utils.isDefined(owner)) {\n                newNode.owner = owner;\n            }\n            this._addNode(newNode);\n            return newNode;\n        },\n\n        /**\n         * Adds the given Node and its outgoing links.\n         */\n        addNodeAndOutgoings: function(node) {\n            if (!this.hasNode(node)) {\n                this._addNode(node);\n            }\n\n            var newLinks = node.outgoing;\n            node.outgoing = [];\n            Utils.forEach(newLinks, function(link) {\n                this.addExistingLink(link);\n            }, this);\n        },\n\n        /**\n         * Sets the 'index' property on the links and nodes of this graph.\n         */\n        setItemIndices: function() {\n            var i;\n            for (i = 0; i < this.nodes.length; ++i) {\n                this.nodes[i].index = i;\n            }\n\n            for (i = 0; i < this.links.length; ++i) {\n                this.links[i].index = i;\n            }\n        },\n\n        /**\n         * Returns a clone of this graph.\n         */\n        clone: function(saveMapping) {\n            var copy = new Graph();\n            var save = Utils.isDefined(saveMapping) && saveMapping === true;\n            if (save) {\n                copy.nodeMap = new Dictionary();\n                copy.linkMap = new Dictionary();\n            }\n            // we need a map even if the saveMapping is not set\n            var map = new Dictionary();\n            Utils.forEach(this.nodes, function(nOriginal) {\n                var nCopy = nOriginal.clone();\n                map.set(nOriginal, nCopy);\n                copy._addNode(nCopy);\n\n                if (save) {\n                    copy.nodeMap.set(nCopy, nOriginal);\n                }\n            });\n\n            Utils.forEach(this.links, function(linkOriginal) {\n                if (map.containsKey(linkOriginal.source) && map.containsKey(linkOriginal.target)) {\n                    var linkCopy = copy.addLink(map.get(linkOriginal.source), map.get(linkOriginal.target));\n                    if (save) {\n                        copy.linkMap.set(linkCopy, linkOriginal);\n                    }\n                }\n            });\n\n            return copy;\n        },\n\n        /**\n         * The parsing allows a quick way to create graphs.\n         *  - [\"n1->n2\", \"n2->n3\"]: creates the three nodes and adds the links\n         *  - [\"n1->n2\", {id: \"QSDF\"}, \"n2->n3\"]: same as previous but also performs a deep extend of the link between n1 and n2 with the given object.\n         */\n        linearize: function(addIds) {\n            return Graph.Utils.linearize(this, addIds);\n        },\n\n        /**\n         * Performs a depth-first traversal starting at the given node.\n         * @param startNode a node or id of a node in this graph\n         * @param action\n         */\n        depthFirstTraversal: function(startNode, action) {\n            if (Utils.isUndefined(startNode)) {\n                throw \"You need to supply a starting node.\";\n            }\n            if (Utils.isUndefined(action)) {\n                throw \"You need to supply an action.\";\n            }\n            if (!this.hasNode(startNode)) {\n                throw \"The given start-node is not part of this graph\";\n            }\n            var foundNode = this.getNode(startNode);// case the given one is an Id\n            var visited = [];\n            this._dftIterator(foundNode, action, visited);\n        },\n\n        _dftIterator: function(node, action, visited) {\n\n            action(node);\n            visited.push(node);\n            var children = node.getChildren();\n            for (var i = 0, len = children.length; i < len; i++) {\n                var child = children[i];\n                if (contains(visited, child)) {\n                    continue;\n                }\n                this._dftIterator(child, action, visited);\n            }\n        },\n\n        /**\n         * Performs a breadth-first traversal starting at the given node.\n         * @param startNode a node or id of a node in this graph\n         * @param action\n         */\n        breadthFirstTraversal: function(startNode, action) {\n\n            if (Utils.isUndefined(startNode)) {\n                throw \"You need to supply a starting node.\";\n            }\n            if (Utils.isUndefined(action)) {\n                throw \"You need to supply an action.\";\n            }\n\n            if (!this.hasNode(startNode)) {\n                throw \"The given start-node is not part of this graph\";\n            }\n            var foundNode = this.getNode(startNode);// case the given one is an Id\n            var queue = new Queue();\n            var visited = [];\n            queue.enqueue(foundNode);\n\n            while (queue.length > 0) {\n                var node = queue.dequeue();\n                action(node);\n                visited.push(node);\n                var children = node.getChildren();\n                for (var i = 0, len = children.length; i < len; i++) {\n                    var child = children[i];\n                    if (contains(visited, child) || contains(queue, child)) {\n                        continue;\n                    }\n                    queue.enqueue(child);\n                }\n            }\n        },\n\n        /**\n         * This is the classic Tarjan algorithm for strongly connected components.\n         * See e.g. http://en.wikipedia.org/wiki/Tarjan's_strongly_connected_components_algorithm\n         * @param excludeSingleItems Whether isolated nodes should be excluded from the analysis.\n         * @param node The start node from which the analysis starts.\n         * @param indices  Numbers the nodes consecutively in the order in which they are discovered.\n         * @param lowLinks The smallest index of any node known to be reachable from the node, including the node itself\n         * @param connected The current component.\n         * @param stack The bookkeeping stack of things to visit.\n         * @param index The counter of visited nodes used to assign the indices.\n         * @private\n         */\n        _stronglyConnectedComponents: function(excludeSingleItems, node, indices, lowLinks, connected, stack, index) {\n            indices.add(node, index);\n            lowLinks.add(node, index);\n            index++;\n\n            stack.push(node);\n\n            var children = node.getChildren(), next;\n            for (var i = 0, len = children.length; i < len; i++) {\n                next = children[i];\n                if (!indices.containsKey(next)) {\n                    this._stronglyConnectedComponents(excludeSingleItems, next, indices, lowLinks, connected, stack, index);\n                    lowLinks.add(node, Math.min(lowLinks.get(node), lowLinks.get(next)));\n                }\n                else if (contains(stack, next)) {\n                    lowLinks.add(node, Math.min(lowLinks.get(node), indices.get(next)));\n                }\n            }\n            // If v is a root node, pop the stack and generate a strong component\n            if (lowLinks.get(node) === indices.get(node)) {\n                var component = [];\n                do {\n                    next = stack.pop();\n                    component.push(next);\n                }\n                while (next !== node);\n                if (!excludeSingleItems || (component.length > 1)) {\n                    connected.push(component);\n                }\n            }\n        },\n\n        /**\n         * Returns the cycles found in this graph.\n         * The returned arrays consist of the nodes which are strongly coupled.\n         * @param excludeSingleItems Whether isolated nodes should be excluded.\n         * @returns {Array} The array of cycles found.\n         */\n        findCycles: function(excludeSingleItems) {\n            if (Utils.isUndefined(excludeSingleItems)) {\n                excludeSingleItems = true;\n            }\n            var indices = new Dictionary();\n            var lowLinks = new Dictionary();\n            var connected = [];\n            var stack = [];\n            for (var i = 0, len = this.nodes.length; i < len; i++) {\n                var node = this.nodes[i];\n                if (indices.containsKey(node)) {\n                    continue;\n                }\n                this._stronglyConnectedComponents(excludeSingleItems, node, indices, lowLinks, connected, stack, 0);\n            }\n            return connected;\n        },\n\n        /**\n         * Returns whether this graph is acyclic.\n         * @returns {*}\n         */\n        isAcyclic: function() {\n            return Utils.isEmpty(this.findCycles());\n        },\n\n        /**\n         * Returns whether the given graph is a subgraph of this one.\n         * @param other Another graph instance.\n         */\n        isSubGraph: function(other) {\n            var otherArray = other.linearize();\n            var thisArray = this.linearize();\n            return Utils.all(otherArray, function(s) {\n                return contains(thisArray, s);\n            });\n        },\n\n        /**\n         *  Makes an acyclic graph from the current (connected) one.\n         * * @returns {Array} The reversed links.\n         */\n        makeAcyclic: function() {\n            // if empty or almost empty\n            if (this.isEmpty() || this.nodes.length <= 1 || this.links.length <= 1) {\n                return [];\n            }\n            // singular case of just two nodes\n            if (this.nodes.length == 2) {\n                var result = [];\n                if (this.links.length > 1) {\n                    var oneLink = this.links[0];\n                    var oneNode = oneLink.source;\n                    for (var i = 0, len = this.links.length; i < len; i++) {\n                        var link = this.links[i];\n                        if (link.source == oneNode) {\n                            continue;\n                        }\n                        var rev = link.reverse();\n                        result.push(rev);\n                    }\n                }\n                return result;\n            }\n\n            var copy = this.clone(true); // copy.nodeMap tells you the mapping\n            var N = this.nodes.length;\n\n            var intensityCatalog = new Dictionary();\n\n            /**\n             * If there are both incoming and outgoing links this will return the flow intensity (out-in).\n             * Otherwise the node acts as a flow source with N specifying the (equal) intensity.\n             * @param node\n             * @returns {number}\n             */\n            var flowIntensity = function(node) {\n                if (node.outgoing.length === 0) {\n                    return (2 - N);\n                }\n                else if (node.incoming.length === 0) {\n                    return (N - 2);\n                }\n                else {\n                    return node.outgoing.length - node.incoming.length;\n                }\n            };\n\n            /**\n             * Collects the nodes with the same intensity.\n             * @param node\n             * @param intensityCatalog\n             */\n            var catalogEqualIntensity = function(node, intensityCatalog) {\n                var intensity = flowIntensity(node, N);\n                if (!intensityCatalog.containsKey(intensity)) {\n                    intensityCatalog.set(intensity, []);\n                }\n                intensityCatalog.get(intensity).push(node);\n            };\n\n            Utils.forEach(copy.nodes, function(v) {\n                catalogEqualIntensity(v, intensityCatalog);\n            });\n\n            var sourceStack = [];\n            var targetStack = [];\n\n            while (copy.nodes.length > 0) {\n                var source, target, intensity;\n                if (intensityCatalog.containsKey(2 - N)) {\n                    var targets = intensityCatalog.get(2 - N); // nodes without outgoings\n                    while (targets.length > 0) {\n                        target = targets.pop();\n                        for (var li = 0; li < target.links.length; li++) {\n                            var targetLink = target.links[li];\n                            source = targetLink.getComplement(target);\n                            intensity = flowIntensity(source, N);\n                            Utils.remove(intensityCatalog.get(intensity), source);\n                            source.removeLink(targetLink);\n                            catalogEqualIntensity(source, intensityCatalog);\n                        }\n                        copy._removeNode(target);\n                        targetStack.unshift(target);\n                    }\n                }\n\n                // move sources to sourceStack\n                if (intensityCatalog.containsKey(N - 2)) {\n                    var sources = intensityCatalog.get(N - 2); // nodes without incomings\n                    while (sources.length > 0) {\n                        source = sources.pop();\n                        for (var si = 0; si < source.links.length; si++) {\n                            var sourceLink = source.links[si];\n                            target = sourceLink.getComplement(source);\n                            intensity = flowIntensity(target, N);\n                            Utils.remove(intensityCatalog.get(intensity), target);\n                            target.removeLink(sourceLink);\n                            catalogEqualIntensity(target, intensityCatalog);\n                        }\n                        sourceStack.push(source);\n                        copy._removeNode(source);\n                    }\n                }\n\n                if (copy.nodes.length > 0) {\n                    for (var k = N - 3; k > 2 - N; k--) {\n                        if (intensityCatalog.containsKey(k) &&\n                            intensityCatalog.get(k).length > 0) {\n                            var maxdiff = intensityCatalog.get(k);\n                            var v = maxdiff.pop();\n                            for (var ri = 0; ri < v.links.length; ri++) {\n                                var ril = v.links[ri];\n                                var u = ril.getComplement(v);\n                                intensity = flowIntensity(u, N);\n                                Utils.remove(intensityCatalog.get(intensity), u);\n                                u.removeLink(ril);\n                                catalogEqualIntensity(u, intensityCatalog);\n                            }\n                            sourceStack.push(v);\n                            copy._removeNode(v);\n                            break;\n                        }\n                    }\n                }\n            }\n\n            sourceStack = sourceStack.concat(targetStack);\n\n            var vertexOrder = new Dictionary();\n            for (var kk = 0; kk < this.nodes.length; kk++) {\n                vertexOrder.set(copy.nodeMap.get(sourceStack[kk]), kk);\n            }\n\n            var reversedEdges = [];\n            Utils.forEach(this.links, function(link) {\n                if (vertexOrder.get(link.source) > vertexOrder.get(link.target)) {\n                    link.reverse();\n                    reversedEdges.push(link);\n                }\n            });\n            return reversedEdges;\n        }\n    });\n\n    /**\n     * A collection of predefined graphs for demo and testing purposes.\n     */\n    Graph.Predefined = {\n        /**\n         * Eight-shapes graph all connected in a cycle.\n         * @returns {*}\n         * @constructor\n         */\n        EightGraph: function() {\n            return Graph.Utils.parse([ \"1->2\", \"2->3\", \"3->4\", \"4->1\", \"3->5\", \"5->6\", \"6->7\", \"7->3\"]);\n        },\n\n        /**\n         * Creates a typical mindmap diagram.\n         * @returns {*}\n         * @constructor\n         */\n        Mindmap: function() {\n            return Graph.Utils.parse([\"0->1\", \"0->2\", \"0->3\", \"0->4\", \"0->5\", \"1->6\", \"1->7\", \"7->8\", \"2->9\", \"9->10\", \"9->11\", \"3->12\",\n                \"12->13\", \"13->14\", \"4->15\", \"4->16\", \"15->17\", \"15->18\", \"18->19\", \"18->20\", \"14->21\", \"14->22\", \"5->23\", \"23->24\", \"23->25\", \"6->26\"]);\n        },\n\n        /**\n         * Three nodes connected in a cycle.\n         * @returns {*}\n         * @constructor\n         */\n        ThreeGraph: function() {\n            return Graph.Utils.parse([ \"1->2\", \"2->3\", \"3->1\"]);\n        },\n\n        /**\n         * A tree with each node having two children.\n         * @param levels How many levels the binary tree should have.\n         * @returns {diagram.Graph}\n         * @constructor\n         */\n        BinaryTree: function(levels) {\n            if (Utils.isUndefined(levels)) {\n                levels = 5;\n            }\n            return Graph.Utils.createBalancedTree(levels, 2);\n        },\n\n        /**\n         * A linear graph (discrete line segment).\n         * @param length How many segments (the node count is hence (length+1)).\n         * @returns {diagram.Graph}\n         * @constructor\n         */\n        Linear: function(length) {\n            if (Utils.isUndefined(length)) {\n                length = 10;\n            }\n            return Graph.Utils.createBalancedTree(length, 1);\n        },\n\n        /**\n         * A standard tree-graph with the specified levels and children (siblings) count.\n         * Note that for a balanced tree of level N and sibling count s, counting the root as level zero:\n         *  - NodeCount = (1-s^(N+1))/(1-s)]\n         *  - LinkCount = s.(1-s^N)/(1-s)\n         * @param levels How many levels the tree should have.\n         * @param siblingsCount How many siblings each level should have.\n         * @returns {diagram.Graph}\n         * @constructor\n         */\n        Tree: function(levels, siblingsCount) {\n            return Graph.Utils.createBalancedTree(levels, siblingsCount);\n        },\n\n        /**\n         * Creates a forest.\n         * Note that for a balanced forest of level N, sibling count s and tree count t, counting the root as level zero:\n         *  - NodeCount = t.(1-s^(N+1))/(1-s)]\n         *  - LinkCount = t.s.(1-s^N)/(1-s)\n         * @param levels How many levels the tree should have.\n         * @param siblingsCount How many siblings each level should have.\n         * @param trees The amount of trees the forest should have.\n         * @returns {diagram.Graph}\n         * @constructor\n         */\n        Forest: function(levels, siblingsCount, trees) {\n            return Graph.Utils.createBalancedForest(levels, siblingsCount, trees);\n        },\n\n        /**\n         * A workflow-like graph with cycles.\n         * @returns {*}\n         * @constructor\n         */\n        Workflow: function() {\n            return Graph.Utils.parse(\n                [\"0->1\", \"1->2\", \"2->3\", \"1->4\", \"4->3\", \"3->5\", \"5->6\", \"6->3\", \"6->7\", \"5->4\"]\n            );\n        },\n\n        /**\n         * A grid graph with the direction of the links avoiding cycles.\n         * Node count: (n+1).(m+1)\n         * Link count: n.(m+1) + m.(n+1)\n         * @param n Horizontal count of grid cells. If zero this will result in a linear graph.\n         * @param m Vertical count of grid cells. If zero this will result in a linear graph.\n         * @constructor\n         */\n        Grid: function(n, m) {\n            var g = new diagram.Graph();\n            if (n <= 0 && m <= 0) {\n                return g;\n            }\n\n            for (var i = 0; i < n + 1; i++) {\n                var previous = null;\n                for (var j = 0; j < m + 1; j++) {\n                    // using x-y coordinates to name the nodes\n                    var node = new Node(i.toString() + \".\" + j.toString());\n                    g.addNode(node);\n                    if (previous) {\n                        g.addLink(previous, node);\n                    }\n                    if (i > 0) {\n                        var left = g.getNode((i - 1).toString() + \".\" + j.toString());\n                        g.addLink(left, node);\n                    }\n                    previous = node;\n                }\n            }\n            return g;\n        }\n\n    };\n\n    /**\n     * Graph generation and other utilities.\n     */\n    Graph.Utils = {\n        /**\n         * The parsing allows a quick way to create graphs.\n         *  - [\"n1->n2\", \"n2->n3\"]: creates the three nodes and adds the links\n         *  - [\"n1->n2\", {id: \"id177\"}, \"n2->n3\"]: same as previous but also performs a deep extend of the link between n1 and n2 with the given object.\n         */\n        parse: function(graphString) {\n\n            var previousLink, graph = new diagram.Graph(), parts = graphString.slice();\n            for (var i = 0, len = parts.length; i < len; i++) {\n                var part = parts[i];\n                if (Utils.isString(part)) // link spec\n                {\n                    if (part.indexOf(\"->\") < 0) {\n                        throw \"The link should be specified as 'a->b'.\";\n                    }\n                    var p = part.split(\"->\");\n                    if (p.length != 2) {\n                        throw \"The link should be specified as 'a->b'.\";\n                    }\n                    previousLink = new Link(p[0], p[1]);\n                    graph.addLink(previousLink);\n                }\n                if (Utils.isObject(part)) {\n                    if (!previousLink) {\n                        throw \"Specification found before Link definition.\";\n                    }\n                    kendo.deepExtend(previousLink, part);\n                }\n            }\n            return graph;\n        },\n\n        /**\n         * Returns a linearized representation of the given Graph.\n         * See also the Graph.Utils.parse method for the inverse operation.\n         */\n        linearize: function(graph, addIds) {\n            if (Utils.isUndefined(graph)) {\n                throw \"Expected an instance of a Graph object in slot one.\";\n            }\n            if (Utils.isUndefined(addIds)) {\n                addIds = false;\n            }\n            var lin = [];\n            for (var i = 0, len = graph.links.length; i < len; i++) {\n                var link = graph.links[i];\n                lin.push(link.source.id + \"->\" + link.target.id);\n                if (addIds) {\n                    lin.push({ id: link.id });\n                }\n            }\n            return lin;\n        },\n\n        /**\n         * The method used by the diagram creation to instantiate a shape.\n         * @param kendoDiagram The Kendo diagram where the diagram will be created.\n         * @param p The position at which to place the shape.\n         * @param shapeDefaults Optional Shape options.\n         * @param id Optional identifier of the shape.\n         * @returns {*}\n         * @private\n         */\n        _addShape: function(kendoDiagram, p, id, shapeDefaults) {\n            if (Utils.isUndefined(p)) {\n                p = new diagram.Point(0, 0);\n            }\n\n            if (Utils.isUndefined(id)) {\n                id = randomId();\n            }\n\n            shapeDefaults = kendo.deepExtend({\n                width: 20,\n                height: 20,\n                id: id,\n                radius: 10,\n                fill: \"#778899\",\n                data: \"circle\",\n                undoable: false,\n                x: p.x,\n                y: p.y\n            }, shapeDefaults);\n\n            return kendoDiagram.addShape(shapeDefaults);\n        },\n        /**\n         * The method used by the diagram creation to instantiate a connection.\n         * @param diagram he Kendo diagram where the diagram will be created.\n         * @param from The source shape.\n         * @param to The target shape.\n         * @param options Optional Connection options.\n         * @returns {*}\n         * @private\n         */\n        _addConnection: function(diagram, from, to, options) {\n            return diagram.connect(from, to, options);\n        },\n\n        /**\n         * Creates a diagram from the given Graph.\n         * @param diagram The Kendo diagram where the diagram will be created.\n         * @param graph The graph structure defining the diagram.\n         */\n        createDiagramFromGraph: function(diagram, graph, doLayout, randomSize) {\n\n            if (Utils.isUndefined(diagram)) {\n                throw \"The diagram surface is undefined.\";\n            }\n            if (Utils.isUndefined(graph)) {\n                throw \"No graph specification defined.\";\n            }\n            if (Utils.isUndefined(doLayout)) {\n                doLayout = true;\n            }\n            if (Utils.isUndefined(randomSize)) {\n                randomSize = false;\n            }\n\n            var width = diagram.element.clientWidth || 200;\n            var height = diagram.element.clientHeight || 200;\n            var map = [], node, shape;\n            for (var i = 0, len = graph.nodes.length; i < len; i++) {\n                node = graph.nodes[i];\n                var p = node.position;\n                if (Utils.isUndefined(p)) {\n                    if (Utils.isDefined(node.x) && Utils.isDefined(node.y)) {\n                        p = new Point(node.x, node.y);\n                    }\n                    else {\n                        p = new Point(Utils.randomInteger(10, width - 20), Utils.randomInteger(10, height - 20));\n                    }\n                }\n                var opt = {};\n\n                if (node.id === \"0\") {\n                    /* kendo.deepExtend(opt,\n                     {\n                     fill: \"Orange\",\n                     data: 'circle',\n                     width: 100,\n                     height: 100,\n                     center: new Point(50, 50)\n                     });*/\n                }\n                else if (randomSize) {\n                    kendo.deepExtend(opt, {\n                        width: Math.random() * 150 + 20,\n                        height: Math.random() * 80 + 50,\n                        data: 'rectangle',\n                        fill: {\n                            color: \"#778899\"\n                        }\n                    });\n                }\n\n                shape = this._addShape(diagram, p, node.id, opt);\n                //shape.content(node.id);\n\n                var bounds = shape.bounds();\n                if (Utils.isDefined(bounds)) {\n                    node.x = bounds.x;\n                    node.y = bounds.y;\n                    node.width = bounds.width;\n                    node.height = bounds.height;\n                }\n                map[node.id] = shape;\n            }\n            for (var gli = 0; gli < graph.links.length; gli++) {\n                var link = graph.links[gli];\n                var sourceShape = map[link.source.id];\n                if (Utils.isUndefined(sourceShape)) {\n                    continue;\n                }\n                var targetShape = map[link.target.id];\n                if (Utils.isUndefined(targetShape)) {\n                    continue;\n                }\n                this._addConnection(diagram, sourceShape, targetShape, { id: link.id });\n\n            }\n            if (doLayout) {\n                var l = new diagram.SpringLayout(diagram);\n                l.layoutGraph(graph, { limitToView: false });\n                for (var shi = 0; shi < graph.nodes.length; shi++) {\n                    node = graph.nodes[shi];\n                    shape = map[node.id];\n                    shape.bounds(new Rect(node.x, node.y, node.width, node.height));\n                }\n            }\n        },\n\n        /**\n         * Creates a balanced tree with the specified number of levels and siblings count.\n         * Note that for a balanced tree of level N and sibling count s, counting the root as level zero:\n         *  - NodeCount = (1-s^(N+1))/(1-s)]\n         *  - LinkCount = s.(1-s^N)/(1-s)\n         * @param levels How many levels the tree should have.\n         * @param siblingsCount How many siblings each level should have.\n         * @returns {diagram.Graph}\n         */\n        createBalancedTree: function(levels, siblingsCount) {\n            if (Utils.isUndefined(levels)) {\n                levels = 3;\n            }\n            if (Utils.isUndefined(siblingsCount)) {\n                siblingsCount = 3;\n            }\n\n            var g = new diagram.Graph(), counter = -1, lastAdded = [], news;\n            if (levels <= 0 || siblingsCount <= 0) {\n                return g;\n            }\n            var root = new Node((++counter).toString());\n            g.addNode(root);\n            g.root = root;\n            lastAdded.push(root);\n            for (var i = 0; i < levels; i++) {\n                news = [];\n                for (var j = 0; j < lastAdded.length; j++) {\n                    var parent = lastAdded[j];\n                    for (var k = 0; k < siblingsCount; k++) {\n                        var item = new Node((++counter).toString());\n                        g.addLink(parent, item);\n                        news.push(item);\n                    }\n                }\n                lastAdded = news;\n            }\n            return g;\n        },\n\n        /**\n         * Creates a balanced tree with the specified number of levels and siblings count.\n         * Note that for a balanced forest of level N, sibling count s and tree count t, counting the root as level zero:\n         *  - NodeCount = t.(1-s^(N+1))/(1-s)]\n         *  - LinkCount = t.s.(1-s^N)/(1-s)\n         * @param levels How many levels the tree should have.\n         * @param siblingsCount How many siblings each level should have.\n         * @returns {diagram.Graph}\n         * @param treeCount The number of trees the forest should have.\n         */\n        createBalancedForest: function(levels, siblingsCount, treeCount) {\n            if (Utils.isUndefined(levels)) {\n                levels = 3;\n            }\n            if (Utils.isUndefined(siblingsCount)) {\n                siblingsCount = 3;\n            }\n            if (Utils.isUndefined(treeCount)) {\n                treeCount = 5;\n            }\n            var g = new diagram.Graph(), counter = -1, lastAdded = [], news;\n            if (levels <= 0 || siblingsCount <= 0 || treeCount <= 0) {\n                return g;\n            }\n\n            for (var t = 0; t < treeCount; t++) {\n                var root = new Node((++counter).toString());\n                g.addNode(root);\n                lastAdded = [root];\n                for (var i = 0; i < levels; i++) {\n                    news = [];\n                    for (var j = 0; j < lastAdded.length; j++) {\n                        var parent = lastAdded[j];\n                        for (var k = 0; k < siblingsCount; k++) {\n                            var item = new Node((++counter).toString());\n                            g.addLink(parent, item);\n                            news.push(item);\n                        }\n                    }\n                    lastAdded = news;\n                }\n            }\n            return g;\n        },\n\n        /**\n         * Creates a random graph (uniform distribution) with the specified amount of nodes.\n         * @param nodeCount The amount of nodes the random graph should have.\n         * @param maxIncidence The maximum allowed degree of the nodes.\n         * @param isTree Whether the return graph should be a tree (default: false).\n         * @returns {diagram.Graph}\n         */\n        createRandomConnectedGraph: function(nodeCount, maxIncidence, isTree) {\n\n            /* Swa's Mathematica export of random Bernoulli graphs\n             gr[n_,p_]:=Module[{g=RandomGraph[BernoulliGraphDistribution[n,p],VertexLabels->\"Name\",DirectedEdges->True]},\n             While[Not[ConnectedGraphQ[g]],g=RandomGraph[BernoulliGraphDistribution[n,p],VertexLabels->\"Name\",DirectedEdges->True]];g];\n             project[a_]:=(\"\\\"\"<>ToString[Part[#,1]]<>\"->\"<>ToString[Part[#,2]]<>\"\\\"\")&     @ a;\n             export[g_]:=project/@ EdgeList[g]\n             g = gr[12,.1]\n             export [g]\n             */\n\n            if (Utils.isUndefined(nodeCount)) {\n                nodeCount = 40;\n            }\n            if (Utils.isUndefined(maxIncidence)) {\n                maxIncidence = 4;\n            }\n            if (Utils.isUndefined(isTree)) {\n                isTree = false;\n            }\n\n            var g = new diagram.Graph(), counter = -1;\n            if (nodeCount <= 0) {\n                return g;\n            }\n\n            var root = new Node((++counter).toString());\n            g.addNode(root);\n            if (nodeCount === 1) {\n                return g;\n            }\n            if (nodeCount > 1) {\n                // random tree\n                for (var i = 1; i < nodeCount; i++) {\n                    var poolNode = g.takeRandomNode([], maxIncidence);\n                    if (!poolNode) {\n                        //failed to find one so the graph will have less nodes than specified\n                        break;\n                    }\n                    var newNode = g.addNode(i.toString());\n                    g.addLink(poolNode, newNode);\n                }\n                if (!isTree && nodeCount > 1) {\n                    var randomAdditions = Utils.randomInteger(1, nodeCount);\n                    for (var ri = 0; ri < randomAdditions; ri++) {\n                        var n1 = g.takeRandomNode([], maxIncidence);\n                        var n2 = g.takeRandomNode([], maxIncidence);\n                        if (n1 && n2 && !g.areConnected(n1, n2)) {\n                            g.addLink(n1, n2);\n                        }\n                    }\n                }\n                return g;\n            }\n        },\n\n        /**\n         * Generates a random diagram.\n         * @param diagram The host diagram.\n         * @param shapeCount The number of shapes the random diagram should contain.\n         * @param maxIncidence The maximum degree the shapes can have.\n         * @param isTree Whether the generated diagram should be a tree\n         * @param layoutType The optional layout type to apply after the diagram is generated.\n         */\n        randomDiagram: function(diagram, shapeCount, maxIncidence, isTree, randomSize) {\n            var g = kendo.dataviz.diagram.Graph.Utils.createRandomConnectedGraph(shapeCount, maxIncidence, isTree);\n            Graph.Utils.createDiagramFromGraph(diagram, g, false, randomSize);\n        }\n    };\n\n    kendo.deepExtend(diagram, {\n        init: function(element) {\n            kendo.init(element, diagram.ui);\n        },\n\n        Point: Point,\n        Intersect: Intersect,\n        Geometry: Geometry,\n        Rect: Rect,\n        Size: Size,\n        RectAlign: RectAlign,\n        Matrix: Matrix,\n        MatrixVector: MatrixVector,\n        normalVariable: normalVariable,\n        randomId: randomId,\n        Dictionary: Dictionary,\n        HashTable: HashTable,\n        Queue: Queue,\n        Set: Set,\n        Node: Node,\n        Link: Link,\n        Graph: Graph,\n        PathDefiner: PathDefiner\n    });\n})(window.kendo.jQuery);\n\n(function($, undefined$1) {\n    // Imports ================================================================\n    var kendo = window.kendo,\n        diagram = kendo.dataviz.diagram,\n        Class = kendo.Class,\n        deepExtend = kendo.deepExtend,\n        Point = diagram.Point,\n        Rect = diagram.Rect,\n        Matrix = diagram.Matrix,\n        Utils = diagram.Utils,\n        isNumber = Utils.isNumber,\n        isString = Utils.isString,\n        MatrixVector = diagram.MatrixVector,\n\n        g = kendo.geometry,\n        d = kendo.drawing,\n\n        defined = d.util.defined,\n\n        inArray = $.inArray;\n\n    // Constants ==============================================================\n    var TRANSPARENT = \"transparent\",\n        Markers = {\n            none: \"none\",\n            arrowStart: \"ArrowStart\",\n            filledCircle: \"FilledCircle\",\n            arrowEnd: \"ArrowEnd\"\n        },\n        FULL_CIRCLE_ANGLE = 360,\n        START = \"start\",\n        END = \"end\",\n        WIDTH = \"width\",\n        HEIGHT = \"height\",\n        X = \"x\",\n        Y = \"y\";\n\n    diagram.Markers = Markers;\n\n    function diffNumericOptions(options, fields) {\n        var elementOptions = this.options;\n        var hasChanges = false;\n        var value, field;\n        for (var i = 0; i < fields.length; i++) {\n            field = fields[i];\n            value = options[field];\n            if (isNumber(value) && elementOptions[field] !== value) {\n                elementOptions[field] = value;\n                hasChanges = true;\n            }\n        }\n\n        return hasChanges;\n    }\n\n    var Scale = Class.extend({\n        init: function(x, y) {\n            this.x = x;\n            this.y = y;\n        },\n        toMatrix: function() {\n            return Matrix.scaling(this.x, this.y);\n        },\n        toString: function() {\n            return kendo.format(\"scale({0},{1})\", this.x, this.y);\n        },\n        invert: function() {\n            return new Scale(1 / this.x, 1 / this.y);\n        }\n    });\n\n    var Translation = Class.extend({\n        init: function(x, y) {\n            this.x = x;\n            this.y = y;\n        },\n        toMatrixVector: function() {\n            return new MatrixVector(0, 0, 0, 0, this.x, this.y);\n        },\n        toMatrix: function() {\n            return Matrix.translation(this.x, this.y);\n        },\n        toString: function() {\n            return kendo.format(\"translate({0},{1})\", this.x, this.y);\n        },\n        plus: function(delta) {\n            this.x += delta.x;\n            this.y += delta.y;\n        },\n        times: function(factor) {\n            this.x *= factor;\n            this.y *= factor;\n        },\n        length: function() {\n            return Math.sqrt(this.x * this.x + this.y * this.y);\n        },\n        normalize: function() {\n            if (this.Length === 0) {\n                return;\n            }\n            this.times(1 / this.length());\n        },\n        invert: function() {\n            return new Translation(-this.x, -this.y);\n        }\n    });\n\n    var Rotation = Class.extend({\n        init: function(angle, x, y) {\n            this.x = x || 0;\n            this.y = y || 0;\n            this.angle = angle;\n        },\n        toString: function() {\n            if (this.x && this.y) {\n                return kendo.format(\"rotate({0},{1},{2})\", this.angle, this.x, this.y);\n            } else {\n                return kendo.format(\"rotate({0})\", this.angle);\n            }\n        },\n        toMatrix: function() {\n            return Matrix.rotation(this.angle, this.x, this.y); // T*R*T^-1\n        },\n        center: function() {\n            return new Point(this.x, this.y);\n        },\n        invert: function() {\n            return new Rotation(FULL_CIRCLE_ANGLE - this.angle, this.x, this.y);\n        }\n    });\n\n    Rotation.ZERO = new Rotation(0);\n\n    Rotation.create = function(rotation) {\n        return new Rotation(rotation.angle, rotation.x, rotation.y);\n    };\n\n    Rotation.parse = function(str) {\n        var values = str.slice(1, str.length - 1).split(\",\"),\n            angle = values[0],\n            x = values[1],\n            y = values[2];\n        var rotation = new Rotation(angle, x, y);\n        return rotation;\n    };\n\n    var CompositeTransform = Class.extend({\n        init: function(x, y, scaleX, scaleY, angle, center) {\n            this.translate = new Translation(x, y);\n            if (scaleX !== undefined$1 && scaleY !== undefined$1) {\n                this.scale = new Scale(scaleX, scaleY);\n            }\n            if (angle !== undefined$1) {\n                this.rotate = center ? new Rotation(angle, center.x, center.y) : new Rotation(angle);\n            }\n        },\n        toString: function() {\n            var toString = function(transform) {\n                return transform ? transform.toString() : \"\";\n            };\n\n            return toString(this.translate) +\n                toString(this.rotate) +\n                toString(this.scale);\n        },\n\n        render: function(visual) {\n            visual._transform = this;\n            visual._renderTransform();\n        },\n\n        toMatrix: function() {\n            var m = Matrix.unit();\n\n            if (this.translate) {\n                m = m.times(this.translate.toMatrix());\n            }\n            if (this.rotate) {\n                m = m.times(this.rotate.toMatrix());\n            }\n            if (this.scale) {\n                m = m.times(this.scale.toMatrix());\n            }\n            return m;\n        },\n        invert: function() {\n            var rotate = this.rotate ? this.rotate.invert() : undefined$1,\n                rotateMatrix = rotate ? rotate.toMatrix() : Matrix.unit(),\n                scale = this.scale ? this.scale.invert() : undefined$1,\n                scaleMatrix = scale ? scale.toMatrix() : Matrix.unit();\n\n            var translatePoint = new Point(-this.translate.x, -this.translate.y);\n            translatePoint = rotateMatrix.times(scaleMatrix).apply(translatePoint);\n            var translate = new Translation(translatePoint.x, translatePoint.y);\n\n            var transform = new CompositeTransform();\n            transform.translate = translate;\n            transform.rotate = rotate;\n            transform.scale = scale;\n\n            return transform;\n        }\n    });\n\n    var AutoSizeableMixin = {\n        _setScale: function() {\n            var options = this.options;\n            var originWidth = this._originWidth;\n            var originHeight = this._originHeight;\n            var scaleX = options.width / originWidth;\n            var scaleY = options.height / originHeight;\n\n            if (!isNumber(scaleX)) {\n                scaleX = 1;\n            }\n            if (!isNumber(scaleY)) {\n                scaleY = 1;\n            }\n\n            this._transform.scale = new Scale(scaleX, scaleY);\n        },\n\n        _setTranslate: function() {\n            var options = this.options;\n            var x = options.x || 0;\n            var y = options.y || 0;\n            this._transform.translate = new Translation(x, y);\n        },\n\n        _initSize: function() {\n            var options = this.options;\n            var transform = false;\n            if (options.autoSize !== false && (defined(options.width) || defined(options.height))) {\n                this._measure(true);\n                this._setScale();\n                transform = true;\n            }\n\n            if (defined(options.x) || defined(options.y)) {\n                this._setTranslate();\n                transform = true;\n            }\n\n            if (transform) {\n                this._renderTransform();\n            }\n        },\n\n        _updateSize: function(options) {\n            var update = false;\n\n            if (this.options.autoSize !== false && this._diffNumericOptions(options, [WIDTH, HEIGHT])) {\n                update = true;\n                this._measure(true);\n                this._setScale();\n            }\n\n            if (this._diffNumericOptions(options, [X, Y])) {\n                update = true;\n                this._setTranslate();\n            }\n\n            if (update) {\n                this._renderTransform();\n            }\n\n            return update;\n        }\n    };\n\n    var Element = Class.extend({\n        init: function(options) {\n            var element = this;\n            element.options = deepExtend({}, element.options, options);\n            element.id = element.options.id;\n            element._originSize = Rect.empty();\n            element._transform = new CompositeTransform();\n        },\n\n        visible: function(value) {\n            return this.drawingContainer().visible(value);\n        },\n\n        redraw: function(options) {\n            if (options && options.id) {\n                 this.id = options.id;\n            }\n        },\n\n        position: function(x, y) {\n            var options = this.options;\n            if (!defined(x)) {\n               return new Point(options.x, options.y);\n            }\n\n            if (defined(y)) {\n                options.x = x;\n                options.y = y;\n            } else if (x instanceof Point) {\n                options.x = x.x;\n                options.y = x.y;\n            }\n\n            this._transform.translate = new Translation(options.x, options.y);\n            this._renderTransform();\n        },\n\n        rotate: function(angle, center) {\n            if (defined(angle)) {\n                this._transform.rotate = new Rotation(angle, center.x, center.y);\n                this._renderTransform();\n            }\n            return this._transform.rotate || Rotation.ZERO;\n        },\n\n        drawingContainer: function() {\n            return this.drawingElement;\n        },\n\n        _renderTransform: function() {\n            var matrix = this._transform.toMatrix();\n            this.drawingContainer().transform(new g.Matrix(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f));\n        },\n\n        _hover: function() {},\n\n        _diffNumericOptions: diffNumericOptions,\n\n        _measure: function(force) {\n            var rect;\n            if (!this._measured || force) {\n                var box = this._boundingBox() || new g.Rect();\n                var startPoint = box.topLeft();\n                rect = new Rect(startPoint.x, startPoint.y, box.width(), box.height());\n                this._originSize = rect;\n                this._originWidth = rect.width;\n                this._originHeight = rect.height;\n                this._measured = true;\n            } else {\n                rect = this._originSize;\n            }\n            return rect;\n        },\n\n        _boundingBox: function() {\n            return this.drawingElement.rawBBox();\n        }\n    });\n\n    var VisualBase = Element.extend({\n        init: function(options) {\n            Element.fn.init.call(this, options);\n\n            options = this.options;\n            options.fill = normalizeDrawingOptions(options.fill);\n            options.stroke = normalizeDrawingOptions(options.stroke);\n        },\n\n        options: {\n            stroke: {\n                color: \"gray\",\n                width: 1\n            },\n            fill: {\n                color: TRANSPARENT\n            }\n        },\n\n        fill: function(color, opacity) {\n            this._fill({\n                color: getColor(color),\n                opacity: opacity\n            });\n        },\n\n        stroke: function(color, width, opacity) {\n            this._stroke({\n                color: getColor(color),\n                width: width,\n                opacity: opacity\n            });\n        },\n\n        redraw: function(options) {\n            if (options) {\n                var stroke = options.stroke;\n                var fill = options.fill;\n                if (stroke) {\n                    this._stroke(normalizeDrawingOptions(stroke));\n                }\n                if (fill) {\n                    this._fill(normalizeDrawingOptions(fill));\n                }\n\n                Element.fn.redraw.call(this, options);\n            }\n        },\n\n        _hover: function(show) {\n            var drawingElement = this.drawingElement;\n            var options = this.options;\n            var hover = options.hover;\n\n            if (hover && hover.fill) {\n                var fill = show ? normalizeDrawingOptions(hover.fill) : options.fill;\n                drawingElement.fill(fill.color, fill.opacity);\n            }\n        },\n\n        _stroke: function(strokeOptions) {\n            var options = this.options;\n            deepExtend(options, {\n                stroke: strokeOptions\n            });\n\n            strokeOptions = options.stroke;\n\n            var stroke = null;\n            if (strokeOptions.width > 0) {\n                stroke = {\n                    color: strokeOptions.color,\n                    width: strokeOptions.width,\n                    opacity: strokeOptions.opacity,\n                    dashType: strokeOptions.dashType\n                };\n            }\n\n            this.drawingElement.options.set(\"stroke\", stroke);\n        },\n\n        _fill: function(fillOptions) {\n            var options = this.options;\n            deepExtend(options, {\n                fill: fillOptions || {}\n            });\n            var fill = options.fill;\n\n            if (fill.gradient) {\n                var gradient = fill.gradient;\n                var GradientClass = (gradient.type === \"radial\" ? d.RadialGradient : d.LinearGradient);\n                this.drawingElement.fill(new GradientClass(gradient));\n            } else {\n                this.drawingElement.fill(fill.color, fill.opacity);\n            }\n        }\n    });\n\n    var TextBlock = VisualBase.extend({\n        init: function(options) {\n            options = this._textColor(options);\n            VisualBase.fn.init.call(this, options);\n\n            this._font();\n            this._initText();\n            this._initSize();\n        },\n\n        options: {\n            fontSize: 15,\n            fontFamily: \"sans-serif\",\n            stroke: {\n                width: 0\n            },\n            fill: {\n                color: \"black\"\n            },\n            autoSize: true\n        },\n\n        _initText: function() {\n            var options = this.options;\n\n            this.drawingElement = new d.Text(defined(options.text) ? options.text : \"\", new g.Point(), {\n                font: options.font\n            });\n\n            this._fill();\n            this._stroke();\n        },\n\n        _textColor: function(options) {\n            if (options && options.color) {\n                options = deepExtend({}, options, {\n                    fill: {\n                        color: options.color\n                    }\n                });\n            }\n            return options;\n        },\n\n        _font: function() {\n            var options = this.options;\n            if (options.fontFamily && defined(options.fontSize)) {\n                var fontOptions = [];\n\n                if (options.fontStyle) {\n                    fontOptions.push(options.fontStyle);\n                }\n\n                if (options.fontWeight) {\n                    fontOptions.push(options.fontWeight);\n                }\n\n                fontOptions.push(options.fontSize + (isNumber(options.fontSize) ? \"px\" : \"\"));\n                fontOptions.push(options.fontFamily);\n\n                options.font = fontOptions.join(\" \");\n            } else {\n                delete options.font;\n            }\n        },\n\n        content: function(text) {\n            return this.drawingElement.content(text);\n        },\n\n        redraw: function(options) {\n            if (options) {\n                var sizeChanged = false;\n                var textOptions = this.options;\n\n                options = this._textColor(options);\n\n                VisualBase.fn.redraw.call(this, options);\n\n                if (options.fontFamily || defined(options.fontSize) || options.fontStyle || options.fontWeight) {\n                    deepExtend(textOptions, {\n                        fontFamily: options.fontFamily,\n                        fontSize: options.fontSize,\n                        fontStyle: options.fontStyle,\n                        fontWeight: options.fontWeight\n                    });\n                    this._font();\n                    this.drawingElement.options.set(\"font\", textOptions.font);\n                    sizeChanged = true;\n                }\n\n                if (options.text) {\n                    this.content(options.text);\n                    sizeChanged = true;\n                }\n\n                if (!this._updateSize(options) && sizeChanged) {\n                    this._initSize();\n                }\n            }\n        }\n    });\n\n    deepExtend(TextBlock.fn, AutoSizeableMixin);\n\n    var Rectangle = VisualBase.extend({\n        init: function(options) {\n            VisualBase.fn.init.call(this, options);\n            this._initPath();\n            this._setPosition();\n        },\n\n        _setPosition: function() {\n            var options = this.options;\n            var x = options.x;\n            var y = options.y;\n            if (defined(x) || defined(y)) {\n                this.position(x || 0, y || 0);\n            }\n        },\n\n        redraw: function(options) {\n            if (options) {\n                VisualBase.fn.redraw.call(this, options);\n                if (this._diffNumericOptions(options, [WIDTH, HEIGHT])) {\n                    this._drawPath();\n                }\n                if (this._diffNumericOptions(options, [X, Y])) {\n                    this._setPosition();\n                }\n            }\n        },\n\n        _initPath: function() {\n            var options = this.options;\n            this.drawingElement = new d.Path({\n                stroke: options.stroke,\n                closed: true\n            });\n\n            this._fill();\n            this._drawPath();\n        },\n\n        _drawPath: function() {\n            var drawingElement = this.drawingElement;\n            var sizeOptions = sizeOptionsOrDefault(this.options);\n            var width = sizeOptions.width;\n            var height = sizeOptions.height;\n\n            drawingElement.segments.elements([\n                createSegment(0, 0),\n                createSegment(width, 0),\n                createSegment(width, height),\n                createSegment(0, height)\n            ]);\n        }\n    });\n\n    var MarkerBase = VisualBase.extend({\n        init: function(options) {\n           VisualBase.fn.init.call(this, options);\n           var anchor = this.options.anchor;\n           this.anchor = new g.Point(anchor.x, anchor.y);\n           this.createElement();\n        },\n\n        options: {\n           stroke: {\n                color: TRANSPARENT,\n                width: 0\n           },\n           fill: {\n                color: \"black\"\n           }\n        },\n\n        _transformToPath: function(point, path) {\n            var transform = path.transform();\n            if (point && transform) {\n                point = point.transformCopy(transform);\n            }\n            return point;\n        },\n\n        redraw: function(options) {\n            if (options) {\n                if (options.position) {\n                    this.options.position = options.position;\n                }\n\n                VisualBase.fn.redraw.call(this, options);\n            }\n        }\n    });\n\n    var CircleMarker = MarkerBase.extend({\n        options: {\n            radius: 4,\n            anchor: {\n                x: 0,\n                y: 0\n            }\n        },\n\n        createElement: function() {\n            var options = this.options;\n            this.drawingElement = new d.Circle(new g.Circle(this.anchor, options.radius), {\n                fill: options.fill,\n                stroke: options.stroke\n            });\n        },\n\n        positionMarker: function(path) {\n            var options = this.options;\n            var position = options.position;\n            var segments = path.segments;\n            var targetSegment;\n            var point;\n\n            if (position == START) {\n                targetSegment = segments[0];\n            } else {\n                targetSegment = segments[segments.length - 1];\n            }\n            if (targetSegment) {\n                point = this._transformToPath(targetSegment.anchor(), path);\n                this.drawingElement.transform(g.transform().translate(point.x, point.y));\n            }\n        }\n    });\n\n    var ArrowMarker = MarkerBase.extend({\n        options: {\n            path: \"M 0 0 L 10 5 L 0 10 L 3 5 z\" ,\n            anchor: {\n                x: 10,\n                y: 5\n            }\n        },\n\n        createElement: function() {\n            var options = this.options;\n            this.drawingElement = d.Path.parse(options.path, {\n                fill: options.fill,\n                stroke: options.stroke\n            });\n        },\n\n        positionMarker: function(path) {\n            var points = this._linePoints(path);\n            var start = points.start;\n            var end = points.end;\n            var transform = g.transform();\n            if (start) {\n                transform.rotate(lineAngle(start, end), end);\n            }\n\n            if (end) {\n                var anchor = this.anchor;\n                var translate = end.clone().translate(-anchor.x, -anchor.y);\n                transform.translate(translate.x, translate.y);\n            }\n            this.drawingElement.transform(transform);\n        },\n\n        _linePoints: function(path) {\n            var options = this.options;\n            var segments = path.segments;\n            var startPoint, endPoint, targetSegment;\n            if (options.position == START) {\n                targetSegment = segments[0];\n                if (targetSegment) {\n                    endPoint = targetSegment.anchor();\n                    startPoint = targetSegment.controlOut();\n                    var nextSegment = segments[1];\n                    if (!startPoint && nextSegment) {\n                        startPoint = nextSegment.anchor();\n                    }\n                }\n            } else {\n                targetSegment = segments[segments.length - 1];\n                if (targetSegment) {\n                    endPoint = targetSegment.anchor();\n                    startPoint = targetSegment.controlIn();\n                    var prevSegment = segments[segments.length - 2];\n                    if (!startPoint && prevSegment) {\n                        startPoint = prevSegment.anchor();\n                    }\n                }\n            }\n            if (endPoint) {\n                return {\n                    start: this._transformToPath(startPoint, path),\n                    end: this._transformToPath(endPoint, path)\n                };\n            }\n        }\n    });\n\n    var MarkerPathMixin = {\n        _getPath: function(position) {\n            var path = this.drawingElement;\n            if (path instanceof d.MultiPath) {\n                if (position == START) {\n                    path = path.paths[0];\n                } else {\n                    path = path.paths[path.paths.length - 1];\n                }\n            }\n            if (path && path.segments.length) {\n                return path;\n            }\n        },\n\n        _normalizeMarkerOptions: function(options) {\n            var startCap = options.startCap;\n            var endCap = options.endCap;\n\n            if (isString(startCap)) {\n                options.startCap = {\n                    type: startCap\n                };\n            }\n\n            if (isString(endCap)) {\n                options.endCap = {\n                    type: endCap\n                };\n            }\n        },\n\n        _removeMarker: function(position) {\n            var marker = this._markers[position];\n            if (marker) {\n                this.drawingContainer().remove(marker.drawingElement);\n                delete this._markers[position];\n            }\n        },\n\n        _createMarkers: function() {\n            var options = this.options;\n            this._normalizeMarkerOptions(options);\n\n            this._markers = {};\n            this._markers[START] = this._createMarker(options.startCap, START);\n            this._markers[END] = this._createMarker(options.endCap, END);\n        },\n\n        _createMarker: function(options, position) {\n            var type = (options || {}).type;\n            var path = this._getPath(position);\n            var markerType, marker;\n            if (!path) {\n                this._removeMarker(position);\n                return;\n            }\n\n            if (type == Markers.filledCircle) {\n                markerType = CircleMarker;\n            } else if (type == Markers.arrowStart || type == Markers.arrowEnd) {\n                markerType = ArrowMarker;\n            } else {\n                this._removeMarker(position);\n            }\n            if (markerType) {\n                marker = new markerType(deepExtend({}, options, {\n                    position: position\n                }));\n                marker.positionMarker(path);\n                this.drawingContainer().append(marker.drawingElement);\n\n                return marker;\n            }\n        },\n\n        _positionMarker: function(position) {\n            var marker = this._markers[position];\n\n            if (marker) {\n                var path = this._getPath(position);\n                if (path) {\n                    marker.positionMarker(path);\n                } else {\n                    this._removeMarker(position);\n                }\n            }\n        },\n\n        _capMap: {\n            start: \"startCap\",\n            end: \"endCap\"\n        },\n\n        _redrawMarker: function(pathChange, position, options) {\n            this._normalizeMarkerOptions(options);\n\n            var pathOptions = this.options;\n            var cap = this._capMap[position];\n            var pathCapType = (pathOptions[cap] || {}).type;\n            var optionsCap = options[cap];\n            var created = false;\n            if (optionsCap) {\n                pathOptions[cap] = deepExtend({}, pathOptions[cap], optionsCap);\n                if (optionsCap.type && pathCapType != optionsCap.type) {\n                    this._removeMarker(position);\n                    this._markers[position] = this._createMarker(pathOptions[cap], position);\n                    created = true;\n                } else if (this._markers[position]) {\n                   this._markers[position].redraw(optionsCap);\n                }\n            } else if (pathChange && !this._markers[position] && pathOptions[cap]) {\n                this._markers[position] = this._createMarker(pathOptions[cap], position);\n                created = true;\n            }\n            return created;\n        },\n\n        _redrawMarkers: function(pathChange, options) {\n            if (!this._redrawMarker(pathChange, START, options) && pathChange) {\n                this._positionMarker(START);\n            }\n            if (!this._redrawMarker(pathChange, END, options) && pathChange) {\n                this._positionMarker(END);\n            }\n        }\n    };\n\n    var Path = VisualBase.extend({\n        init: function(options) {\n            VisualBase.fn.init.call(this, options);\n            this.container = new d.Group();\n            this._createElements();\n            this._initSize();\n        },\n\n        options: {\n            autoSize: true\n        },\n\n        drawingContainer: function() {\n            return this.container;\n        },\n\n        data: function(value) {\n            var options = this.options;\n            if (value) {\n                if (options.data != value) {\n                   options.data = value;\n                   this._setData(value);\n                   this._initSize();\n                   this._redrawMarkers(true, {});\n                }\n            } else {\n                return options.data;\n            }\n        },\n\n        redraw: function(options) {\n            if (options) {\n                VisualBase.fn.redraw.call(this, options);\n\n                var pathOptions = this.options;\n                var data = options.data;\n\n                if (defined(data) && pathOptions.data != data) {\n                    pathOptions.data = data;\n                    this._setData(data);\n                    if (!this._updateSize(options)) {\n                        this._initSize();\n                    }\n                    this._redrawMarkers(true, options);\n                } else {\n                    this._updateSize(options);\n                    this._redrawMarkers(false, options);\n                }\n            }\n        },\n\n        _createElements: function() {\n            var options = this.options;\n\n            this.drawingElement = d.Path.parse(options.data || \"\", {\n                stroke: options.stroke\n            });\n\n            this._fill();\n            this.container.append(this.drawingElement);\n            this._createMarkers();\n        },\n\n        _setData: function(data) {\n            var drawingElement = this.drawingElement;\n            var multipath = d.Path.parse(data || \"\");\n            var paths = multipath.paths.slice(0);\n            multipath.paths.elements([]);\n            drawingElement.paths.elements(paths);\n        }\n    });\n\n    deepExtend(Path.fn, AutoSizeableMixin);\n    deepExtend(Path.fn, MarkerPathMixin);\n\n    var Line = VisualBase.extend({\n        init: function(options) {\n            VisualBase.fn.init.call(this, options);\n            this.container = new d.Group();\n            this._initPath();\n            this._createMarkers();\n        },\n\n        drawingContainer: function() {\n            return this.container;\n        },\n\n        redraw: function(options) {\n            if (options) {\n                options = options || {};\n                var from = options.from;\n                var to = options.to;\n                if (from) {\n                    this.options.from = from;\n                }\n\n                if (to) {\n                    this.options.to = to;\n                }\n\n                if (from || to) {\n                    this._drawPath();\n                    this._redrawMarkers(true, options);\n                } else {\n                    this._redrawMarkers(false, options);\n                }\n\n                VisualBase.fn.redraw.call(this, options);\n            }\n        },\n\n        _initPath: function() {\n            var options = this.options;\n            var drawingElement = this.drawingElement = new d.Path({\n                stroke: options.stroke\n            });\n\n            this._fill();\n            this._drawPath();\n            this.container.append(drawingElement);\n        },\n\n        _drawPath: function() {\n            var options = this.options;\n            var drawingElement = this.drawingElement;\n            var from = options.from || new Point();\n            var to = options.to || new Point();\n\n            drawingElement.segments.elements([\n                createSegment(from.x, from.y),\n                createSegment(to.x, to.y)\n            ]);\n        }\n    });\n\n    deepExtend(Line.fn, MarkerPathMixin);\n\n    var Polyline = VisualBase.extend({\n        init: function(options) {\n            VisualBase.fn.init.call(this, options);\n            this.container = new d.Group();\n            this._initPath();\n            this._createMarkers();\n        },\n\n        drawingContainer: function() {\n            return this.container;\n        },\n\n        points: function(points) {\n            var options = this.options;\n            if (points) {\n                options.points = points;\n                this._updatePath();\n            } else {\n                return options.points;\n            }\n        },\n\n        redraw: function(options) {\n            if (options) {\n                var points = options.points;\n                VisualBase.fn.redraw.call(this, options);\n\n                if (points && this._pointsDiffer(points)) {\n                    this.points(points);\n                    this._redrawMarkers(true, options);\n                } else {\n                    this._redrawMarkers(false, options);\n                }\n            }\n        },\n\n        _initPath: function() {\n            var options = this.options;\n            this.drawingElement = new d.Path({\n                stroke: options.stroke\n            });\n\n            this._fill();\n            this.container.append(this.drawingElement);\n\n            if (options.points) {\n                this._updatePath();\n            }\n        },\n\n        _pointsDiffer: function(points) {\n            var currentPoints = this.options.points;\n            var differ = currentPoints.length !== points.length;\n            if (!differ) {\n                for (var i = 0; i < points.length; i++) {\n                    if (currentPoints[i].x !== points[i].x || currentPoints[i].y !== points[i].y) {\n                        differ = true;\n                        break;\n                    }\n                }\n            }\n\n            return differ;\n        },\n\n        _updatePath: function() {\n            var drawingElement = this.drawingElement;\n            var options = this.options;\n            var points = options.points;\n            var segments = [];\n            var point;\n            for (var i = 0; i < points.length; i++) {\n                point = points[i];\n                segments.push(createSegment(point.x, point.y));\n            }\n\n            drawingElement.segments.elements(segments);\n        },\n\n        options: {\n            points: []\n        }\n    });\n\n    deepExtend(Polyline.fn, MarkerPathMixin);\n\n    var Image = Element.extend({\n        init: function(options) {\n            Element.fn.init.call(this, options);\n\n            this._initImage();\n        },\n\n        redraw: function(options) {\n            if (options) {\n                if (options.source) {\n                    this.drawingElement.src(options.source);\n                }\n\n                if (this._diffNumericOptions(options, [WIDTH, HEIGHT, X, Y])) {\n                    this.drawingElement.rect(this._rect());\n                }\n\n                Element.fn.redraw.call(this, options);\n            }\n        },\n\n        _initImage: function() {\n            var options = this.options;\n            var rect = this._rect();\n\n            this.drawingElement = new d.Image(options.source, rect, {});\n        },\n\n        _rect: function() {\n            var sizeOptions = sizeOptionsOrDefault(this.options);\n            var origin = new g.Point(sizeOptions.x, sizeOptions.y);\n            var size = new g.Size(sizeOptions.width, sizeOptions.height);\n\n            return new g.Rect(origin, size);\n        }\n    });\n\n    var Group = Element.extend({\n        init: function(options) {\n            this.children = [];\n            Element.fn.init.call(this, options);\n            this.drawingElement = new d.Group();\n            this._initSize();\n        },\n\n        options: {\n            autoSize: false\n        },\n\n        append: function(visual) {\n            this.drawingElement.append(visual.drawingContainer());\n            this.children.push(visual);\n            this._childrenChange = true;\n        },\n\n        remove: function(visual) {\n            if (this._remove(visual)) {\n                this._childrenChange = true;\n            }\n        },\n\n        _remove: function(visual) {\n            var index = inArray(visual, this.children);\n            if (index >= 0) {\n                this.drawingElement.removeAt(index);\n                this.children.splice(index, 1);\n                return true;\n            }\n        },\n\n        clear: function() {\n            this.drawingElement.clear();\n            this.children = [];\n            this._childrenChange = true;\n        },\n\n        toFront: function(visuals) {\n            var visual;\n\n            for (var i = 0; i < visuals.length; i++) {\n                visual = visuals[i];\n                if (this._remove(visual)) {\n                    this.append(visual);\n                }\n            }\n        },\n        //TO DO: add drawing group support for moving and inserting children\n        toBack: function(visuals) {\n            this._reorderChildren(visuals, 0);\n        },\n\n        toIndex: function(visuals, indices) {\n            this._reorderChildren(visuals, indices);\n        },\n\n        _reorderChildren: function(visuals, indices) {\n            var group = this.drawingElement;\n            var drawingChildren = group.children.slice(0);\n            var children = this.children;\n            var fixedPosition = isNumber(indices);\n            var i, index, toIndex, drawingElement, visual;\n\n            for (i = 0; i < visuals.length; i++) {\n                visual = visuals[i];\n                drawingElement = visual.drawingContainer();\n\n                index = inArray(visual, children);\n                if (index >= 0) {\n                    drawingChildren.splice(index, 1);\n                    children.splice(index, 1);\n\n                    toIndex = fixedPosition ? indices : indices[i];\n\n                    drawingChildren.splice(toIndex, 0, drawingElement);\n                    children.splice(toIndex, 0, visual);\n                }\n            }\n            group.clear();\n            group.append.apply(group, drawingChildren);\n        },\n\n        redraw: function(options) {\n            if (options) {\n                if (this._childrenChange) {\n                    this._childrenChange = false;\n                    if (!this._updateSize(options)) {\n                        this._initSize();\n                    }\n                } else {\n                    this._updateSize(options);\n                }\n\n                Element.fn.redraw.call(this, options);\n            }\n        },\n\n        _boundingBox: function() {\n            var children = this.children;\n            var boundingBox;\n            var visual, childBoundingBox;\n            for (var i = 0; i < children.length; i++) {\n                visual = children[i];\n                if (visual.visible() && visual._includeInBBox !== false) {\n                    childBoundingBox = visual.drawingContainer().clippedBBox(null);\n                    if (childBoundingBox) {\n                        if (boundingBox) {\n                            boundingBox = g.Rect.union(boundingBox, childBoundingBox);\n                        } else {\n                            boundingBox = childBoundingBox;\n                        }\n                    }\n                }\n            }\n\n            return boundingBox;\n        }\n    });\n\n    deepExtend(Group.fn, AutoSizeableMixin);\n\n    var Layout = Group.extend({\n        init: function(rect, options) {\n            this.children = [];\n            Element.fn.init.call(this, options);\n            this.drawingElement = new d.Layout(toDrawingRect(rect), options);\n            this._initSize();\n        },\n\n        rect: function(rect) {\n            if (rect) {\n                this.drawingElement.rect(toDrawingRect(rect));\n            } else {\n                var drawingRect = this.drawingElement.rect();\n                if (drawingRect) {\n                    return new Rect(drawingRect.origin.x, drawingRect.origin.y, drawingRect.size.width, drawingRect.size.height);\n                }\n            }\n        },\n\n        reflow: function() {\n            this.drawingElement.reflow();\n        },\n\n        redraw: function(options) {\n            kendo.deepExtend(this.drawingElement.options, options);\n            Group.fn.redraw.call(this, options);\n        }\n    });\n\n    var Circle = VisualBase.extend({\n        init: function(options) {\n            VisualBase.fn.init.call(this, options);\n            this._initCircle();\n            this._initSize();\n        },\n\n        redraw: function(options) {\n            if (options) {\n                var circleOptions = this.options;\n\n                if (options.center) {\n                    deepExtend(circleOptions, {\n                        center: options.center\n                    });\n                    this._center.move(circleOptions.center.x, circleOptions.center.y);\n                }\n\n                if (this._diffNumericOptions(options, [\"radius\"])) {\n                    this._circle.setRadius(circleOptions.radius);\n                }\n\n                this._updateSize(options);\n\n                VisualBase.fn.redraw.call(this, options);\n            }\n        },\n\n        _initCircle: function() {\n            var options = this.options;\n            var width = options.width;\n            var height = options.height;\n            var radius = options.radius;\n            if (!defined(radius)) {\n                if (!defined(width)) {\n                    width = height;\n                }\n                if (!defined(height)) {\n                    height = width;\n                }\n                options.radius = radius = Math.min(width, height) / 2;\n            }\n\n            var center = options.center || { x: radius, y: radius };\n            this._center = new g.Point(center.x, center.y);\n            this._circle = new g.Circle(this._center, radius);\n            this.drawingElement = new d.Circle(this._circle, {\n                stroke: options.stroke\n            });\n\n            this._fill();\n        }\n    });\n    deepExtend(Circle.fn, AutoSizeableMixin);\n\n    var Canvas = Class.extend({\n        init: function(element, options) {\n            options = options || {};\n            this.element = element;\n            this.surface = d.Surface.create(element, options);\n            if (kendo.isFunction(this.surface.translate)) {\n                this.translate = this._translate;\n            }\n\n            this.drawingElement = new d.Group();\n            this._viewBox = new Rect(0, 0, options.width, options.height);\n            this.size(this._viewBox);\n        },\n\n        bounds: function() {\n            var box = this.drawingElement.clippedBBox();\n            return new Rect(0, 0, box.width(), box.height());\n        },\n\n        size: function(size) {\n            var viewBox = this._viewBox;\n            if (defined(size)) {\n                viewBox.width = size.width;\n                viewBox.height = size.height;\n                this.surface.setSize(size);\n            }\n            return {\n                width: viewBox.width,\n                height: viewBox.height\n            };\n        },\n\n        _translate: function(x, y) {\n            var viewBox = this._viewBox;\n            if (defined(x) && defined(y)) {\n                viewBox.x = x;\n                viewBox.y = y;\n                this.surface.translate({ x: x, y: y });\n            }\n            return {\n                x: viewBox.x,\n                y: viewBox.y\n            };\n        },\n\n        draw: function() {\n            this.surface.draw(this.drawingElement);\n        },\n\n        append: function(visual) {\n            this.drawingElement.append(visual.drawingContainer());\n            return this;\n        },\n\n        remove: function(visual) {\n            this.drawingElement.remove(visual.drawingContainer());\n        },\n\n        insertBefore: function() {\n\n        },\n\n        clear: function() {\n            this.drawingElement.clear();\n        },\n\n        destroy: function(clearHtml) {\n            this.surface.destroy();\n            if (clearHtml) {\n                $(this.element).remove();\n            }\n        }\n    });\n\n    // Helper functions ===========================================\n\n    function sizeOptionsOrDefault(options) {\n        return {\n            x: options.x || 0,\n            y: options.y || 0,\n            width: options.width || 0,\n            height: options.height || 0\n        };\n    }\n\n    function normalizeDrawingOptions(options) {\n        if (options) {\n            var drawingOptions = options;\n\n            if (isString(drawingOptions)) {\n                drawingOptions = {\n                    color: drawingOptions\n                };\n            }\n\n            if (drawingOptions.color) {\n                drawingOptions.color = getColor(drawingOptions.color);\n            }\n            return drawingOptions;\n        }\n    }\n\n    function getColor(value) {\n        var color;\n        if (value != TRANSPARENT) {\n            color = new d.Color(value).toHex();\n        } else {\n            color = value;\n        }\n        return color;\n    }\n\n    function lineAngle(p1, p2) {\n        var xDiff = p2.x - p1.x;\n        var yDiff = p2.y - p1.y;\n        var angle = d.util.deg(Math.atan2(yDiff, xDiff));\n        return angle;\n    }\n\n    function createSegment(x, y) {\n        return new d.Segment(new g.Point(x, y));\n    }\n\n    function toDrawingRect(rect) {\n        if (rect) {\n            return new g.Rect([rect.x, rect.y], [rect.width, rect.height]);\n        }\n    }\n\n    // Exports ================================================================\n    kendo.deepExtend(diagram, {\n        init: function(element) {\n            kendo.init(element, diagram.ui);\n        },\n        diffNumericOptions: diffNumericOptions,\n        Element: Element,\n        Scale: Scale,\n        Translation: Translation,\n        Rotation: Rotation,\n        Circle: Circle,\n        Group: Group,\n        Rectangle: Rectangle,\n        Canvas: Canvas,\n        Path: Path,\n        Layout: Layout,\n        Line: Line,\n        MarkerBase: MarkerBase,\n        ArrowMarker: ArrowMarker,\n        CircleMarker: CircleMarker,\n        Polyline: Polyline,\n        CompositeTransform: CompositeTransform,\n        TextBlock: TextBlock,\n        Image: Image,\n        VisualBase: VisualBase\n    });\n})(window.kendo.jQuery);\n\n(function($, undefined$1) {\n        // Imports ================================================================\n        var kendo = window.kendo,\n            dataviz = kendo.dataviz,\n            diagram = dataviz.diagram,\n            Class = kendo.Class,\n            Group = diagram.Group,\n            Rect = diagram.Rect,\n            Rectangle = diagram.Rectangle,\n            Utils = diagram.Utils,\n            isUndefined = Utils.isUndefined,\n            Point = diagram.Point,\n            Circle = diagram.Circle,\n            Ticker = diagram.Ticker,\n            deepExtend = kendo.deepExtend,\n            Movable = kendo.ui.Movable,\n            util = kendo.drawing.util,\n            defined = util.defined,\n            inArray = $.inArray;\n\n        // Constants ==============================================================\n        var Cursors = {\n                arrow: \"default\",\n                grip: \"pointer\",\n                cross: \"pointer\",\n                add: \"pointer\",\n                move: \"move\",\n                select: \"pointer\",\n                south: \"s-resize\",\n                east: \"e-resize\",\n                west: \"w-resize\",\n                north: \"n-resize\",\n                rowresize: \"row-resize\",\n                colresize: \"col-resize\"\n            },\n            HIT_TEST_DISTANCE = 10,\n            AUTO = \"Auto\",\n            TOP = \"Top\",\n            RIGHT = \"Right\",\n            LEFT = \"Left\",\n            BOTTOM = \"Bottom\",\n            DEFAULT_SNAP_SIZE = 10,\n            DEFAULT_SNAP_ANGLE = 10,\n            DRAG_START = \"dragStart\",\n            DRAG = \"drag\",\n            DRAG_END = \"dragEnd\",\n            ITEMROTATE = \"itemRotate\",\n            ITEMBOUNDSCHANGE = \"itemBoundsChange\",\n            MIN_SNAP_SIZE = 5,\n            MIN_SNAP_ANGLE = 5,\n            MOUSE_ENTER = \"mouseEnter\",\n            MOUSE_LEAVE = \"mouseLeave\",\n            ZOOM_START = \"zoomStart\",\n            ZOOM_END = \"zoomEnd\",\n            SCROLL_MIN = -20000,\n            SCROLL_MAX = 20000,\n            FRICTION = 0.90,\n            FRICTION_MOBILE = 0.93,\n            VELOCITY_MULTIPLIER = 5,\n            TRANSPARENT = \"transparent\",\n            PAN = \"pan\",\n            ROTATED = \"rotated\",\n            SOURCE = \"source\",\n            TARGET = \"target\",\n            HANDLE_NAMES = {\n                \"-1\": SOURCE,\n                \"1\": TARGET\n            };\n\n        diagram.Cursors = Cursors;\n\n        var PositionAdapter = kendo.Class.extend({\n            init: function(layoutState) {\n                this.layoutState = layoutState;\n                this.diagram = layoutState.diagram;\n            },\n            initState: function() {\n                this.froms = [];\n                this.tos = [];\n                this.subjects = [];\n                function pusher(id, bounds) {\n                    var shape = this.diagram.getShapeById(id);\n                    if (shape) {\n                        this.subjects.push(shape);\n                        this.froms.push(shape.bounds().topLeft());\n                        this.tos.push(bounds.topLeft());\n                    }\n                }\n\n                this.layoutState.nodeMap.forEach(pusher, this);\n            },\n            update: function(tick) {\n                if (this.subjects.length <= 0) {\n                    return;\n                }\n                for (var i = 0; i < this.subjects.length; i++) {\n                    //todo: define a Lerp function instead\n                    this.subjects[i].position(\n                        new Point(this.froms[i].x + (this.tos[i].x - this.froms[i].x) * tick, this.froms[i].y + (this.tos[i].y - this.froms[i].y) * tick)\n                    );\n                }\n            }\n        });\n\n        var LayoutUndoUnit = Class.extend({\n            init: function(initialState, finalState, animate) {\n                if (isUndefined(animate)) {\n                    this.animate = false;\n                }\n                else {\n                    this.animate = animate;\n                }\n                this._initialState = initialState;\n                this._finalState = finalState;\n                this.title = \"Diagram layout\";\n            },\n            undo: function() {\n                this.setState(this._initialState);\n            },\n            redo: function() {\n                this.setState(this._finalState);\n            },\n            setState: function(state) {\n                var diagram = state.diagram;\n                if (this.animate) {\n                    state.linkMap.forEach(\n                        function(id, points) {\n                            var conn = diagram.getShapeById(id);\n                            conn.visible(false);\n                            if (conn) {\n                                conn.points(points);\n                            }\n                        }\n                    );\n                    var ticker = new Ticker();\n                    ticker.addAdapter(new PositionAdapter(state));\n                    ticker.onComplete(function() {\n                        state.linkMap.forEach(\n                            function(id) {\n                                var conn = diagram.getShapeById(id);\n                                conn.visible(true);\n                            }\n                        );\n                    });\n                    ticker.play();\n                }\n                else {\n                    state.nodeMap.forEach(function(id, bounds) {\n                        var shape = diagram.getShapeById(id);\n                        if (shape) {\n                            shape.position(bounds.topLeft());\n                        }\n                    });\n                    state.linkMap.forEach(\n                        function(id, points) {\n                            var conn = diagram.getShapeById(id);\n                            if (conn) {\n                                conn.points(points);\n                            }\n                        }\n                    );\n                }\n            }\n        });\n\n        var CompositeUnit = Class.extend({\n            init: function(unit) {\n                this.units = [];\n                this.title = \"Composite unit\";\n                if (unit !== undefined$1) {\n                    this.units.push(unit);\n                }\n            },\n            add: function(undoUnit) {\n                this.units.push(undoUnit);\n            },\n            undo: function() {\n                for (var i = 0; i < this.units.length; i++) {\n                    this.units[i].undo();\n                }\n            },\n            redo: function() {\n                for (var i = 0; i < this.units.length; i++) {\n                    this.units[i].redo();\n                }\n            }\n        });\n\n        var ConnectionEditUnit = Class.extend({\n            init: function(item, redoSource, redoTarget) {\n                this.item = item;\n                this._redoSource = redoSource;\n                this._redoTarget = redoTarget;\n                if (defined(redoSource)) {\n                    this._undoSource = item.source();\n                }\n\n                if (defined(redoTarget)) {\n                    this._undoTarget = item.target();\n                }\n                this.title = \"Connection Editing\";\n            },\n            undo: function() {\n                if (this._undoSource !== undefined$1) {\n                    this.item._updateConnector(this._undoSource, \"source\");\n                }\n\n                if (this._undoTarget !== undefined$1) {\n                    this.item._updateConnector(this._undoTarget, \"target\");\n                }\n\n                this.item.updateModel();\n            },\n            redo: function() {\n                if (this._redoSource !== undefined$1) {\n                    this.item._updateConnector(this._redoSource, \"source\");\n                }\n\n                if (this._redoTarget !== undefined$1) {\n                    this.item._updateConnector(this._redoTarget, \"target\");\n                }\n\n                this.item.updateModel();\n            }\n        });\n\n        var ConnectionEditUndoUnit = Class.extend({\n            init: function(item, undoSource, undoTarget) {\n                this.item = item;\n                this._undoSource = undoSource;\n                this._undoTarget = undoTarget;\n                this._redoSource = item.source();\n                this._redoTarget = item.target();\n                this.title = \"Connection Editing\";\n            },\n            undo: function() {\n                this.item._updateConnector(this._undoSource, \"source\");\n                this.item._updateConnector(this._undoTarget, \"target\");\n                this.item.updateModel();\n            },\n            redo: function() {\n                this.item._updateConnector(this._redoSource, \"source\");\n                this.item._updateConnector(this._redoTarget, \"target\");\n                this.item.updateModel();\n            }\n        });\n\n        var DeleteConnectionUnit = Class.extend({\n            init: function(connection) {\n                this.connection = connection;\n                this.diagram = connection.diagram;\n                this.targetConnector = connection.targetConnector;\n                this.title = \"Delete connection\";\n            },\n            undo: function() {\n                this.diagram._addConnection(this.connection, false);\n            },\n            redo: function() {\n                this.diagram.remove(this.connection, false);\n            }\n        });\n\n        var DeleteShapeUnit = Class.extend({\n            init: function(shape) {\n                this.shape = shape;\n                this.diagram = shape.diagram;\n                this.title = \"Deletion\";\n            },\n            undo: function() {\n                this.diagram._addShape(this.shape, false);\n                this.shape.select(false);\n            },\n            redo: function() {\n                this.shape.select(false);\n                this.diagram.remove(this.shape, false);\n            }\n        });\n        /**\n         * Holds the undoredo state when performing a rotation, translation or scaling. The adorner is optional.\n         * @type {*}\n         */\n        var TransformUnit = Class.extend({\n            init: function(shapes, undoStates, adorner) {\n                this.shapes = shapes;\n                this.undoStates = undoStates;\n                this.title = \"Transformation\";\n                this.redoStates = [];\n                this.adorner = adorner;\n                for (var i = 0; i < this.shapes.length; i++) {\n                    var shape = this.shapes[i];\n                    this.redoStates.push(shape.bounds());\n                }\n            },\n            undo: function() {\n                for (var i = 0; i < this.shapes.length; i++) {\n                    var shape = this.shapes[i];\n                    shape.bounds(this.undoStates[i]);\n                    if (shape.hasOwnProperty(\"layout\")) {\n                        shape.layout(shape, this.redoStates[i], this.undoStates[i]);\n                    }\n                    shape.updateModel();\n                }\n                if (this.adorner) {\n                    this.adorner.refreshBounds();\n                    this.adorner.refresh();\n                }\n            },\n            redo: function() {\n                for (var i = 0; i < this.shapes.length; i++) {\n                    var shape = this.shapes[i];\n                    shape.bounds(this.redoStates[i]);\n                    // the 'layout' property, if implemented, lets the shape itself work out what to do with the new bounds\n                    if (shape.hasOwnProperty(\"layout\")) {\n                        shape.layout(shape, this.undoStates[i], this.redoStates[i]);\n                    }\n                    shape.updateModel();\n                }\n\n                if (this.adorner) {\n                    this.adorner.refreshBounds();\n                    this.adorner.refresh();\n                }\n            }\n        });\n\n        var AddConnectionUnit = Class.extend({\n            init: function(connection, diagram) {\n                this.connection = connection;\n                this.diagram = diagram;\n                this.title = \"New connection\";\n            },\n\n            undo: function() {\n                this.diagram.remove(this.connection, false);\n            },\n\n            redo: function() {\n                this.diagram._addConnection(this.connection, false);\n            }\n        });\n\n        var AddShapeUnit = Class.extend({\n            init: function(shape, diagram) {\n                this.shape = shape;\n                this.diagram = diagram;\n                this.title = \"New shape\";\n            },\n\n            undo: function() {\n                this.diagram.deselect();\n                this.diagram.remove(this.shape, false);\n            },\n\n            redo: function() {\n                this.diagram._addShape(this.shape, false);\n            }\n        });\n\n        var PanUndoUnit = Class.extend({\n            init: function(initialPosition, finalPosition, diagram) {\n                this.initial = initialPosition;\n                this.finalPos = finalPosition;\n                this.diagram = diagram;\n                this.title = \"Pan Unit\";\n            },\n            undo: function() {\n                this.diagram.pan(this.initial);\n            },\n            redo: function() {\n                this.diagram.pan(this.finalPos);\n            }\n        });\n\n        var RotateUnit = Class.extend({\n            init: function(adorner, shapes, undoRotates) {\n                this.shapes = shapes;\n                this.undoRotates = undoRotates;\n                this.title = \"Rotation\";\n                this.redoRotates = [];\n                this.redoAngle = adorner._angle;\n                this.adorner = adorner;\n                this.center = adorner._innerBounds.center();\n                for (var i = 0; i < this.shapes.length; i++) {\n                    var shape = this.shapes[i];\n                    this.redoRotates.push(shape.rotate().angle);\n                }\n            },\n            undo: function() {\n                var i, shape;\n                for (i = 0; i < this.shapes.length; i++) {\n                    shape = this.shapes[i];\n                    shape.rotate(this.undoRotates[i], this.center, false);\n                    if (shape.hasOwnProperty(\"layout\")) {\n                        shape.layout(shape);\n                    }\n                    shape.updateModel();\n                }\n                if (this.adorner) {\n                    this.adorner._initialize();\n                    this.adorner.refresh();\n                }\n            },\n            redo: function() {\n                var i, shape;\n                for (i = 0; i < this.shapes.length; i++) {\n                    shape = this.shapes[i];\n                    shape.rotate(this.redoRotates[i], this.center, false);\n                    if (shape.hasOwnProperty(\"layout\")) {\n                        shape.layout(shape);\n                    }\n                    shape.updateModel();\n                }\n                if (this.adorner) {\n                    this.adorner._initialize();\n                    this.adorner.refresh();\n                }\n            }\n        });\n\n        var ToFrontUnit = Class.extend({\n            init: function(diagram, items, initialIndices) {\n                this.diagram = diagram;\n                this.indices = initialIndices;\n                this.items = items;\n                this.title = \"Rotate Unit\";\n            },\n            undo: function() {\n                this.diagram._toIndex(this.items, this.indices);\n            },\n            redo: function() {\n                this.diagram.toFront(this.items, false);\n            }\n        });\n\n        var ToBackUnit = Class.extend({\n            init: function(diagram, items, initialIndices) {\n                this.diagram = diagram;\n                this.indices = initialIndices;\n                this.items = items;\n                this.title = \"Rotate Unit\";\n            },\n            undo: function() {\n                this.diagram._toIndex(this.items, this.indices);\n            },\n            redo: function() {\n                this.diagram.toBack(this.items, false);\n            }\n        });\n\n        /**\n         * Undo-redo service.\n         */\n        var UndoRedoService = kendo.Observable.extend({\n            init: function(options) {\n                kendo.Observable.fn.init.call(this, options);\n                this.bind(this.events, options);\n                this.stack = [];\n                this.index = 0;\n                this.capacity = 100;\n            },\n\n            events: [\"undone\", \"redone\"],\n\n            /**\n             * Starts the collection of units. Add those with\n             * the addCompositeItem method and call commit. Or cancel to forget about it.\n             */\n            begin: function() {\n                this.composite = new CompositeUnit();\n            },\n\n            /**\n             * Cancels the collection process of unit started with 'begin'.\n             */\n            cancel: function() {\n                this.composite = undefined$1;\n            },\n\n            /**\n             * Commits a batch of units.\n             */\n            commit: function(execute) {\n                if (this.composite.units.length > 0) {\n                    this._restart(this.composite, execute);\n                }\n                this.composite = undefined$1;\n            },\n\n            /**\n             * Adds a unit as part of the begin-commit batch.\n             * @param undoUnit\n             */\n            addCompositeItem: function(undoUnit) {\n                if (this.composite) {\n                    this.composite.add(undoUnit);\n                } else {\n                    this.add(undoUnit);\n                }\n            },\n\n            /**\n             * Standard addition of a unit. See also the batch version; begin-addCompositeUnit-commit methods.\n             * @param undoUnit The unit to be added.\n             * @param execute If false, the unit will be added but not executed.\n             */\n            add: function(undoUnit, execute) {\n                this._restart(undoUnit, execute);\n            },\n\n            /**\n             * Returns the number of undoable unit in the stack.\n             * @returns {Number}\n             */\n\n            pop: function() {\n                if (this.index > 0) {\n                    this.stack.pop();\n                    this.index--;\n                }\n            },\n\n            count: function() {\n                return this.stack.length;\n            },\n\n            /**\n             * Rollback of the unit on top of the stack.\n             */\n            undo: function() {\n                if (this.index > 0) {\n                    this.index--;\n                    this.stack[this.index].undo();\n                    this.trigger(\"undone\");\n                }\n            },\n\n            /**\n             * Redo of the last undone action.\n             */\n            redo: function() {\n                if (this.stack.length > 0 && this.index < this.stack.length) {\n                    this.stack[this.index].redo();\n                    this.index++;\n                    this.trigger(\"redone\");\n                }\n            },\n\n            _restart: function(composite, execute) {\n                // throw away anything beyond this point if this is a new branch\n                this.stack.splice(this.index, this.stack.length - this.index);\n                this.stack.push(composite);\n                if (execute !== false) {\n                    this.redo();\n                } else {\n                    this.index++;\n                }\n                // check the capacity\n                if (this.stack.length > this.capacity) {\n                    this.stack.splice(0, this.stack.length - this.capacity);\n                    this.index = this.capacity; //points to the end of the stack\n                }\n            },\n\n            /**\n             * Clears the stack.\n             */\n            clear: function() {\n                this.stack = [];\n                this.index = 0;\n            }\n        });\n\n// Tools =========================================\n\n        var EmptyTool = Class.extend({\n            init: function(toolService) {\n                this.toolService = toolService;\n            },\n            start: function() {\n            },\n            move: function() {\n            },\n            end: function() {\n            },\n            tryActivate: function() {\n                return false;\n            },\n            getCursor: function() {\n                return Cursors.arrow;\n            }\n        });\n\n        var ScrollerTool = EmptyTool.extend({\n            init: function(toolService) {\n                var tool = this;\n                var friction = kendo.support.mobileOS ? FRICTION_MOBILE : FRICTION;\n                EmptyTool.fn.init.call(tool, toolService);\n\n                var diagram = tool.toolService.diagram,\n                    canvas = diagram.canvas;\n\n                var scroller = diagram.scroller = tool.scroller = $(diagram.scrollable).kendoMobileScroller({\n                    friction: friction,\n                    velocityMultiplier: VELOCITY_MULTIPLIER,\n                    mousewheelScrolling: false,\n                    zoom: false,\n                    scroll: tool._move.bind(tool)\n                }).data(\"kendoMobileScroller\");\n\n                if (canvas.translate) {\n                    tool.movableCanvas = new Movable(canvas.element);\n                }\n\n                var virtualScroll = function(dimension, min, max) {\n                    dimension.makeVirtual();\n                    dimension.virtualSize(min || SCROLL_MIN, max || SCROLL_MAX);\n                };\n\n                virtualScroll(scroller.dimensions.x);\n                virtualScroll(scroller.dimensions.y);\n                scroller.disable();\n            },\n\n            tryActivate: function(p, meta) {\n                var toolService = this.toolService;\n                var options = toolService.diagram.options.pannable;\n                var enabled = meta.ctrlKey;\n\n                if (defined(options.key)) {\n                    if (!options.key || options.key == \"none\") {\n                        enabled = noMeta(meta) && !defined(toolService.hoveredItem);\n                    } else {\n                        enabled = meta[options.key + \"Key\"];\n                    }\n                }\n\n                return options !== false && enabled && !defined(toolService.hoveredAdorner) && !defined(toolService._hoveredConnector);\n            },\n\n            start: function() {\n                this.scroller.enable();\n            },\n            move: function() {\n            },//the tool itself should not handle the scrolling. Let kendo scroller take care of this part. Check _move\n            _move: function(args) {\n                var tool = this,\n                    diagram = tool.toolService.diagram,\n                    canvas = diagram.canvas,\n                    scrollPos = new Point(args.scrollLeft, args.scrollTop);\n\n                if (canvas.translate) {\n                    diagram._storePan(scrollPos.times(-1));\n                    tool.movableCanvas.moveTo(scrollPos);\n                    canvas.translate(scrollPos.x, scrollPos.y);\n                } else {\n                    scrollPos = scrollPos.plus(diagram._pan.times(-1));\n                }\n\n                diagram.trigger(PAN, { pan: scrollPos });\n            },\n            end: function() {\n                this.scroller.disable();\n            },\n            getCursor: function() {\n                return Cursors.move;\n            }\n        });\n\n        /**\n         * The tool handling the transformations via the adorner.\n         * @type {*}\n         */\n        var PointerTool = Class.extend({\n            init: function(toolService) {\n                this.toolService = toolService;\n            },\n            tryActivate: function() {\n                return true; // the pointer tool is last and handles all others requests.\n            },\n            start: function(p, meta) {\n                var toolService = this.toolService,\n                    diagram = toolService.diagram,\n                    hoveredItem = toolService.hoveredItem;\n\n                if (hoveredItem) {\n                    toolService.selectSingle(hoveredItem, meta);\n                    if (hoveredItem.adorner) { //connection\n                        this.adorner = hoveredItem.adorner;\n                        this.handle = this.adorner._hitTest(p);\n                    }\n                }\n\n                if (!this.handle) {\n                    this.handle = diagram._resizingAdorner._hitTest(p);\n                    if (this.handle) {\n                        this.adorner = diagram._resizingAdorner;\n                    }\n                }\n\n                if (this.adorner) {\n                    if (!this.adorner.isDragHandle(this.handle) || !diagram.trigger(DRAG_START, { shapes: this.adorner.shapes, connections: [] })) {\n                        this.adorner.start(p);\n                    } else {\n                        toolService.startPoint = p;\n                        toolService.end(p);\n                    }\n                }\n            },\n\n            move: function(p) {\n                if (this.adorner) {\n                    this.adorner.move(this.handle, p);\n                    if (this.adorner.isDragHandle(this.handle)) {\n                        this.toolService.diagram.trigger(DRAG, { shapes: this.adorner.shapes, connections: [] });\n                    }\n                }\n            },\n\n            end: function() {\n                var diagram = this.toolService.diagram,\n                    adorner = this.adorner,\n                    unit;\n\n                if (adorner) {\n                    if (!adorner.isDragHandle(this.handle) || !diagram.trigger(DRAG_END, { shapes: adorner.shapes, connections: [] })) {\n                        unit = adorner.stop();\n                        if (unit) {\n                            diagram.undoRedoService.add(unit, false);\n                        }\n                    } else {\n                        adorner.cancel();\n                    }\n                }\n\n                this.adorner = undefined$1;\n                this.handle = undefined$1;\n            },\n            getCursor: function(p) {\n                return this.toolService.hoveredItem ? this.toolService.hoveredItem._getCursor(p) : Cursors.arrow;\n            }\n        });\n\n        var SelectionTool = Class.extend({\n            init: function(toolService) {\n                this.toolService = toolService;\n            },\n            tryActivate: function(p, meta) {\n                var toolService = this.toolService;\n                var selectable = toolService.diagram.options.selectable;\n                var enabled = selectable && selectable.multiple !== false;\n\n                if (enabled) {\n                    if (selectable.key && selectable.key != \"none\") {\n                        enabled = meta[selectable.key + \"Key\"];\n                    } else {\n                        enabled = noMeta(meta);\n                    }\n                }\n\n                return enabled && !defined(toolService.hoveredItem) && !defined(toolService.hoveredAdorner);\n            },\n            start: function(p) {\n                var diagram = this.toolService.diagram;\n                diagram.deselect();\n                diagram.selector.start(p);\n            },\n            move: function(p) {\n                var diagram = this.toolService.diagram;\n                diagram.selector.move(p);\n            },\n            end: function(p, meta) {\n                var diagram = this.toolService.diagram, hoveredItem = this.toolService.hoveredItem;\n                var rect = diagram.selector.bounds();\n                if ((!hoveredItem || !hoveredItem.isSelected) && !meta.ctrlKey) {\n                    diagram.deselect();\n                }\n                if (!rect.isEmpty()) {\n                    diagram.selectArea(rect);\n                }\n                diagram.selector.end();\n            },\n            getCursor: function() {\n                return Cursors.arrow;\n            }\n        });\n\n        var ConnectionTool = Class.extend({\n            init: function(toolService) {\n                this.toolService = toolService;\n                this.type = \"ConnectionTool\";\n            },\n            tryActivate: function() {\n                return this.toolService._hoveredConnector;\n            },\n            start: function(p, meta) {\n                var toolService = this.toolService,\n                    diagram = toolService.diagram,\n                    connector = toolService._hoveredConnector,\n                    connection = diagram._createConnection({}, connector._c, p);\n\n                if (canDrag(connection) && !diagram.trigger(DRAG_START, { shapes: [], connections: [connection], connectionHandle: TARGET }) && diagram._addConnection(connection)) {\n                    toolService._connectionManipulation(connection, connector._c.shape, true);\n                    toolService._removeHover();\n                    toolService.selectSingle(toolService.activeConnection, meta);\n                    if (meta.type == \"touchmove\") {\n                        diagram._cachedTouchTarget = connector.visual;\n                    }\n                } else {\n                    connection.source(null);\n                    toolService.end(p);\n                }\n            },\n\n            move: function(p) {\n                var toolService = this.toolService;\n                var connection = toolService.activeConnection;\n\n                connection.target(p);\n                toolService.diagram.trigger(DRAG, { shapes: [], connections: [connection], connectionHandle: TARGET });\n                return true;\n            },\n\n            end: function(p) {\n                var toolService = this.toolService,\n                    d = toolService.diagram,\n                    connection = toolService.activeConnection,\n                    hoveredItem = toolService.hoveredItem,\n                    connector = toolService._hoveredConnector,\n                    target,\n                    cachedTouchTarget = d._cachedTouchTarget;\n\n                if (!connection) {\n                    return;\n                }\n\n                if (connector && connector._c != connection.sourceConnector) {\n                    target = connector._c;\n                } else if (hoveredItem && hoveredItem instanceof diagram.Shape) {\n                    target = hoveredItem.getConnector(AUTO) || hoveredItem.getConnector(p);\n                } else {\n                    target = p;\n                }\n\n                connection.target(target);\n\n                if (!d.trigger(DRAG_END, { shapes: [], connections: [connection], connectionHandle: TARGET })) {\n                    connection.updateModel();\n                    d._syncConnectionChanges();\n                } else {\n                    d.remove(connection, false);\n                    d.undoRedoService.pop();\n                }\n                toolService._connectionManipulation();\n\n                if (cachedTouchTarget) {\n                    d._connectorsAdorner.visual.remove(cachedTouchTarget);\n                    d._cachedTouchTarget = null;\n                }\n            },\n\n            getCursor: function() {\n                return Cursors.arrow;\n            }\n        });\n\n        var ConnectionEditTool = Class.extend({\n            init: function(toolService) {\n                this.toolService = toolService;\n                this.type = \"ConnectionTool\";\n            },\n\n            tryActivate: function(p, meta) {\n                var toolService = this.toolService,\n                    diagram = toolService.diagram,\n                    selectable = diagram.options.selectable,\n                    item = toolService.hoveredItem,\n                    isActive = selectable !== false &&\n                               item && item.path && !(item.isSelected && meta.ctrlKey);\n\n                if (isActive) {\n                    this._c = item;\n                }\n\n                return isActive;\n            },\n\n            start: function(p, meta) {\n                var toolService = this.toolService;\n                var connection = this._c;\n\n                toolService.selectSingle(connection, meta);\n\n                var adorner = connection.adorner;\n\n                var handle, name;\n                if (adorner) {\n                    handle = adorner._hitTest(p);\n                    name = HANDLE_NAMES[handle];\n                }\n\n                if (canDrag(connection) && adorner && !toolService.diagram.trigger(DRAG_START, { shapes: [], connections: [connection], connectionHandle: name })) {\n                    this.handle = handle;\n                    this.handleName = name;\n                    adorner.start(p);\n                } else {\n                    toolService.startPoint = p;\n                    toolService.end(p);\n                }\n            },\n\n            move: function(p) {\n                var adorner = this._c.adorner;\n                if (canDrag(this._c) && adorner) {\n                    adorner.move(this.handle, p);\n                    this.toolService.diagram.trigger(DRAG, { shapes: [], connections: [this._c], connectionHandle: this.handleName });\n\n                    return true;\n                }\n            },\n\n            end: function(p) {\n                var connection = this._c;\n                var adorner = connection.adorner;\n                var toolService = this.toolService;\n                var diagram = toolService.diagram;\n\n                if (adorner) {\n                    if (canDrag(connection)) {\n                        var unit = adorner.stop(p);\n                        if (!diagram.trigger(DRAG_END, { shapes: [], connections: [connection], connectionHandle: this.handleName })) {\n                            diagram.undoRedoService.add(unit, false);\n                            connection.updateModel();\n                            diagram._syncConnectionChanges();\n                        } else {\n                            unit.undo();\n                        }\n                    }\n                }\n            },\n\n            getCursor: function() {\n                return Cursors.move;\n            }\n        });\n\n        function testKey(key, str) {\n            return str.charCodeAt(0) == key || str.toUpperCase().charCodeAt(0) == key;\n        }\n\n        /**\n         * The service managing the tools.\n         * @type {*}\n         */\n        var ToolService = Class.extend({\n            init: function(diagram) {\n                this.diagram = diagram;\n                this.tools = [\n                    new ScrollerTool(this),\n                    new ConnectionEditTool(this),\n                    new ConnectionTool(this),\n                    new SelectionTool(this),\n                    new PointerTool(this)\n                ]; // the order matters.\n\n                this.activeTool = undefined$1;\n            },\n\n            start: function(p, meta) {\n                meta = deepExtend({}, meta);\n                if (this.activeTool) {\n                    this.activeTool.end(p, meta);\n                }\n                this._updateHoveredItem(p);\n                this._activateTool(p, meta);\n                this.activeTool.start(p, meta);\n                this._updateCursor(p);\n                this.diagram.focus();\n                this.diagram.canvas.surface.suspendTracking();\n                this.startPoint = p;\n                return true;\n            },\n\n            move: function(p, meta) {\n                meta = deepExtend({}, meta);\n                var updateHovered = true;\n                if (this.activeTool) {\n                    updateHovered = this.activeTool.move(p, meta);\n                }\n                if (updateHovered) {\n                    this._updateHoveredItem(p);\n                }\n                this._updateCursor(p);\n                return true;\n            },\n\n            end: function(p, meta) {\n                meta = deepExtend({}, meta);\n                if (this.activeTool) {\n                    this.activeTool.end(p, meta);\n                }\n                this.diagram.canvas.surface.resumeTracking();\n                this.activeTool = undefined$1;\n                this._updateCursor(p);\n                return true;\n            },\n\n            keyDown: function(key, meta) {\n                var diagram = this.diagram;\n                meta = deepExtend({ ctrlKey: false, metaKey: false, altKey: false }, meta);\n                if ((meta.ctrlKey || meta.metaKey) && !meta.altKey) {// ctrl or option\n                    if (testKey(key, \"a\")) {// A: select all\n                        diagram.selectAll();\n                        diagram._destroyToolBar();\n                        return true;\n                    } else if (testKey(key, \"z\")) {// Z: undo\n                        diagram.undo();\n                        diagram._destroyToolBar();\n                        return true;\n                    } else if (testKey(key, \"y\")) {// y: redo\n                        diagram.redo();\n                        diagram._destroyToolBar();\n                        return true;\n                    } else if (testKey(key, \"c\")) {\n                        diagram.copy();\n                        diagram._destroyToolBar();\n                    } else if (testKey(key, \"x\")) {\n                        diagram.cut();\n                        diagram._destroyToolBar();\n                    } else if (testKey(key, \"v\")) {\n                        diagram.paste();\n                        diagram._destroyToolBar();\n                    } else if (testKey(key, \"l\")) {\n                        diagram.layout();\n                        diagram._destroyToolBar();\n                    } else if (testKey(key, \"d\")) {\n                        diagram._destroyToolBar();\n                        diagram.copy();\n                        diagram.paste();\n                    }\n                } else if (key === 46 || key === 8) {// del: deletion\n                    var toRemove = this.diagram._triggerRemove(diagram.select());\n                    if (toRemove.length) {\n                        this.diagram.remove(toRemove, true);\n                        this.diagram._syncChanges();\n                        this.diagram._destroyToolBar();\n                    }\n\n                    return true;\n                } else if (key === 27) {// ESC: stop any action\n                    this._discardNewConnection();\n                    diagram.deselect();\n                    diagram._destroyToolBar();\n                    return true;\n                }\n\n            },\n            wheel: function(p, meta) {\n                var diagram = this.diagram,\n                    delta = meta.delta,\n                    z = diagram.zoom(),\n                    options = diagram.options,\n                    zoomRate = options.zoomRate,\n                    zoomOptions = { point: p, meta: meta, zoom: z };\n\n                if (diagram.trigger(ZOOM_START, zoomOptions)) {\n                    return;\n                }\n\n                if (delta < 0) {\n                    z += zoomRate;\n                } else {\n                    z -= zoomRate;\n                }\n\n                z = kendo.dataviz.round(Math.max(options.zoomMin, Math.min(options.zoomMax, z)), 2);\n                zoomOptions.zoom = z;\n\n                diagram.zoom(z, zoomOptions);\n                diagram.trigger(ZOOM_END, zoomOptions);\n\n                return true;\n            },\n            setTool: function(tool, index) {\n                tool.toolService = this;\n                this.tools[index] = tool;\n            },\n\n            selectSingle: function(item, meta) {\n                var diagram = this.diagram;\n                var selectable = diagram.options.selectable;\n                if (selectable && !item.isSelected && item.options.selectable !== false) {\n                    var addToSelection = meta.ctrlKey && selectable.multiple !== false;\n                    diagram.select(item, { addToSelection: addToSelection });\n                }\n            },\n\n            _discardNewConnection: function() {\n                if (this.newConnection) {\n                    this.diagram.remove(this.newConnection);\n                    this.newConnection = undefined$1;\n                }\n            },\n            _activateTool: function(p, meta) {\n                for (var i = 0; i < this.tools.length; i++) {\n                    var tool = this.tools[i];\n                    if (tool.tryActivate(p, meta)) {\n                        this.activeTool = tool;\n                        break; // activating the first available tool in the loop.\n                    }\n                }\n            },\n            _updateCursor: function(p) {\n                var element = this.diagram.element;\n                var cursor = this.activeTool ? this.activeTool.getCursor(p) : (this.hoveredAdorner ? this.hoveredAdorner._getCursor(p) : (this.hoveredItem ? this.hoveredItem._getCursor(p) : Cursors.arrow));\n\n                element.css({ cursor: cursor });\n            },\n            _connectionManipulation: function(connection, disabledShape, isNew) {\n                this.activeConnection = connection;\n                this.disabledShape = disabledShape;\n                if (isNew) {\n                    this.newConnection = this.activeConnection;\n                } else {\n                    this.newConnection = undefined$1;\n                }\n            },\n            _updateHoveredItem: function(p) {\n                var hit = this._hitTest(p);\n                var diagram = this.diagram;\n\n                if (hit != this.hoveredItem && (!this.disabledShape || hit != this.disabledShape)) {\n                    if (this.hoveredItem) {\n                        diagram.trigger(MOUSE_LEAVE, { item: this.hoveredItem });\n                        this.hoveredItem._hover(false);\n                    }\n\n                    if (hit && hit.options.enable) {\n                        diagram.trigger(MOUSE_ENTER, { item: hit });\n\n                        this.hoveredItem = hit; // Shape, connection or connector\n                        this.hoveredItem._hover(true);\n                    } else {\n                        this.hoveredItem = undefined$1;\n                    }\n                }\n            },\n            _removeHover: function() {\n                if (this.hoveredItem) {\n                    this.hoveredItem._hover(false);\n                    this.hoveredItem = undefined$1;\n                }\n            },\n            _hitTest: function(point) {\n                var hit, d = this.diagram, item, i;\n\n                // connectors\n                if (this._hoveredConnector) {\n                    this._hoveredConnector._hover(false);\n                    this._hoveredConnector = undefined$1;\n                }\n                if (d._connectorsAdorner._visible) {\n                    hit = d._connectorsAdorner._hitTest(point);\n                    if (hit) {\n                        return hit;\n                    }\n                }\n\n                hit = this.diagram._resizingAdorner._hitTest(point);\n                if (hit) {\n                    this.hoveredAdorner = d._resizingAdorner;\n                    if (hit.x !== 0 || hit.y !== 0) { // hit testing for resizers or rotator, otherwise if (0,0) than pass through.\n                        return;\n                    }\n                    hit = undefined$1;\n                } else {\n                    this.hoveredAdorner = undefined$1;\n                }\n\n                if (!this.activeTool || this.activeTool.type !== \"ConnectionTool\") {\n                    var selectedConnections = []; // only the connections should have higher presence because the connection edit point is on top of connector.\n                    // TODO: This should be reworked. The connection adorner should be one for all selected connections and should be hit tested prior the connections and shapes itself.\n                    for (i = 0; i < d._selectedItems.length; i++) {\n                        item = d._selectedItems[i];\n                        if (item instanceof diagram.Connection) {\n                            selectedConnections.push(item);\n                        }\n                    }\n                    hit = this._hitTestItems(selectedConnections, point);\n                }\n\n                return hit || this._hitTestElements(point);\n            },\n\n            _hitTestElements: function(point) {\n                var diagram = this.diagram;\n                var shapeHit = this._hitTestItems(diagram.shapes, point);\n                var connectionHit = this._hitTestItems(diagram.connections, point);\n                var hit;\n\n                if ((!this.activeTool || this.activeTool.type != \"ConnectionTool\") && shapeHit && connectionHit && !hitTestShapeConnectors(shapeHit, point)) {\n                    var mainLayer = diagram.mainLayer;\n                    var shapeIdx = inArray(shapeHit.visual, mainLayer.children);\n                    var connectionIdx = inArray(connectionHit.visual, mainLayer.children);\n                    hit = shapeIdx > connectionIdx ? shapeHit : connectionHit;\n                }\n                return hit || shapeHit || connectionHit;\n            },\n\n            _hitTestItems: function(array, point) {\n                var i, item, hit;\n                for (i = array.length - 1; i >= 0; i--) {\n                    item = array[i];\n                    hit = item._hitTest(point);\n                    if (hit) {\n                        return hit;\n                    }\n                }\n            }\n        });\n\n// Routing =========================================\n\n        /**\n         * Base class for connection routers.\n         */\n        var ConnectionRouterBase = kendo.Class.extend({\n            init: function() {\n            }\n            /*route: function (connection) {\n             },\n             hitTest: function (p) {\n\n             },\n             getBounds: function () {\n\n             }*/\n        });\n\n        /**\n         * Base class for polyline and cascading routing.\n         */\n        var LinearConnectionRouter = ConnectionRouterBase.extend({\n            init: function(connection) {\n                var that = this;\n                ConnectionRouterBase.fn.init.call(that);\n                this.connection = connection;\n            },\n            /**\n             * Hit testing for polyline paths.\n             */\n            hitTest: function(p) {\n                var rec = this.getBounds().inflate(HIT_TEST_DISTANCE);\n                if (!rec.contains(p)) {\n                    return false;\n                }\n                return diagram.Geometry.distanceToPolyline(p, this.connection.allPoints()) < HIT_TEST_DISTANCE;\n            },\n\n            /**\n             * Bounds of a polyline.\n             * @returns {kendo.dataviz.diagram.Rect}\n             */\n            getBounds: function() {\n                var points = this.connection.allPoints(),\n                    s = points[0],\n                    e = points[points.length - 1],\n                    right = Math.max(s.x, e.x),\n                    left = Math.min(s.x, e.x),\n                    top = Math.min(s.y, e.y),\n                    bottom = Math.max(s.y, e.y);\n\n                for (var i = 1; i < points.length - 1; ++i) {\n                    right = Math.max(right, points[i].x);\n                    left = Math.min(left, points[i].x);\n                    top = Math.min(top, points[i].y);\n                    bottom = Math.max(bottom, points[i].y);\n                }\n\n                return new Rect(left, top, right - left, bottom - top);\n            }\n        });\n\n        /**\n         * A simple poly-linear routing which does not alter the intermediate points.\n         * Does hold the underlying hit, bounds....logic.\n         * @type {*|Object|void|extend|Zepto.extend|b.extend}\n         */\n        var PolylineRouter = LinearConnectionRouter.extend({\n            init: function(connection) {\n                var that = this;\n                LinearConnectionRouter.fn.init.call(that);\n                this.connection = connection;\n            },\n            route: function() {\n                // just keep the points as is\n            }\n        });\n\n        var CascadingRouter = LinearConnectionRouter.extend({\n            SAME_SIDE_DISTANCE_RATIO: 5,\n\n            init: function(connection) {\n                var that = this;\n                LinearConnectionRouter.fn.init.call(that);\n                this.connection = connection;\n            },\n\n            routePoints: function(start, end, sourceConnector, targetConnector) {\n                var result;\n\n                if (sourceConnector && targetConnector) {\n                    result = this._connectorPoints(start, end, sourceConnector, targetConnector);\n                } else {\n                    result = this._floatingPoints(start, end, sourceConnector);\n                }\n                return result;\n            },\n\n            route: function() {\n                var sourceConnector = this.connection._resolvedSourceConnector;\n                var targetConnector = this.connection._resolvedTargetConnector;\n                var start = this.connection.sourcePoint();\n                var end = this.connection.targetPoint();\n                var points = this.routePoints(start, end, sourceConnector, targetConnector);\n                this.connection.points(points);\n            },\n\n            _connectorSides: [{\n                name: \"Top\",\n                axis: \"y\",\n                boundsPoint: \"topLeft\",\n                secondarySign: 1\n            }, {\n                name: \"Left\",\n                axis: \"x\",\n                boundsPoint: \"topLeft\",\n                secondarySign: 1\n            }, {\n                name: \"Bottom\",\n                axis: \"y\",\n                boundsPoint: \"bottomRight\",\n                secondarySign: -1\n            }, {\n                name: \"Right\",\n                axis: \"x\",\n                boundsPoint: \"bottomRight\",\n                secondarySign: -1\n            }],\n\n            _connectorSide: function(connector, targetPoint) {\n                var position = connector.position();\n                var shapeBounds = connector.shape.bounds(ROTATED);\n                var bounds = {\n                    topLeft: shapeBounds.topLeft(),\n                    bottomRight: shapeBounds.bottomRight()\n                };\n                var sides = this._connectorSides;\n                var min = util.MAX_NUM;\n                var sideDistance;\n                var minSide;\n                var axis;\n                var side;\n                for (var idx = 0; idx < sides.length; idx++) {\n                    side = sides[idx];\n                    axis = side.axis;\n                    sideDistance = Math.round(Math.abs(position[axis] - bounds[side.boundsPoint][axis]));\n                    if (sideDistance < min) {\n                        min = sideDistance;\n                        minSide = side;\n                    } else if (sideDistance === min &&\n                        (position[axis] - targetPoint[axis]) * side.secondarySign > (position[minSide.axis] - targetPoint[minSide.axis]) * minSide.secondarySign) {\n                        minSide = side;\n                    }\n                }\n                return minSide.name;\n            },\n\n            _sameSideDistance: function(connector) {\n                var bounds = connector.shape.bounds(ROTATED);\n                return Math.min(bounds.width, bounds.height) / this.SAME_SIDE_DISTANCE_RATIO;\n            },\n\n            _connectorPoints: function(start, end, sourceConnector, targetConnector) {\n                var sourceConnectorSide = this._connectorSide(sourceConnector, end);\n                var targetConnectorSide = this._connectorSide(targetConnector, start);\n                var deltaX = end.x - start.x;\n                var deltaY = end.y - start.y;\n                var sameSideDistance = this._sameSideDistance(sourceConnector);\n                var result = [];\n                var pointX, pointY;\n\n                if (sourceConnectorSide === TOP || sourceConnectorSide == BOTTOM) {\n                    if (targetConnectorSide == TOP || targetConnectorSide == BOTTOM) {\n                        if (sourceConnectorSide == targetConnectorSide) {\n                            if (sourceConnectorSide == TOP) {\n                                pointY = Math.min(start.y, end.y) - sameSideDistance;\n                            } else {\n                                pointY = Math.max(start.y, end.y) + sameSideDistance;\n                            }\n                            result = [new Point(start.x, pointY), new Point(end.x, pointY)];\n                        } else {\n                            result = [new Point(start.x, start.y + deltaY / 2), new Point(end.x, start.y + deltaY / 2)];\n                        }\n                    } else {\n                        result = [new Point(start.x, end.y)];\n                    }\n                } else {\n                    if (targetConnectorSide == LEFT || targetConnectorSide == RIGHT) {\n                        if (sourceConnectorSide == targetConnectorSide) {\n                            if (sourceConnectorSide == LEFT) {\n                                pointX = Math.min(start.x, end.x) - sameSideDistance;\n                            } else {\n                                pointX = Math.max(start.x, end.x) + sameSideDistance;\n                            }\n                            result = [new Point(pointX, start.y), new Point(pointX, end.y)];\n                        } else {\n                            result = [new Point(start.x + deltaX / 2, start.y), new Point(start.x + deltaX / 2, start.y + deltaY)];\n                        }\n                    } else {\n                        result = [new Point(end.x, start.y)];\n                    }\n                }\n                return result;\n            },\n\n            _floatingPoints: function(start, end, sourceConnector) {\n                var sourceConnectorSide = sourceConnector ? this._connectorSide(sourceConnector, end) : null;\n                var cascadeStartHorizontal = this._startHorizontal(start, end, sourceConnectorSide);\n                var points = [start, start, end, end];\n                var deltaX = end.x - start.x;\n                var deltaY = end.y - start.y;\n                var length = points.length;\n                var shiftX;\n                var shiftY;\n\n                // note that this is more generic than needed for only two intermediate points.\n                for (var idx = 1; idx < length - 1; ++idx) {\n                    if (cascadeStartHorizontal) {\n                        if (idx % 2 !== 0) {\n                            shiftX = deltaX / (length / 2);\n                            shiftY = 0;\n                        }\n                        else {\n                            shiftX = 0;\n                            shiftY = deltaY / ((length - 1) / 2);\n                        }\n                    }\n                    else {\n                        if (idx % 2 !== 0) {\n                            shiftX = 0;\n                            shiftY = deltaY / (length / 2);\n                        }\n                        else {\n                            shiftX = deltaX / ((length - 1) / 2);\n                            shiftY = 0;\n                        }\n                    }\n                    points[idx] = new Point(points[idx - 1].x + shiftX, points[idx - 1].y + shiftY);\n                }\n                // need to fix the wrong 1.5 factor of the last intermediate point\n                idx--;\n                if ((cascadeStartHorizontal && (idx % 2 !== 0)) || (!cascadeStartHorizontal && (idx % 2 === 0))) {\n                    points[length - 2] = new Point(points[length - 1].x, points[length - 2].y);\n                } else {\n                    points[length - 2] = new Point(points[length - 2].x, points[length - 1].y);\n                }\n\n                return [points[1], points[2]];\n            },\n\n            _startHorizontal: function(start, end, sourceSide) {\n                var horizontal;\n                if (sourceSide !== null && (sourceSide === RIGHT || sourceSide === LEFT)) {\n                    horizontal = true;\n                } else {\n                    horizontal = Math.abs(start.x - end.x) > Math.abs(start.y - end.y);\n                }\n\n                return horizontal;\n            }\n        });\n\n// Adorners =========================================\n\n        var AdornerBase = Class.extend({\n            init: function(diagram, options) {\n                var that = this;\n                that.diagram = diagram;\n                that.options = deepExtend({}, that.options, options);\n                that.visual = new Group();\n                that.diagram._adorners.push(that);\n            },\n            refresh: function() {\n\n            }\n        });\n\n        var ConnectionEditAdorner = AdornerBase.extend({\n            init: function(connection, options) {\n                var that = this, diagram;\n                that.connection = connection;\n                diagram = that.connection.diagram;\n                that._ts = diagram.toolService;\n                AdornerBase.fn.init.call(that, diagram, options);\n                var sp = that.connection.sourcePoint();\n                var tp = that.connection.targetPoint();\n                that.spVisual = new Circle(deepExtend(that.options.handles, { center: sp }));\n                that.epVisual = new Circle(deepExtend(that.options.handles, { center: tp }));\n                that.visual.append(that.spVisual);\n                that.visual.append(that.epVisual);\n            },\n\n            options: {\n                handles: {}\n            },\n\n            _getCursor: function() {\n                return Cursors.move;\n            },\n\n            start: function(p) {\n                this.handle = this._hitTest(p);\n                this.startPoint = p;\n                this._initialSource = this.connection.source();\n                this._initialTarget = this.connection.target();\n                switch (this.handle) {\n                    case -1:\n                        if (this.connection.targetConnector) {\n                            this._ts._connectionManipulation(this.connection, this.connection.targetConnector.shape);\n                        }\n                        break;\n                    case 1:\n                        if (this.connection.sourceConnector) {\n                            this._ts._connectionManipulation(this.connection, this.connection.sourceConnector.shape);\n                        }\n                        break;\n                }\n            },\n\n            move: function(handle, p) {\n                switch (handle) {\n                    case -1:\n                        this.connection.source(p);\n                        break;\n                    case 1:\n                        this.connection.target(p);\n                        break;\n                    default:\n                        var delta = p.minus(this.startPoint);\n                        this.startPoint = p;\n                        if (!this.connection.sourceConnector) {\n                            this.connection.source(this.connection.sourcePoint().plus(delta));\n                        }\n                        if (!this.connection.targetConnector) {\n                            this.connection.target(this.connection.targetPoint().plus(delta));\n                        }\n                        break;\n                }\n                this.refresh();\n                return true;\n            },\n\n            stop: function(p) {\n                var ts = this.diagram.toolService, item = ts.hoveredItem, target;\n                if (ts._hoveredConnector) {\n                    target = ts._hoveredConnector._c;\n                } else if (item && item instanceof diagram.Shape) {\n                    target = item.getConnector(AUTO) || item.getConnector(p);\n                } else {\n                    target = p;\n                }\n\n                if (this.handle === -1) {\n                    this.connection.source(target);\n                } else if (this.handle === 1) {\n                    this.connection.target(target);\n                }\n\n                this.handle = undefined$1;\n                this._ts._connectionManipulation();\n                return new ConnectionEditUndoUnit(this.connection, this._initialSource, this._initialTarget);\n            },\n\n            _hitTest: function(point) {\n                var sourcePoint = this.connection.sourcePoint();\n                var targetPoint = this.connection.targetPoint();\n                var radiusX = this.options.handles.width / 2 + HIT_TEST_DISTANCE;\n                var radiusY = this.options.handles.height / 2 + HIT_TEST_DISTANCE;\n                var sourcePointDistance = sourcePoint.distanceTo(point);\n                var targetPointDistance = targetPoint.distanceTo(point);\n                var sourceHandle = new Rect(sourcePoint.x, sourcePoint.y).inflate(radiusX, radiusY).contains(point);\n                var targetHandle = new Rect(targetPoint.x, targetPoint.y).inflate(radiusX, radiusY).contains(point);\n                var handle = 0;\n\n                if (sourceHandle && (!targetHandle || sourcePointDistance < targetPointDistance)) {\n                    handle = -1;\n                } else if (targetHandle && (!sourceHandle || targetPointDistance < sourcePointDistance)) {\n                    handle = 1;\n                }\n\n                return handle;\n            },\n\n            refresh: function() {\n                this.spVisual.redraw({ center: this.diagram.modelToLayer(this.connection.sourcePoint()) });\n                this.epVisual.redraw({ center: this.diagram.modelToLayer(this.connection.targetPoint()) });\n            }\n        });\n\n        var ConnectorsAdorner = AdornerBase.extend({\n            init: function(diagram, options) {\n                var that = this;\n                AdornerBase.fn.init.call(that, diagram, options);\n                that._refreshHandler = function(e) {\n                    if (e.item == that.shape) {\n                        that.refresh();\n                    }\n                };\n            },\n\n            show: function(shape) {\n                var that = this, len, i, ctr;\n                that._visible = true;\n                that.shape = shape;\n                that.diagram.bind(ITEMBOUNDSCHANGE, that._refreshHandler);\n                len = shape.connectors.length;\n                that.connectors = [];\n                that._clearVisual();\n                for (i = 0; i < len; i++) {\n                    ctr = new ConnectorVisual(shape.connectors[i]);\n                    that.connectors.push(ctr);\n                    that.visual.append(ctr.visual);\n                }\n                that.visual.visible(true);\n                that.refresh();\n            },\n\n            _clearVisual: function() {\n                var that = this;\n                if (that.diagram._cachedTouchTarget) {\n                    that._keepCachedTouchTarget();\n                } else {\n                    that.visual.clear();\n                }\n            },\n\n            _keepCachedTouchTarget: function() {\n                var that = this,\n                    visualChildren = that.visual.children;\n                var childrenCount = visualChildren.length;\n                var index = inArray(that.diagram._cachedTouchTarget, visualChildren);\n                for (var i = childrenCount - 1; i >= 0; i--) {\n                    if (i == index) {\n                        continue;\n                    }\n                    that.visual.remove(visualChildren[i]);\n                }\n            },\n\n            destroy: function() {\n                var that = this;\n                that.diagram.unbind(ITEMBOUNDSCHANGE, that._refreshHandler);\n                that.shape = undefined$1;\n                that._visible = undefined$1;\n                that.visual.visible(false);\n            },\n\n            _hitTest: function(p) {\n                var ctr, i;\n                for (i = 0; i < this.connectors.length; i++) {\n                    ctr = this.connectors[i];\n                    if (ctr._hitTest(p)) {\n                        ctr._hover(true);\n                        this.diagram.toolService._hoveredConnector = ctr;\n                        break;\n                    }\n                }\n            },\n\n            refresh: function() {\n                if (this.shape) {\n                    var bounds = this.shape.bounds();\n                        bounds = this.diagram.modelToLayer(bounds);\n                    this.visual.position(bounds.topLeft());\n                    $.each(this.connectors, function() {\n                        this.refresh();\n                    });\n                }\n            }\n        });\n\n        function hitToOppositeSide(hit, bounds) {\n            var result;\n\n            if (hit.x == -1 && hit.y == -1) {\n                result = bounds.bottomRight();\n            } else if (hit.x == 1 && hit.y == 1) {\n                result = bounds.topLeft();\n            } else if (hit.x == -1 && hit.y == 1) {\n                result = bounds.topRight();\n            } else if (hit.x == 1 && hit.y == -1) {\n                result = bounds.bottomLeft();\n            } else if (hit.x === 0 && hit.y == -1) {\n                result = bounds.bottom();\n            } else if (hit.x === 0 && hit.y == 1) {\n                result = bounds.top();\n            } else if (hit.x == 1 && hit.y === 0) {\n                result = bounds.left();\n            } else if (hit.x == -1 && hit.y === 0) {\n                result = bounds.right();\n            }\n\n            return result;\n        }\n\n        var ResizingAdorner = AdornerBase.extend({\n            init: function(diagram, options) {\n                var that = this;\n                AdornerBase.fn.init.call(that, diagram, options);\n                that._manipulating = false;\n                that.map = [];\n                that.shapes = [];\n\n                that._initSelection();\n                that._createHandles();\n                that.redraw();\n                that.diagram.bind(\"select\", function(e) {\n                    that._initialize(e.selected);\n                });\n\n                that._refreshHandler = function() {\n                    if (!that._internalChange) {\n                        that.refreshBounds();\n                        that.refresh();\n                    }\n                };\n\n                that._rotatedHandler = function() {\n                    if (that.shapes.length == 1) {\n                        that._angle = that.shapes[0].rotate().angle;\n                    }\n                    that._refreshHandler();\n                };\n\n                that.diagram.bind(ITEMBOUNDSCHANGE, that._refreshHandler).bind(ITEMROTATE, that._rotatedHandler);\n                that.refreshBounds();\n                that.refresh();\n            },\n\n            options: {\n                handles: {\n                    fill: {\n                        color: \"#fff\"\n                    },\n                    stroke: {\n                        color: \"#282828\"\n                    },\n                    height: 7,\n                    width: 7,\n                    hover: {\n                        fill: {\n                            color: \"#282828\"\n                        },\n                        stroke: {\n                            color: \"#282828\"\n                        }\n                    }\n                },\n                selectable: {\n                    stroke: {\n                        color: \"#778899\",\n                        width: 1,\n                        dashType: \"dash\"\n                    },\n                    fill: {\n                        color: TRANSPARENT\n                    }\n                },\n                offset: 10\n            },\n\n            _initSelection: function() {\n                var that = this;\n                var diagram = that.diagram;\n                var selectable = diagram.options.selectable;\n                var options = deepExtend({}, that.options.selectable, selectable);\n                that.rect = new Rectangle(options);\n                that.visual.append(that.rect);\n            },\n\n            _resizable: function() {\n                return this.options.editable && this.options.editable.resize !== false;\n            },\n\n            _handleOptions: function() {\n                return (this.options.editable.resize || {}).handles || this.options.handles;\n            },\n\n            _createHandles: function() {\n                var handles, item, y, x;\n\n                if (this._resizable()) {\n                    handles = this._handleOptions();\n                    for (x = -1; x <= 1; x++) {\n                        for (y = -1; y <= 1; y++) {\n                            if ((x !== 0) || (y !== 0)) { // (0, 0) element, (-1, -1) top-left, (+1, +1) bottom-right\n                                item = new Rectangle(handles);\n                                item.drawingElement._hover = this._hover.bind(this);\n                                this.map.push({ x: x, y: y, visual: item });\n                                this.visual.append(item);\n                            }\n                        }\n                    }\n                }\n            },\n\n            bounds: function(value) {\n                if (value) {\n                    this._innerBounds = value.clone();\n                    this._bounds = this.diagram.modelToLayer(value).inflate(this.options.offset, this.options.offset);\n                } else {\n                    return this._bounds;\n                }\n            },\n\n            _hitTest: function(p) {\n                var tp = this.diagram.modelToLayer(p),\n                    i, hit, handleBounds, handlesCount = this.map.length, handle;\n\n                if (this._angle) {\n                    tp = tp.clone().rotate(this._bounds.center(), this._angle);\n                }\n\n                if (this._resizable()) {\n                    for (i = 0; i < handlesCount; i++) {\n                        handle = this.map[i];\n                        hit = new Point(handle.x, handle.y);\n                        handleBounds = this._getHandleBounds(hit); //local coordinates\n                        handleBounds.offset(this._bounds.x, this._bounds.y);\n                        if (handleBounds.contains(tp)) {\n                            return hit;\n                        }\n                    }\n                }\n\n                if (this._bounds.contains(tp)) {\n                    return new Point(0, 0);\n                }\n            },\n\n            _getHandleBounds: function(p) {\n                if (this._resizable()) {\n                    var handles = this._handleOptions(),\n                        w = handles.width,\n                        h = handles.height,\n                        r = new Rect(0, 0, w, h);\n\n                    if (p.x < 0) {\n                        r.x = - w / 2;\n                    } else if (p.x === 0) {\n                        r.x = Math.floor(this._bounds.width / 2) - w / 2;\n                    } else if (p.x > 0) {\n                        r.x = this._bounds.width + 1.0 - w / 2;\n                    } if (p.y < 0) {\n                        r.y = - h / 2;\n                    } else if (p.y === 0) {\n                        r.y = Math.floor(this._bounds.height / 2) - h / 2;\n                    } else if (p.y > 0) {\n                        r.y = this._bounds.height + 1.0 - h / 2;\n                    }\n\n                    return r;\n                }\n            },\n\n            _getCursor: function(point) {\n                var hit = this._hitTest(point);\n                if (hit && (hit.x >= -1) && (hit.x <= 1) && (hit.y >= -1) && (hit.y <= 1) && this._resizable()) {\n                    var angle = this._angle;\n                    if (angle) {\n                        angle = 360 - angle;\n                        hit.rotate(new Point(0, 0), angle);\n                        hit = new Point(Math.round(hit.x), Math.round(hit.y));\n                    }\n\n                    if (hit.x == -1 && hit.y == -1) {\n                        return \"nw-resize\";\n                    }\n                    if (hit.x == 1 && hit.y == 1) {\n                        return \"se-resize\";\n                    }\n                    if (hit.x == -1 && hit.y == 1) {\n                        return \"sw-resize\";\n                    }\n                    if (hit.x == 1 && hit.y == -1) {\n                        return \"ne-resize\";\n                    }\n                    if (hit.x === 0 && hit.y == -1) {\n                        return \"n-resize\";\n                    }\n                    if (hit.x === 0 && hit.y == 1) {\n                        return \"s-resize\";\n                    }\n                    if (hit.x == 1 && hit.y === 0) {\n                        return \"e-resize\";\n                    }\n                    if (hit.x == -1 && hit.y === 0) {\n                        return \"w-resize\";\n                    }\n                }\n                return this._manipulating ? Cursors.move : Cursors.select;\n            },\n\n            _initialize: function() {\n                var that = this, i, item,\n                    items = that.diagram.select();\n\n                that.shapes = [];\n                for (i = 0; i < items.length; i++) {\n                    item = items[i];\n                    if (item instanceof diagram.Shape) {\n                        that.shapes.push(item);\n                        item._rotationOffset = new Point();\n                    }\n                }\n\n                that._angle = that.shapes.length == 1 ? that.shapes[0].rotate().angle : 0;\n                that._startAngle = that._angle;\n                that._rotates();\n                that._positions();\n                that.refreshBounds();\n                that.refresh();\n                that.redraw();\n            },\n\n            _rotates: function() {\n                var that = this, i, shape;\n                that.initialRotates = [];\n                for (i = 0; i < that.shapes.length; i++) {\n                    shape = that.shapes[i];\n                    that.initialRotates.push(shape.rotate().angle);\n                }\n            },\n\n            _positions: function() {\n                var that = this, i, shape;\n                that.initialStates = [];\n                for (i = 0; i < that.shapes.length; i++) {\n                    shape = that.shapes[i];\n                    that.initialStates.push(shape.bounds());\n                }\n            },\n\n            _hover: function(value, element) {\n                if (this._resizable()) {\n                    var handleOptions = this._handleOptions(),\n                        hover = handleOptions.hover,\n                        stroke = handleOptions.stroke,\n                        fill = handleOptions.fill;\n\n                    if (value && Utils.isDefined(hover.stroke)) {\n                        stroke = deepExtend({}, stroke, hover.stroke);\n                    }\n\n                    if (value && Utils.isDefined(hover.fill)) {\n                        fill = hover.fill;\n                    }\n                    element.stroke(stroke.color, stroke.width, stroke.opacity);\n                    element.fill(fill.color, fill.opacity);\n                }\n            },\n\n            start: function(p) {\n                this._sp = p;\n                this._cp = p;\n                this._lp = p;\n                this._manipulating = true;\n                this._internalChange = true;\n                this.shapeStates = [];\n                for (var i = 0; i < this.shapes.length; i++) {\n                    var shape = this.shapes[i];\n                    this.shapeStates.push(shape.bounds());\n                }\n            },\n\n            redraw: function() {\n                var i, handle,\n                    visibleHandles = this._resizable();\n\n                for (i = 0; i < this.map.length; i++) {\n                    handle = this.map[i];\n                    handle.visual.visible(visibleHandles);\n                }\n            },\n\n            angle: function(value) {\n                if (defined(value)) {\n                    this._angle = value;\n                }\n\n                return this._angle;\n            },\n\n            rotate: function() {\n                var center = this._innerBounds.center();\n                var currentAngle = this.angle();\n                this._internalChange = true;\n                for (var i = 0; i < this.shapes.length; i++) {\n                    var shape = this.shapes[i];\n                    currentAngle = (currentAngle + this.initialRotates[i] - this._startAngle) % 360;\n                    shape.rotate(currentAngle, center);\n                }\n                this.refresh();\n            },\n\n            move: function(handle, p) {\n                var delta, dragging,\n                    dtl = new Point(),\n                    dbr = new Point(),\n                    bounds, center, shape,\n                    i, angle, newBounds,\n                    changed = 0, staticPoint,\n                    scaleX, scaleY;\n\n                if (handle.y === -2 && handle.x === -1) {\n                    center = this._innerBounds.center();\n                    this._angle = this._truncateAngle(Utils.findAngle(center, p));\n                    for (i = 0; i < this.shapes.length; i++) {\n                        shape = this.shapes[i];\n                        angle = (this._angle + this.initialRotates[i] - this._startAngle) % 360;\n                        shape.rotate(angle, center);\n                        if (shape.hasOwnProperty(\"layout\")) {\n                            shape.layout(shape);\n                        }\n                        this._rotating = true;\n                    }\n                    this.refresh();\n                } else {\n                    if (this.shouldSnap()) {\n                        var thr = this._truncateDistance(p.minus(this._lp));\n                        // threshold\n                        if (thr.x === 0 && thr.y === 0) {\n                            this._cp = p;\n                            return;\n                        }\n                        delta = thr;\n                        this._lp = new Point(this._lp.x + thr.x, this._lp.y + thr.y);\n                    } else {\n                        delta = p.minus(this._cp);\n                    }\n\n                    if (this.isDragHandle(handle)) {\n                        dbr = dtl = delta; // dragging\n                        dragging = true;\n                    } else {\n                        if (this._angle) { // adjust the delta so that resizers resize in the correct direction after rotation.\n                            delta.rotate(new Point(0, 0), this._angle);\n                        }\n                        if (handle.x == -1) {\n                            dtl.x = delta.x;\n                        } else if (handle.x == 1) {\n                            dbr.x = delta.x;\n                        }\n                        if (handle.y == -1) {\n                            dtl.y = delta.y;\n                        } else if (handle.y == 1) {\n                            dbr.y = delta.y;\n                        }\n                    }\n\n                    if (!dragging) {\n                        staticPoint = hitToOppositeSide(handle, this._innerBounds);\n                        scaleX = (this._innerBounds.width + delta.x * handle.x) / this._innerBounds.width;\n                        scaleY = (this._innerBounds.height + delta.y * handle.y) / this._innerBounds.height;\n                    }\n\n                    for (i = 0; i < this.shapes.length; i++) {\n                        shape = this.shapes[i];\n                        bounds = shape.bounds();\n                        if (dragging) {\n                            if (!canDrag(shape)) {\n                                continue;\n                            }\n                            newBounds = this._displaceBounds(bounds, dtl, dbr, dragging);\n                        } else {\n                            newBounds = bounds.clone();\n                            newBounds.scale(scaleX, scaleY, staticPoint, this._innerBounds.center(), shape.rotate().angle);\n                            var newCenter = newBounds.center(); // fixes the new rotation center.\n                            newCenter.rotate(bounds.center(), -this._angle);\n                            newBounds = new Rect(newCenter.x - newBounds.width / 2, newCenter.y - newBounds.height / 2, newBounds.width, newBounds.height);\n                        }\n                        if (newBounds.width >= shape.options.minWidth && newBounds.height >= shape.options.minHeight) { // if we up-size very small shape\n                            var oldBounds = bounds;\n                            shape.bounds(newBounds);\n                            if (shape.hasOwnProperty(\"layout\")) {\n                                shape.layout(shape, oldBounds, newBounds);\n                            }\n                            if (oldBounds.width !== newBounds.width || oldBounds.height !== newBounds.height) {\n                                shape.rotate(shape.rotate().angle); // forces the rotation to update it's rotation center\n                            }\n                            changed += 1;\n                        }\n                    }\n\n                    if (changed) {\n                        if (changed == i) {\n                            newBounds = this._displaceBounds(this._innerBounds, dtl, dbr, dragging);\n                            this.bounds(newBounds);\n                        } else {\n                            this.refreshBounds();\n                        }\n                        this.refresh();\n                    }\n\n                    this._positions();\n                }\n\n                this._cp = p;\n            },\n\n            isDragHandle: function(handle) {\n                return handle.x === 0 && handle.y === 0;\n            },\n\n            cancel: function() {\n                var shapes = this.shapes;\n                var states = this.shapeStates;\n                for (var idx = 0; idx < shapes.length; idx++) {\n                    shapes[idx].bounds(states[idx]);\n                }\n                this.refreshBounds();\n                this.refresh();\n                this._manipulating = undefined$1;\n                this._internalChange = undefined$1;\n                this._rotating = undefined$1;\n            },\n\n            _truncatePositionToGuides: function(bounds) {\n                if (this.diagram.ruler) {\n                    return this.diagram.ruler.truncatePositionToGuides(bounds);\n                }\n                return bounds;\n            },\n\n            _truncateSizeToGuides: function(bounds) {\n                if (this.diagram.ruler) {\n                    return this.diagram.ruler.truncateSizeToGuides(bounds);\n                }\n                return bounds;\n            },\n\n            _truncateAngle: function(a) {\n                var snap = this.snapOptions();\n                var snapAngle = Math.max(snap.angle || DEFAULT_SNAP_ANGLE, MIN_SNAP_ANGLE);\n                return snap ? Math.floor((a % 360) / snapAngle) * snapAngle : (a % 360);\n            },\n\n            _truncateDistance: function(d) {\n                if (d instanceof diagram.Point) {\n                    return new diagram.Point(this._truncateDistance(d.x), this._truncateDistance(d.y));\n                } else {\n                    var snap = this.snapOptions() || {};\n                    var snapSize = Math.max(snap.size || DEFAULT_SNAP_SIZE, MIN_SNAP_SIZE);\n                    return snap ? Math.floor(d / snapSize) * snapSize : d;\n                }\n            },\n\n            snapOptions: function() {\n                var editable = this.diagram.options.editable;\n                var snap = ((editable || {}).drag || {}).snap || {};\n                return snap;\n            },\n\n            shouldSnap: function() {\n                var editable = this.diagram.options.editable;\n                var drag = (editable || {}).drag;\n                var snap = (drag || {}).snap;\n                return editable !== false && drag !== false && snap !== false;\n            },\n\n            _displaceBounds: function(bounds, dtl, dbr, dragging) {\n                var tl = bounds.topLeft().plus(dtl),\n                    br = bounds.bottomRight().plus(dbr),\n                    newBounds = Rect.fromPoints(tl, br),\n                    newCenter;\n                if (!dragging) {\n                    newCenter = newBounds.center();\n                    newCenter.rotate(bounds.center(), -this._angle);\n                    newBounds = new Rect(newCenter.x - newBounds.width / 2, newCenter.y - newBounds.height / 2, newBounds.width, newBounds.height);\n                }\n                return newBounds;\n            },\n\n            stop: function() {\n                var unit, i, shape;\n                if (this._cp != this._sp) {\n                    if (this._rotating) {\n                        unit = new RotateUnit(this, this.shapes, this.initialRotates);\n                        this._rotating = false;\n                    } else if (this._diffStates()) {\n                        if (this.diagram.ruler) {\n                            for (i = 0; i < this.shapes.length; i++) {\n                                shape = this.shapes[i];\n                                var bounds = shape.bounds();\n                                bounds = this._truncateSizeToGuides(this._truncatePositionToGuides(bounds));\n                                shape.bounds(bounds);\n                                this.refreshBounds();\n                                this.refresh();\n                            }\n                        }\n                        for (i = 0; i < this.shapes.length; i++) {\n                            shape = this.shapes[i];\n                            shape.updateModel();\n                        }\n                        unit = new TransformUnit(this.shapes, this.shapeStates, this);\n                        this.diagram._syncShapeChanges();\n                    }\n                }\n\n                this._manipulating = undefined$1;\n                this._internalChange = undefined$1;\n                this._rotating = undefined$1;\n                return unit;\n            },\n\n            _diffStates: function() {\n                var shapes = this.shapes;\n                var states = this.shapeStates;\n                for (var idx = 0; idx < shapes.length; idx++) {\n                    if (!shapes[idx].bounds().equals(states[idx])) {\n                        return true;\n                    }\n                }\n                return false;\n            },\n\n            refreshBounds: function() {\n                var bounds = this.shapes.length == 1 ?\n                    this.shapes[0].bounds().clone() :\n                    this.diagram.boundingBox(this.shapes, true);\n\n                this.bounds(bounds);\n            },\n\n            refresh: function() {\n                var that = this, b, bounds;\n                if (this.shapes.length > 0) {\n                    bounds = this.bounds();\n                    this.visual.visible(true);\n                    this.visual.position(bounds.topLeft());\n                    $.each(this.map, function() {\n                        b = that._getHandleBounds(new Point(this.x, this.y));\n                        this.visual.position(b.topLeft());\n                    });\n                    this.visual.position(bounds.topLeft());\n\n                    var center = new Point(bounds.width / 2, bounds.height / 2);\n                    this.visual.rotate(this._angle, center);\n                    this.rect.redraw({ width: bounds.width, height: bounds.height });\n                    if (this.rotationThumb) {\n                        var thumb = this.options.editable.rotate.thumb;\n                        this._rotationThumbBounds = new Rect(bounds.center().x, bounds.y + thumb.y, 0, 0).inflate(thumb.width);\n                        this.rotationThumb.redraw({ x: bounds.width / 2 - thumb.width / 2 });\n                    }\n                } else {\n                    this.visual.visible(false);\n                }\n            }\n        });\n\n        var Selector = Class.extend({\n            init: function(diagram) {\n                var selectable = diagram.options.selectable;\n                this.options = deepExtend({}, this.options, selectable);\n\n                this.visual = new Rectangle(this.options);\n                this.diagram = diagram;\n            },\n            options: {\n                stroke: {\n                    color: \"#778899\",\n                    width: 1,\n                    dashType: \"dash\"\n                },\n                fill: {\n                    color: TRANSPARENT\n                }\n            },\n            start: function(p) {\n                this._sp = this._ep = p;\n                this.refresh();\n                this.diagram._adorn(this, true);\n            },\n            end: function() {\n                this._sp = this._ep = undefined$1;\n                this.diagram._adorn(this, false);\n            },\n            bounds: function(value) {\n                if (value) {\n                    this._bounds = value;\n                }\n                return this._bounds;\n            },\n            move: function(p) {\n                this._ep = p;\n                this.refresh();\n            },\n            refresh: function() {\n                if (this._sp) {\n                    var visualBounds = Rect.fromPoints(this.diagram.modelToLayer(this._sp), this.diagram.modelToLayer(this._ep));\n                    this.bounds(Rect.fromPoints(this._sp, this._ep));\n                    this.visual.position(visualBounds.topLeft());\n                    this.visual.redraw({ height: visualBounds.height + 1, width: visualBounds.width + 1 });\n                }\n            }\n        });\n\n        var ConnectorVisual = Class.extend({\n            init: function(connector) {\n                this.options = deepExtend({}, connector.options);\n                this._c = connector;\n                this.visual = new Circle(this.options);\n                this.refresh();\n            },\n            _hover: function(value) {\n                var options = this.options,\n                    hover = options.hover,\n                    stroke = options.stroke,\n                    fill = options.fill;\n\n                if (value && Utils.isDefined(hover.stroke)) {\n                    stroke = deepExtend({}, stroke, hover.stroke);\n                }\n\n                if (value && Utils.isDefined(hover.fill)) {\n                    fill = hover.fill;\n                }\n\n                this.visual.redraw({\n                    stroke: stroke,\n                    fill: fill\n                });\n            },\n            refresh: function() {\n                var p = this._c.shape.diagram.modelToView(this._c.position()),\n                    relative = p.minus(this._c.shape.bounds(\"transformed\").topLeft()),\n                    value = new Rect(p.x, p.y, 0, 0);\n                value.inflate(this.options.width / 2, this.options.height / 2);\n                this._visualBounds = value;\n                this.visual.redraw({ center: new Point(relative.x, relative.y) });\n            },\n            _hitTest: function(p) {\n                var tp = this._c.shape.diagram.modelToView(p);\n                return this._visualBounds.contains(tp);\n            }\n        });\n\n        function canDrag(element) {\n            var editable = element.options.editable;\n            return editable && editable.drag !== false;\n        }\n\n        function hitTestShapeConnectors(shape, point) {\n            var connector, position, rect;\n            for (var idx = 0; idx < shape.connectors.length; idx++) {\n                connector = shape.connectors[idx];\n                position = connector.position();\n                rect = new Rect(position.x, position.y);\n                rect.inflate(HIT_TEST_DISTANCE, HIT_TEST_DISTANCE);\n                if (rect.contains(point)) {\n                    return connector;\n                }\n            }\n        }\n\n        function noMeta(meta) {\n            return meta.ctrlKey === false && meta.altKey === false && meta.shiftKey === false;\n        }\n\n        deepExtend(diagram, {\n            CompositeUnit: CompositeUnit,\n            TransformUnit: TransformUnit,\n            PanUndoUnit: PanUndoUnit,\n            AddShapeUnit: AddShapeUnit,\n            AddConnectionUnit: AddConnectionUnit,\n            DeleteShapeUnit: DeleteShapeUnit,\n            DeleteConnectionUnit: DeleteConnectionUnit,\n            ConnectionEditAdorner: ConnectionEditAdorner,\n            ConnectionTool: ConnectionTool,\n            ConnectorVisual: ConnectorVisual,\n            UndoRedoService: UndoRedoService,\n            ResizingAdorner: ResizingAdorner,\n            Selector: Selector,\n            ToolService: ToolService,\n            ConnectorsAdorner: ConnectorsAdorner,\n            LayoutUndoUnit: LayoutUndoUnit,\n            ConnectionEditUnit: ConnectionEditUnit,\n            ToFrontUnit: ToFrontUnit,\n            ToBackUnit: ToBackUnit,\n            ConnectionRouterBase: ConnectionRouterBase,\n            PolylineRouter: PolylineRouter,\n            CascadingRouter: CascadingRouter,\n            SelectionTool: SelectionTool,\n            ScrollerTool: ScrollerTool,\n            PointerTool: PointerTool,\n            ConnectionEditTool: ConnectionEditTool,\n            RotateUnit: RotateUnit\n        });\n})(window.kendo.jQuery);\n\n(function($, undefined$1) {\n    var kendo = window.kendo,\n        diagram = kendo.dataviz.diagram,\n        Graph = diagram.Graph,\n        Node = diagram.Node,\n        Link = diagram.Link,\n        deepExtend = kendo.deepExtend,\n        Size = diagram.Size,\n        Rect = diagram.Rect,\n        Dictionary = diagram.Dictionary,\n        Set = diagram.Set,\n        HyperTree = diagram.Graph,\n        Utils = diagram.Utils,\n        Point = diagram.Point,\n        EPSILON = 1e-06,\n        DEG_TO_RAD = Math.PI / 180,\n        contains = Utils.contains,\n        grep = $.grep;\n\n    /**\n     * Base class for layout algorithms.\n     * @type {*}\n     */\n    var LayoutBase = kendo.Class.extend({\n        defaultOptions: {\n            type: \"Tree\",\n            subtype: \"Down\",\n            roots: null,\n            animate: false,\n            //-------------------------------------------------------------------\n            /**\n             * Force-directed option: whether the motion of the nodes should be limited by the boundaries of the diagram surface.\n             */\n            limitToView: false,\n            /**\n             * Force-directed option: the amount of friction applied to the motion of the nodes.\n             */\n            friction: 0.9,\n            /**\n             * Force-directed option: the optimal distance between nodes (minimum energy).\n             */\n            nodeDistance: 50,\n            /**\n             * Force-directed option: the number of time things are being calculated.\n             */\n            iterations: 300,\n            //-------------------------------------------------------------------\n            /**\n             * Tree option: the separation in one direction (depends on the subtype what direction this is).\n             */\n            horizontalSeparation: 90,\n            /**\n             * Tree option: the separation in the complementary direction (depends on the subtype what direction this is).\n             */\n            verticalSeparation: 50,\n\n            //-------------------------------------------------------------------\n            /**\n             * Tip-over tree option: children-to-parent vertical distance.\n             */\n            underneathVerticalTopOffset: 15,\n            /**\n             * Tip-over tree option: children-to-parent horizontal distance.\n             */\n            underneathHorizontalOffset: 15,\n            /**\n             * Tip-over tree option: leaf-to-next-branch vertical distance.\n             */\n            underneathVerticalSeparation: 15,\n            //-------------------------------------------------------------------\n            /**\n             * Settings object to organize the different components of the diagram in a grid layout structure\n             */\n            grid: {\n                /**\n                 * The width of the grid in which components are arranged. Beyond this width a component will be on the next row.\n                 */\n                width: 1500,\n                /**\n                 * The left offset of the grid.\n                 */\n                offsetX: 50,\n                /**\n                 * The top offset of the grid.\n                 */\n                offsetY: 50,\n                /**\n                 * The horizontal padding within a cell of the grid where a single component resides.\n                 */\n                componentSpacingX: 20,\n                /**\n                 * The vertical padding within a cell of the grid where a single component resides.\n                 */\n                componentSpacingY: 20\n            },\n\n            //-------------------------------------------------------------------\n            /**\n             * Layered option: the separation height/width between the layers.\n             */\n            layerSeparation: 50,\n            /**\n             * Layered option: how many rounds of shifting and fine-tuning.\n             */\n            layeredIterations: 2,\n            /**\n             * Tree-radial option: the angle at which the layout starts.\n             */\n            startRadialAngle: 0,\n            /**\n             * Tree-radial option: the angle at which the layout starts.\n             */\n            endRadialAngle: 360,\n            /**\n             * Tree-radial option: the separation between levels.\n             */\n            radialSeparation: 150,\n            /**\n             * Tree-radial option: the separation between the root and the first level.\n             */\n            radialFirstLevelSeparation: 200,\n            /**\n             * Tree-radial option: whether a virtual roots bing the components in one radial layout.\n             */\n            keepComponentsInOneRadialLayout: false,\n            //-------------------------------------------------------------------\n\n            // TODO: ensure to change this to false when containers are around\n            ignoreContainers: true,\n            layoutContainerChildren: false,\n            ignoreInvisible: true,\n            animateTransitions: false\n        },\n        init: function() {\n        },\n\n        /**\n         * Organizes the components in a grid.\n         * Returns the final set of nodes (not the Graph).\n         * @param components\n         */\n        gridLayoutComponents: function(components) {\n            if (!components) {\n                throw \"No components supplied.\";\n            }\n\n            // calculate and cache the bounds of the components\n            Utils.forEach(components, function(c) {\n                c.calcBounds();\n            });\n\n            // order by decreasing width\n            components.sort(function(a, b) {\n                return b.bounds.width - a.bounds.width;\n            });\n\n            var maxWidth = this.options.grid.width,\n                offsetX = this.options.grid.componentSpacingX,\n                offsetY = this.options.grid.componentSpacingY,\n                height = 0,\n                startX = this.options.grid.offsetX,\n                startY = this.options.grid.offsetY,\n                x = startX,\n                y = startY,\n                i,\n                resultLinkSet = [],\n                resultNodeSet = [];\n\n            while (components.length > 0) {\n                if (x >= maxWidth) {\n                    // start a new row\n                    x = startX;\n                    y += height + offsetY;\n                    // reset the row height\n                    height = 0;\n                }\n                var component = components.pop();\n                this.moveToOffset(component, new Point(x, y));\n                for (i = 0; i < component.nodes.length; i++) {\n                    resultNodeSet.push(component.nodes[i]); // to be returned in the end\n                }\n                for (i = 0; i < component.links.length; i++) {\n                    resultLinkSet.push(component.links[i]);\n                }\n                var boundingRect = component.bounds;\n                var currentHeight = boundingRect.height;\n                if (currentHeight <= 0 || isNaN(currentHeight)) {\n                    currentHeight = 0;\n                }\n                var currentWidth = boundingRect.width;\n                if (currentWidth <= 0 || isNaN(currentWidth)) {\n                    currentWidth = 0;\n                }\n\n                if (currentHeight >= height) {\n                    height = currentHeight;\n                }\n                x += currentWidth + offsetX;\n            }\n\n            return {\n                nodes: resultNodeSet,\n                links: resultLinkSet\n            };\n        },\n\n        moveToOffset: function(component, p) {\n            var i, j,\n                bounds = component.bounds,\n                deltax = p.x - bounds.x,\n                deltay = p.y - bounds.y;\n\n            for (i = 0; i < component.nodes.length; i++) {\n                var node = component.nodes[i];\n                var nodeBounds = node.bounds();\n                if (nodeBounds.width === 0 && nodeBounds.height === 0 && nodeBounds.x === 0 && nodeBounds.y === 0) {\n                    nodeBounds = new Rect(0, 0, 0, 0);\n                }\n                nodeBounds.x += deltax;\n                nodeBounds.y += deltay;\n                node.bounds(nodeBounds);\n            }\n            for (i = 0; i < component.links.length; i++) {\n                var link = component.links[i];\n                if (link.points) {\n                    var newpoints = [];\n                    var points = link.points;\n                    for (j = 0; j < points.length; j++) {\n                        var pt = points[j];\n                        pt.x += deltax;\n                        pt.y += deltay;\n                        newpoints.push(pt);\n                    }\n                    link.points = newpoints;\n                }\n            }\n            this.currentHorizontalOffset += bounds.width + this.options.grid.offsetX;\n            return new Point(deltax, deltay);\n        },\n\n        transferOptions: function(options) {\n\n            // Size options lead to stackoverflow and need special handling\n\n            this.options = kendo.deepExtend({}, this.defaultOptions);\n            if (Utils.isUndefined(options)) {\n                return;\n            }\n\n            this.options = kendo.deepExtend(this.options, options || {});\n        }\n    });\n\n    /**\n     * The data bucket a hypertree holds in its nodes.     *\n     * @type {*}\n     */\n    /* var ContainerGraph = kendo.Class.extend({\n     init: function (diagram) {\n     this.diagram = diagram;\n     this.graph = new Graph(diagram);\n     this.container = null;\n     this.containerNode = null;\n     }\n\n     });*/\n\n    /**\n     * Adapter between the diagram control and the graph representation. It converts shape and connections to nodes and edges taking into the containers and their collapsef state,\n     * the visibility of items and more. If the layoutContainerChildren is true a hypertree is constructed which holds the hierarchy of containers and many conditions are analyzed\n     * to investigate how the effective graph structure looks like and how the layout has to be performed.\n     * @type {*}\n     */\n    var DiagramToHyperTreeAdapter = kendo.Class.extend({\n        init: function(diagram) {\n\n            /**\n             * The mapping to/from the original nodes.\n             * @type {Dictionary}\n             */\n            this.nodeMap = new Dictionary();\n\n            /**\n             * Gets the mapping of a shape to a container in case the shape sits in a collapsed container.\n             * @type {Dictionary}\n             */\n            this.shapeMap = new Dictionary();\n\n            /**\n             * The nodes being mapped.\n             * @type {Dictionary}\n             */\n            this.nodes = [];\n\n            /**\n             * The connections being mapped.\n             * @type {Dictionary}\n             */\n            this.edges = [];\n\n            // the mapping from an edge to all the connections it represents, this can be both because of multiple connections between\n            // two shapes or because a container holds multiple connections to another shape or container.\n            this.edgeMap = new Dictionary();\n\n            /**\n             * The resulting set of Nodes when the analysis has finished.\n             * @type {Array}\n             */\n            this.finalNodes = [];\n\n            /**\n             * The resulting set of Links when the analysis has finished.\n             * @type {Array}\n             */\n            this.finalLinks = [];\n\n            /**\n             * The items being omitted because of multigraph edges.\n             * @type {Array}\n             */\n            this.ignoredConnections = [];\n\n            /**\n             * The items being omitted because of containers, visibility and other factors.\n             * @type {Array}\n             */\n            this.ignoredShapes = [];\n\n            /**\n             * The map from a node to the partition/hypernode in which it sits. This hyperMap is null if 'options.layoutContainerChildren' is false.\n             * @type {Dictionary}\n             */\n            this.hyperMap = new Dictionary();\n\n            /**\n             * The hypertree contains the hierarchy defined by the containers.\n             * It's in essence a Graph of Graphs with a tree structure defined by the hierarchy of containers.\n             * @type {HyperTree}\n             */\n            this.hyperTree = new Graph();\n\n            /**\n             * The resulting graph after conversion. Note that this does not supply the information contained in the\n             * ignored connection and shape collections.\n             * @type {null}\n             */\n            this.finalGraph = null;\n\n            this.diagram = diagram;\n        },\n\n        /**\n         * The hyperTree is used when the 'options.layoutContainerChildren' is true. It contains the hierarchy of containers whereby each node is a ContainerGraph.\n         * This type of node has a Container reference to the container which holds the Graph items. There are three possible situations during the conversion process:\n         *  - Ignore the containers: the container are non-existent and only normal shapes are mapped. If a shape has a connection to a container it will be ignored as well\n         *    since there is no node mapped for the container.\n         *  - Do not ignore the containers and leave the content of the containers untouched: the top-level elements are being mapped and the children within a container are not altered.\n         *  - Do not ignore the containers and organize the content of the containers as well: the hypertree is constructed and there is a partitioning of all nodes and connections into the hypertree.\n         *    The only reason a connection or node is not being mapped might be due to the visibility, which includes the visibility change through a collapsed parent container.\n         * @param options\n         */\n        convert: function(options) {\n\n            if (Utils.isUndefined(this.diagram)) {\n                throw \"No diagram to convert.\";\n            }\n\n            this.options = kendo.deepExtend({\n                    ignoreInvisible: true,\n                    ignoreContainers: true,\n                    layoutContainerChildren: false\n                },\n                options || {}\n            );\n\n            this.clear();\n            // create the nodes which participate effectively in the graph analysis\n            this._renormalizeShapes();\n\n            // recreate the incoming and outgoing collections of each and every node\n            this._renormalizeConnections();\n\n            // export the resulting graph\n            this.finalNodes = new Dictionary(this.nodes);\n            this.finalLinks = new Dictionary(this.edges);\n\n            this.finalGraph = new Graph();\n            this.finalNodes.forEach(function(n) {\n                this.finalGraph.addNode(n);\n            }, this);\n            this.finalLinks.forEach(function(l) {\n                this.finalGraph.addExistingLink(l);\n            }, this);\n            return this.finalGraph;\n        },\n\n        /**\n         * Maps the specified connection to an edge of the graph deduced from the given diagram.\n         * @param connection\n         * @returns {*}\n         */\n        mapConnection: function(connection) {\n            return this.edgeMap.get(connection.id);\n        },\n\n        /**\n         * Maps the specified shape to a node of the graph deduced from the given diagram.\n         * @param shape\n         * @returns {*}\n         */\n        mapShape: function(shape) {\n            return this.nodeMap.get(shape.id);\n        },\n\n        /**\n         * Gets the edge, if any, between the given nodes.\n         * @param a\n         * @param b\n         */\n        getEdge: function(a, b) {\n            return Utils.first(a.links, function(link) {\n                return link.getComplement(a) === b;\n            });\n        },\n\n        /**\n         * Clears all the collections used by the conversion process.\n         */\n        clear: function() {\n            this.finalGraph = null;\n            this.hyperTree = (!this.options.ignoreContainers && this.options.layoutContainerChildren) ? new HyperTree() : null;\n            this.hyperMap = (!this.options.ignoreContainers && this.options.layoutContainerChildren) ? new Dictionary() : null;\n            this.nodeMap = new Dictionary();\n            this.shapeMap = new Dictionary();\n            this.nodes = [];\n            this.edges = [];\n            this.edgeMap = new Dictionary();\n            this.ignoredConnections = [];\n            this.ignoredShapes = [];\n            this.finalNodes = [];\n            this.finalLinks = [];\n        },\n\n        /**\n         * The path from a given ContainerGraph to the root (container).\n         * @param containerGraph\n         * @returns {Array}\n         */\n        listToRoot: function(containerGraph) {\n            var list = [];\n            var s = containerGraph.container;\n            if (!s) {\n                return list;\n            }\n            list.push(s);\n            while (s.parentContainer) {\n                s = s.parentContainer;\n                list.push(s);\n            }\n            list.reverse();\n            return list;\n        },\n\n        firstNonIgnorableContainer: function(shape) {\n\n            if (shape.isContainer && !this._isIgnorableItem(shape)) {\n                return shape;\n            }\n            return !shape.parentContainer ? null : this.firstNonIgnorableContainer(shape.parentContainer);\n        },\n        isContainerConnection: function(a, b) {\n            if (a.isContainer && this.isDescendantOf(a, b)) {\n                return true;\n            }\n            return b.isContainer && this.isDescendantOf(b, a);\n        },\n\n        /**\n         * Returns true if the given shape is a direct child or a nested container child of the given container.\n         * If the given container and shape are the same this will return false since a shape cannot be its own child.\n         * @param scope\n         * @param a\n         * @returns {boolean}\n         */\n        isDescendantOf: function(scope, a) {\n            if (!scope.isContainer) {\n                throw \"Expecting a container.\";\n            }\n            if (scope === a) {\n                return false;\n            }\n            if (contains(scope.children, a)) {\n                return true;\n            }\n            var containers = [];\n            for (var i = 0, len = scope.children.length; i < len; i++) {\n                var c = scope.children[i];\n                if (c.isContainer && this.isDescendantOf(c, a)) {\n                    containers.push(c);\n                }\n            }\n\n            return containers.length > 0;\n        },\n        isIgnorableItem: function(shape) {\n            if (this.options.ignoreInvisible) {\n                if (shape.isCollapsed && this._isVisible(shape)) {\n                    return false;\n                }\n                if (!shape.isCollapsed && this._isVisible(shape)) {\n                    return false;\n                }\n                return true;\n            }\n            else {\n                return shape.isCollapsed && !this._isTop(shape);\n            }\n        },\n\n        /**\n         *  Determines whether the shape is or needs to be mapped to another shape. This occurs essentially when the shape sits in\n         * a collapsed container hierarchy and an external connection needs a node endpoint. This node then corresponds to the mapped shape and is\n         * necessarily a container in the parent hierarchy of the shape.\n         * @param shape\n         */\n        isShapeMapped: function(shape) {\n            return shape.isCollapsed && !this._isVisible(shape) && !this._isTop(shape);\n        },\n\n        leastCommonAncestor: function(a, b) {\n            if (!a) {\n                throw \"Parameter should not be null.\";\n            }\n            if (!b) {\n                throw \"Parameter should not be null.\";\n            }\n\n            if (!this.hyperTree) {\n                throw \"No hypertree available.\";\n            }\n            var al = this.listToRoot(a);\n            var bl = this.listToRoot(b);\n            var found = null;\n            if (Utils.isEmpty(al) || Utils.isEmpty(bl)) {\n                return this.hyperTree.root.data;\n            }\n            var xa = al[0];\n            var xb = bl[0];\n            var i = 0;\n            while (xa === xb) {\n                found = al[i];\n                i++;\n                if (i >= al.length || i >= bl.length) {\n                    break;\n                }\n                xa = al[i];\n                xb = bl[i];\n            }\n            if (!found) {\n                return this.hyperTree.root.data;\n            }\n            else {\n                return grep(this.hyperTree.nodes, function(n) {\n                    return n.data.container === found;\n                });\n            }\n        },\n        /**\n         * Determines whether the specified item is a top-level shape or container.\n         * @param item\n         * @returns {boolean}\n         * @private\n         */\n        _isTop: function(item) {\n            return !item.parentContainer;\n        },\n\n        /**\n         * Determines iteratively (by walking up the container stack) whether the specified shape is visible.\n         * This does NOT tell whether the item is not visible due to an explicit Visibility change or due to a collapse state.\n         * @param shape\n         * @returns {*}\n         * @private\n         */\n        _isVisible: function(shape) {\n\n            if (!shape.visible()) {\n                return false;\n            }\n            return !shape.parentContainer ? shape.visible() : this._isVisible(shape.parentContainer);\n        },\n\n        _isCollapsed: function(shape) {\n\n            if (shape.isContainer && shape.isCollapsed) {\n                return true;\n            }\n            return shape.parentContainer && this._isCollapsed(shape.parentContainer);\n        },\n\n        /**\n         * First part of the graph creation; analyzing the shapes and containers and deciding whether they should be mapped to a Node.\n         * @private\n         */\n        _renormalizeShapes: function() {\n            // add the nodes, the adjacency structure will be reconstructed later on\n            if (this.options.ignoreContainers) {\n                for (var i = 0, len = this.diagram.shapes.length; i < len; i++) {\n                    var shape = this.diagram.shapes[i];\n\n                    // if not visible (and ignoring the invisible ones) or a container we skip\n                    if ((this.options.ignoreInvisible && !this._isVisible(shape)) || shape.isContainer) {\n                        this.ignoredShapes.push(shape);\n                        continue;\n                    }\n                    var node = new Node(shape.id, shape);\n                    node.isVirtual = false;\n\n                    // the mapping will always contain singletons and the hyperTree will be null\n                    this.nodeMap.add(shape.id, node);\n                    this.nodes.push(node);\n                }\n            }\n            else {\n                throw \"Containers are not supported yet, but stay tuned.\";\n            }\n        },\n\n        /**\n         * Second part of the graph creation; analyzing the connections and deciding whether they should be mapped to an edge.\n         * @private\n         */\n        _renormalizeConnections: function() {\n            if (this.diagram.connections.length === 0) {\n                return;\n            }\n            for (var i = 0, len = this.diagram.connections.length; i < len; i++) {\n                var conn = this.diagram.connections[i];\n\n                if (this.isIgnorableItem(conn)) {\n                    this.ignoredConnections.push(conn);\n                    continue;\n                }\n\n                var source = !conn.sourceConnector ? null : conn.sourceConnector.shape;\n                var sink = !conn.targetConnector ? null : conn.targetConnector.shape;\n\n                // no layout for floating connections\n                if (!source || !sink) {\n                    this.ignoredConnections.push(conn);\n                    continue;\n                }\n\n                if (contains(this.ignoredShapes, source) && !this.shapeMap.containsKey(source)) {\n                    this.ignoredConnections.push(conn);\n                    continue;\n                }\n                if (contains(this.ignoredShapes, sink) && !this.shapeMap.containsKey(sink)) {\n                    this.ignoredConnections.push(conn);\n                    continue;\n                }\n\n                // if the endpoint sits in a collapsed container we need the container rather than the shape itself\n                if (this.shapeMap.containsKey(source)) {\n                    source = this.shapeMap[source];\n                }\n                if (this.shapeMap.containsKey(sink)) {\n                    sink = this.shapeMap[sink];\n                }\n\n                var sourceNode = this.mapShape(source);\n                var sinkNode = this.mapShape(sink);\n                if ((sourceNode === sinkNode) || this.areConnectedAlready(sourceNode, sinkNode)) {\n                    this.ignoredConnections.push(conn);\n                    continue;\n                }\n\n                if (sourceNode === null || sinkNode === null) {\n                    throw \"A shape was not mapped to a node.\";\n                }\n                if (this.options.ignoreContainers) {\n                    // much like a floating connection here since at least one end is attached to a container\n                    if (sourceNode.isVirtual || sinkNode.isVirtual) {\n                        this.ignoredConnections.push(conn);\n                        continue;\n                    }\n                    var newEdge = new Link(sourceNode, sinkNode, conn.id, conn);\n\n                    this.edgeMap.add(conn.id, newEdge);\n                    this.edges.push(newEdge);\n                }\n                else {\n                    throw \"Containers are not supported yet, but stay tuned.\";\n                }\n            }\n        },\n\n        areConnectedAlready: function(n, m) {\n            return Utils.any(this.edges, function(l) {\n                return l.source === n && l.target === m || l.source === m && l.target === n;\n            });\n        }\n\n        /**\n         * Depth-first traversal of the given container.\n         * @param container\n         * @param action\n         * @param includeStart\n         * @private\n         */\n        /* _visitContainer: function (container, action, includeStart) {\n\n         *//*if (container == null) throw new ArgumentNullException(\"container\");\n         if (action == null) throw new ArgumentNullException(\"action\");\n         if (includeStart) action(container);\n         if (container.children.isEmpty()) return;\n         foreach(\n         var item\n         in\n         container.children.OfType < IShape > ()\n         )\n         {\n         var childContainer = item\n         as\n         IContainerShape;\n         if (childContainer != null) this.VisitContainer(childContainer, action);\n         else action(item);\n         }*//*\n         }*/\n\n\n    });\n\n    /**\n     * The classic spring-embedder (aka force-directed, Fruchterman-Rheingold, barycentric) algorithm.\n     * http://en.wikipedia.org/wiki/Force-directed_graph_drawing\n     *  - Chapter 12 of Tamassia et al. \"Handbook of graph drawing and visualization\".\n     *  - Kobourov on preprint arXiv; http://arxiv.org/pdf/1201.3011.pdf\n     *  - Fruchterman and Rheingold in SOFTWARE-PRACTICE AND EXPERIENCE, VOL. 21(1 1), 1129-1164 (NOVEMBER 1991)\n     * @type {*}\n     */\n    var SpringLayout = LayoutBase.extend({\n        init: function(diagram) {\n            var that = this;\n            LayoutBase.fn.init.call(that);\n            if (Utils.isUndefined(diagram)) {\n                throw \"Diagram is not specified.\";\n            }\n            this.diagram = diagram;\n        },\n\n        layout: function(options) {\n\n            this.transferOptions(options);\n\n            var adapter = new DiagramToHyperTreeAdapter(this.diagram);\n            var graph = adapter.convert(options);\n            if (graph.isEmpty()) {\n                return;\n            }\n            // split into connected components\n            var components = graph.getConnectedComponents();\n            if (Utils.isEmpty(components)) {\n                return;\n            }\n            for (var i = 0; i < components.length; i++) {\n                var component = components[i];\n                this.layoutGraph(component, options);\n            }\n            var finalNodeSet = this.gridLayoutComponents(components);\n            return new diagram.LayoutState(this.diagram, finalNodeSet);\n        },\n\n        layoutGraph: function(graph, options) {\n\n            if (Utils.isDefined(options)) {\n                this.transferOptions(options);\n            }\n            this.graph = graph;\n\n            var initialTemperature = this.options.nodeDistance * 9;\n            this.temperature = initialTemperature;\n\n            var guessBounds = this._expectedBounds();\n            this.width = guessBounds.width;\n            this.height = guessBounds.height;\n\n            for (var step = 0; step < this.options.iterations; step++) {\n                this.refineStage = step >= this.options.iterations * 5 / 6;\n                this.tick();\n                // exponential cooldown\n                this.temperature = this.refineStage ?\n                    initialTemperature / 30 :\n                    initialTemperature * (1 - step / (2 * this.options.iterations ));\n            }\n        },\n\n        /**\n         * Single iteration of the simulation.\n         */\n        tick: function() {\n            var i;\n            // collect the repulsive forces on each node\n            for (i = 0; i < this.graph.nodes.length; i++) {\n                this._repulsion(this.graph.nodes[i]);\n            }\n\n            // collect the attractive forces on each node\n            for (i = 0; i < this.graph.links.length; i++) {\n                this._attraction(this.graph.links[i]);\n            }\n            // update the positions\n            for (i = 0; i < this.graph.nodes.length; i++) {\n                var node = this.graph.nodes[i];\n                var offset = Math.sqrt(node.dx * node.dx + node.dy * node.dy);\n                if (offset === 0) {\n                    return;\n                }\n                node.x += Math.min(offset, this.temperature) * node.dx / offset;\n                node.y += Math.min(offset, this.temperature) * node.dy / offset;\n                if (this.options.limitToView) {\n                    node.x = Math.min(this.width, Math.max(node.width / 2, node.x));\n                    node.y = Math.min(this.height, Math.max(node.height / 2, node.y));\n                }\n            }\n        },\n\n        /**\n         * Shakes the node away from its current position to escape the deadlock.\n         * @param node A Node.\n         * @private\n         */\n        _shake: function(node) {\n            // just a simple polar neighborhood\n            var rho = Math.random() * this.options.nodeDistance / 4;\n            var alpha = Math.random() * 2 * Math.PI;\n            node.x += rho * Math.cos(alpha);\n            node.y -= rho * Math.sin(alpha);\n        },\n\n        /**\n         * The typical Coulomb-Newton force law F=k/r^2\n         * @remark This only works in dimensions less than three.\n         * @param d\n         * @param n A Node.\n         * @param m Another Node.\n         * @returns {number}\n         * @private\n         */\n        _InverseSquareForce: function(d, n, m) {\n            var force;\n            if (!this.refineStage) {\n                force = Math.pow(d, 2) / Math.pow(this.options.nodeDistance, 2);\n            }\n            else {\n                var deltax = n.x - m.x;\n                var deltay = n.y - m.y;\n\n                var wn = n.width / 2;\n                var hn = n.height / 2;\n                var wm = m.width / 2;\n                var hm = m.height / 2;\n\n                force = (Math.pow(deltax, 2) / Math.pow(wn + wm + this.options.nodeDistance, 2)) + (Math.pow(deltay, 2) / Math.pow(hn + hm + this.options.nodeDistance, 2));\n            }\n            return force * 4 / 3;\n        },\n\n        /**\n         * The typical Hooke force law F=kr^2\n         * @param d\n         * @param n\n         * @param m\n         * @returns {number}\n         * @private\n         */\n        _SquareForce: function(d, n, m) {\n            return 1 / this._InverseSquareForce(d, n, m);\n        },\n\n        _repulsion: function(n) {\n            n.dx = 0;\n            n.dy = 0;\n            Utils.forEach(this.graph.nodes, function(m) {\n                if (m === n) {\n                    return;\n                }\n                while (n.x === m.x && n.y === m.y) {\n                    this._shake(m);\n                }\n                var vx = n.x - m.x;\n                var vy = n.y - m.y;\n                var distance = Math.sqrt(vx * vx + vy * vy);\n                var r = this._SquareForce(distance, n, m) * 2;\n                n.dx += (vx / distance) * r;\n                n.dy += (vy / distance) * r;\n            }, this);\n        },\n        _attraction: function(link) {\n            var t = link.target;\n            var s = link.source;\n            if (s === t) {\n                // loops induce endless shakes\n                return;\n            }\n            while (s.x === t.x && s.y === t.y) {\n                this._shake(t);\n            }\n\n            var vx = s.x - t.x;\n            var vy = s.y - t.y;\n            var distance = Math.sqrt(vx * vx + vy * vy);\n\n            var a = this._InverseSquareForce(distance, s, t) * 5;\n            var dx = (vx / distance) * a;\n            var dy = (vy / distance) * a;\n            t.dx += dx;\n            t.dy += dy;\n            s.dx -= dx;\n            s.dy -= dy;\n        },\n\n        /**\n         * Calculates the expected bounds after layout.\n         * @returns {*}\n         * @private\n         */\n        _expectedBounds: function() {\n\n            var size, N = this.graph.nodes.length, /*golden ration optimal?*/ ratio = 1.5, multiplier = 4;\n            if (N === 0) {\n                return size;\n            }\n            size = Utils.fold(this.graph.nodes, function(s, node) {\n                var area = node.width * node.height;\n                if (area > 0) {\n                    s += Math.sqrt(area);\n                    return s;\n                }\n                return 0;\n            }, 0, this);\n            var av = size / N;\n            var squareSize = av * Math.ceil(Math.sqrt(N));\n            var width = squareSize * Math.sqrt(ratio);\n            var height = squareSize / Math.sqrt(ratio);\n            return { width: width * multiplier, height: height * multiplier };\n        }\n\n    });\n\n    var TreeLayoutProcessor = kendo.Class.extend({\n\n        init: function(options) {\n            this.center = null;\n            this.options = options;\n        },\n        layout: function(treeGraph, root) {\n            this.graph = treeGraph;\n            if (!this.graph.nodes || this.graph.nodes.length === 0) {\n                return;\n            }\n\n            if (!contains(this.graph.nodes, root)) {\n                throw \"The given root is not in the graph.\";\n            }\n\n            this.center = root;\n            this.graph.cacheRelationships();\n            /* var nonull = this.graph.nodes.where(function (n) {\n             return n.associatedShape != null;\n             });*/\n\n            // transfer the rects\n            /*nonull.forEach(function (n) {\n             n.Location = n.associatedShape.Position;\n             n.NodeSize = n.associatedShape.ActualBounds.ToSize();\n             }\n\n             );*/\n\n            // caching the children\n            /* nonull.forEach(function (n) {\n             n.children = n.getChildren();\n             });*/\n\n            this.layoutSwitch();\n\n            // apply the layout to the actual visuals\n            // nonull.ForEach(n => n.associatedShape.Position = n.Location);\n        },\n\n        layoutLeft: function(left) {\n            this.setChildrenDirection(this.center, \"Left\", false);\n            this.setChildrenLayout(this.center, \"Default\", false);\n            var h = 0, w = 0, y, i, node;\n            for (i = 0; i < left.length; i++) {\n                node = left[i];\n                node.TreeDirection = \"Left\";\n                var s = this.measure(node, Size.Empty);\n                w = Math.max(w, s.Width);\n                h += s.height + this.options.verticalSeparation;\n            }\n\n            h -= this.options.verticalSeparation;\n            var x = this.center.x - this.options.horizontalSeparation;\n            y = this.center.y + ((this.center.height - h) / 2);\n            for (i = 0; i < left.length; i++) {\n                node = left[i];\n                var p = new Point(x - node.Size.width, y);\n\n                this.arrange(node, p);\n                y += node.Size.height + this.options.verticalSeparation;\n            }\n        },\n\n        layoutRight: function(right) {\n            this.setChildrenDirection(this.center, \"Right\", false);\n            this.setChildrenLayout(this.center, \"Default\", false);\n            var h = 0, w = 0, y, i, node;\n            for (i = 0; i < right.length; i++) {\n                node = right[i];\n                node.TreeDirection = \"Right\";\n                var s = this.measure(node, Size.Empty);\n                w = Math.max(w, s.Width);\n                h += s.height + this.options.verticalSeparation;\n            }\n\n            h -= this.options.verticalSeparation;\n            var x = this.center.x + this.options.horizontalSeparation + this.center.width;\n            y = this.center.y + ((this.center.height - h) / 2);\n            for (i = 0; i < right.length; i++) {\n                node = right[i];\n                var p = new Point(x, y);\n                this.arrange(node, p);\n                y += node.Size.height + this.options.verticalSeparation;\n            }\n        },\n\n        layoutUp: function(up) {\n            this.setChildrenDirection(this.center, \"Up\", false);\n            this.setChildrenLayout(this.center, \"Default\", false);\n            var w = 0, y, node, i;\n            for (i = 0; i < up.length; i++) {\n                node = up[i];\n                node.TreeDirection = \"Up\";\n                var s = this.measure(node, Size.Empty);\n                w += s.width + this.options.horizontalSeparation;\n            }\n\n            w -= this.options.horizontalSeparation;\n            var x = this.center.x + (this.center.width / 2) - (w / 2);\n\n            // y = this.center.y -verticalSeparation -this.center.height/2 - h;\n            for (i = 0; i < up.length; i++) {\n                node = up[i];\n                y = this.center.y - this.options.verticalSeparation - node.Size.height;\n                var p = new Point(x, y);\n                this.arrange(node, p);\n                x += node.Size.width + this.options.horizontalSeparation;\n            }\n        },\n\n        layoutDown: function(down) {\n            var node, i;\n            this.setChildrenDirection(this.center, \"Down\", false);\n            this.setChildrenLayout(this.center, \"Default\", false);\n            var w = 0, y;\n            for (i = 0; i < down.length; i++) {\n                node = down[i];\n                node.treeDirection = \"Down\";\n                var s = this.measure(node, Size.Empty);\n                w += s.width + this.options.horizontalSeparation;\n            }\n\n            w -= this.options.horizontalSeparation;\n            var x = this.center.x + (this.center.width / 2) - (w / 2);\n            y = this.center.y + this.options.verticalSeparation + this.center.height;\n            for (i = 0; i < down.length; i++) {\n                node = down[i];\n                var p = new Point(x, y);\n                this.arrange(node, p);\n                x += node.Size.width + this.options.horizontalSeparation;\n            }\n        },\n\n        layoutRadialTree: function() {\n            // var rmax = children.Aggregate(0D, (current, node) => Math.max(node.SectorAngle, current));\n            this.setChildrenDirection(this.center, \"Radial\", false);\n            this.setChildrenLayout(this.center, \"Default\", false);\n            this.previousRoot = null;\n            var startAngle = this.options.startRadialAngle * DEG_TO_RAD;\n            var endAngle = this.options.endRadialAngle * DEG_TO_RAD;\n            if (endAngle <= startAngle) {\n                throw \"Final angle should not be less than the start angle.\";\n            }\n\n            this.maxDepth = 0;\n            this.origin = new Point(this.center.x, this.center.y);\n            this.calculateAngularWidth(this.center, 0);\n\n            // perform the layout\n            if (this.maxDepth > 0) {\n                this.radialLayout(this.center, this.options.radialFirstLevelSeparation, startAngle, endAngle);\n            }\n\n            // update properties of the root node\n            this.center.Angle = endAngle - startAngle;\n        },\n\n        tipOverTree: function(down, startFromLevel) {\n            if (Utils.isUndefined(startFromLevel)) {\n                startFromLevel = 0;\n            }\n\n            this.setChildrenDirection(this.center, \"Down\", false);\n            this.setChildrenLayout(this.center, \"Default\", false);\n            this.setChildrenLayout(this.center, \"Underneath\", false, startFromLevel);\n            var w = 0, y, node, i;\n            for (i = 0; i < down.length; i++) {\n                node = down[i];\n\n                // if (node.IsSpecial) continue;\n                node.TreeDirection = \"Down\";\n                var s = this.measure(node, Size.Empty);\n                w += s.width + this.options.horizontalSeparation;\n            }\n\n            w -= this.options.horizontalSeparation;\n\n            // putting the root in the center with respect to the whole diagram is not a nice result, let's put it with respect to the first level only\n            w -= down[down.length - 1].width;\n            w += down[down.length - 1].associatedShape.bounds().width;\n\n            var x = this.center.x + (this.center.width / 2) - (w / 2);\n            y = this.center.y + this.options.verticalSeparation + this.center.height;\n            for (i = 0; i < down.length; i++) {\n                node = down[i];\n                // if (node.IsSpecial) continue;\n                var p = new Point(x, y);\n                this.arrange(node, p);\n                x += node.Size.width + this.options.horizontalSeparation;\n            }\n\n            /*//let's place the special node, assuming there is only one\n             if (down.Count(n => n.IsSpecial) > 0)\n             {\n             var special = (from n in down where n.IsSpecial select n).First();\n             if (special.Children.Count > 0)\n             throw new DiagramException(\"The 'special' element should not have children.\");\n             special.Data.Location = new Point(Center.Data.Location.X + Center.AssociatedShape.BoundingRectangle.Width + this.options.HorizontalSeparation, Center.Data.Location.Y);\n             }*/\n        },\n        calculateAngularWidth: function(n, d) {\n            if (d > this.maxDepth) {\n                this.maxDepth = d;\n            }\n\n            var aw = 0, w = 1000, h = 1000, diameter = d === 0 ? 0 : Math.sqrt((w * w) + (h * h)) / d;\n\n            if (n.children.length > 0) {\n                // eventually with n.IsExpanded\n                for (var i = 0, len = n.children.length; i < len; i++) {\n                    var child = n.children[i];\n                    aw += this.calculateAngularWidth(child, d + 1);\n                }\n                aw = Math.max(diameter, aw);\n            }\n            else {\n                aw = diameter;\n            }\n\n            n.sectorAngle = aw;\n            return aw;\n        },\n        sortChildren: function(n) {\n            var basevalue = 0, i;\n\n            // update basevalue angle for node ordering\n            if (n.parents.length > 1) {\n                throw \"Node is not part of a tree.\";\n            }\n            var p = n.parents[0];\n            if (p) {\n                var pl = new Point(p.x, p.y);\n                var nl = new Point(n.x, n.y);\n                basevalue = this.normalizeAngle(Math.atan2(pl.y - nl.y, pl.x - nl.x));\n            }\n\n            var count = n.children.length;\n            if (count === 0) {\n                return null;\n            }\n\n            var angle = [];\n            var idx = [];\n\n            for (i = 0; i < count; ++i) {\n                var c = n.children[i];\n                var l = new Point(c.x, c.y);\n                idx[i] = i;\n                angle[i] = this.normalizeAngle(-basevalue + Math.atan2(l.y - l.y, l.x - l.x));\n            }\n\n            Utils.bisort(angle, idx);\n            var col = []; // list of nodes\n            var children = n.children;\n            for (i = 0; i < count; ++i) {\n                col.push(children[idx[i]]);\n            }\n\n            return col;\n        },\n\n        normalizeAngle: function(angle) {\n            while (angle > Math.PI * 2) {\n                angle -= 2 * Math.PI;\n            }\n            while (angle < 0) {\n                angle += Math.PI * 2;\n            }\n            return angle;\n        },\n        radialLayout: function(node, radius, startAngle, endAngle) {\n            var deltaTheta = endAngle - startAngle;\n            var deltaThetaHalf = deltaTheta / 2.0;\n            var parentSector = node.sectorAngle;\n            var fraction = 0;\n            var sorted = this.sortChildren(node);\n            for (var i = 0, len = sorted.length; i < len; i++) {\n                var childNode = sorted[i];\n                var cp = childNode;\n                var childAngleFraction = cp.sectorAngle / parentSector;\n                if (childNode.children.length > 0) {\n                    this.radialLayout(childNode,\n                        radius + this.options.radialSeparation,\n                        startAngle + (fraction * deltaTheta),\n                        startAngle + ((fraction + childAngleFraction) * deltaTheta));\n                }\n\n                this.setPolarLocation(childNode, radius, startAngle + (fraction * deltaTheta) + (childAngleFraction * deltaThetaHalf));\n                cp.angle = childAngleFraction * deltaTheta;\n                fraction += childAngleFraction;\n            }\n        },\n        setPolarLocation: function(node, radius, angle) {\n            node.x = this.origin.x + (radius * Math.cos(angle));\n            node.y = this.origin.y + (radius * Math.sin(angle));\n            node.BoundingRectangle = new Rect(node.x, node.y, node.width, node.height);\n        },\n\n        /**\n         * Sets the children direction recursively.\n         * @param node\n         * @param direction\n         * @param includeStart\n         */\n        setChildrenDirection: function(node, direction, includeStart) {\n            var rootDirection = node.treeDirection;\n            this.graph.depthFirstTraversal(node, function(n) {\n                n.treeDirection = direction;\n            });\n            if (!includeStart) {\n                node.treeDirection = rootDirection;\n            }\n        },\n\n        /**\n         * Sets the children layout recursively.\n         * @param node\n         * @param layout\n         * @param includeStart\n         * @param startFromLevel\n         */\n        setChildrenLayout: function(node, layout, includeStart, startFromLevel) {\n            if (Utils.isUndefined(startFromLevel)) {\n                startFromLevel = 0;\n            }\n            var rootLayout = node.childrenLayout;\n            if (startFromLevel > 0) {\n                // assign levels to the Node.Level property\n                this.graph.assignLevels(node);\n\n                // assign the layout on the condition that the level is at least the 'startFromLevel'\n                this.graph.depthFirstTraversal(\n                    node, function(s) {\n                        if (s.level >= startFromLevel + 1) {\n                            s.childrenLayout = layout;\n                        }\n                    }\n                );\n            }\n            else {\n                this.graph.depthFirstTraversal(node, function(s) {\n                    s.childrenLayout = layout;\n                });\n\n                // if the start should not be affected we put the state back\n                if (!includeStart) {\n                    node.childrenLayout = rootLayout;\n                }\n            }\n        },\n\n        /**\n         * Returns the actual size of the node. The given size is the allowed space wherein the node can lay out itself.\n         * @param node\n         * @param givenSize\n         * @returns {Size}\n         */\n        measure: function(node, givenSize) {\n            var w = 0, h = 0, s;\n            var result = new Size(0, 0);\n            if (!node) {\n                throw \"\";\n            }\n            var b = node.associatedShape.bounds();\n            var shapeWidth = b.width;\n            var shapeHeight = b.height;\n            if (node.parents.length !== 1) {\n                throw \"Node not in a spanning tree.\";\n            }\n\n            var parent = node.parents[0];\n            if (node.treeDirection === \"Undefined\") {\n                node.treeDirection = parent.treeDirection;\n            }\n\n            if (Utils.isEmpty(node.children)) {\n                result = new Size(\n                    Math.abs(shapeWidth) < EPSILON ? 50 : shapeWidth,\n                    Math.abs(shapeHeight) < EPSILON ? 25 : shapeHeight);\n            }\n            else if (node.children.length === 1) {\n                switch (node.treeDirection) {\n                    case \"Radial\":\n                        s = this.measure(node.children[0], givenSize); // child size\n                        w = shapeWidth + (this.options.radialSeparation * Math.cos(node.AngleToParent)) + s.width;\n                        h = shapeHeight + Math.abs(this.options.radialSeparation * Math.sin(node.AngleToParent)) + s.height;\n                        break;\n                    case \"Left\":\n                    case \"Right\":\n                        switch (node.childrenLayout) {\n\n                            case \"TopAlignedWithParent\":\n                                break;\n\n                            case \"BottomAlignedWithParent\":\n                                break;\n\n                            case \"Underneath\":\n                                s = this.measure(node.children[0], givenSize);\n                                w = shapeWidth + s.width + this.options.underneathHorizontalOffset;\n                                h = shapeHeight + this.options.underneathVerticalTopOffset + s.height;\n                                break;\n\n                            case \"Default\":\n                                s = this.measure(node.children[0], givenSize);\n                                w = shapeWidth + this.options.horizontalSeparation + s.width;\n                                h = Math.max(shapeHeight, s.height);\n                                break;\n\n                            default:\n                                throw \"Unhandled TreeDirection in the Radial layout measuring.\";\n                        }\n                        break;\n                    case \"Up\":\n                    case \"Down\":\n                        switch (node.childrenLayout) {\n\n                            case \"TopAlignedWithParent\":\n                            case \"BottomAlignedWithParent\":\n                                break;\n\n                            case \"Underneath\":\n                                s = this.measure(node.children[0], givenSize);\n                                w = Math.max(shapeWidth, s.width + this.options.underneathHorizontalOffset);\n                                h = shapeHeight + this.options.underneathVerticalTopOffset + s.height;\n                                break;\n\n                            case \"Default\":\n                                s = this.measure(node.children[0], givenSize);\n                                h = shapeHeight + this.options.verticalSeparation + s.height;\n                                w = Math.max(shapeWidth, s.width);\n                                break;\n\n                            default:\n                                throw \"Unhandled TreeDirection in the Down layout measuring.\";\n                        }\n                        break;\n                    default:\n                        throw \"Unhandled TreeDirection in the layout measuring.\";\n                }\n\n                result = new Size(w, h);\n            }\n            else {\n                var i, childNode;\n                switch (node.treeDirection) {\n                    case \"Left\":\n                    case \"Right\":\n                        switch (node.childrenLayout) {\n\n                            case \"TopAlignedWithParent\":\n                            case \"BottomAlignedWithParent\":\n                                break;\n\n                            case \"Underneath\":\n                                w = shapeWidth;\n                                h = shapeHeight + this.options.underneathVerticalTopOffset;\n                                for (i = 0; i < node.children.length; i++) {\n                                    childNode = node.children[i];\n                                    s = this.measure(childNode, givenSize);\n                                    w = Math.max(w, s.width + this.options.underneathHorizontalOffset);\n                                    h += s.height + this.options.underneathVerticalSeparation;\n                                }\n\n                                h -= this.options.underneathVerticalSeparation;\n                                break;\n\n                            case \"Default\":\n                                w = shapeWidth;\n                                h = 0;\n                                for (i = 0; i < node.children.length; i++) {\n                                    childNode = node.children[i];\n                                    s = this.measure(childNode, givenSize);\n                                    w = Math.max(w, shapeWidth + this.options.horizontalSeparation + s.width);\n                                    h += s.height + this.options.verticalSeparation;\n                                }\n                                h -= this.options.verticalSeparation;\n                                break;\n\n                            default:\n                                throw \"Unhandled TreeDirection in the Right layout measuring.\";\n                        }\n\n                        break;\n                    case \"Up\":\n                    case \"Down\":\n\n                        switch (node.childrenLayout) {\n\n                            case \"TopAlignedWithParent\":\n                            case \"BottomAlignedWithParent\":\n                                break;\n\n                            case \"Underneath\":\n                                w = shapeWidth;\n                                h = shapeHeight + this.options.underneathVerticalTopOffset;\n                                for (i = 0; i < node.children.length; i++) {\n                                    childNode = node.children[i];\n                                    s = this.measure(childNode, givenSize);\n                                    w = Math.max(w, s.width + this.options.underneathHorizontalOffset);\n                                    h += s.height + this.options.underneathVerticalSeparation;\n                                }\n\n                                h -= this.options.underneathVerticalSeparation;\n                                break;\n\n                            case \"Default\":\n                                w = 0;\n                                h = 0;\n                                for (i = 0; i < node.children.length; i++) {\n                                    childNode = node.children[i];\n                                    s = this.measure(childNode, givenSize);\n                                    w += s.width + this.options.horizontalSeparation;\n                                    h = Math.max(h, s.height + this.options.verticalSeparation + shapeHeight);\n                                }\n\n                                w -= this.options.horizontalSeparation;\n                                break;\n\n                            default:\n                                throw \"Unhandled TreeDirection in the Down layout measuring.\";\n                        }\n\n                        break;\n                    default:\n                        throw \"Unhandled TreeDirection in the layout measuring.\";\n                }\n\n                result = new Size(w, h);\n            }\n\n            node.SectorAngle = Math.sqrt((w * w / 4) + (h * h / 4));\n            node.Size = result;\n            return result;\n        },\n        arrange: function(n, p) {\n            var i, pp, child, node, childrenwidth, b = n.associatedShape.bounds();\n            var shapeWidth = b.width;\n            var shapeHeight = b.height;\n            if (Utils.isEmpty(n.children)) {\n                n.x = p.x;\n                n.y = p.y;\n                n.BoundingRectangle = new Rect(p.x, p.y, shapeWidth, shapeHeight);\n            }\n            else {\n                var x, y;\n                var selfLocation;\n                switch (n.treeDirection) {\n                    case \"Left\":\n                        switch (n.childrenLayout) {\n                            case \"TopAlignedWithParent\":\n                            case \"BottomAlignedWithParent\":\n                                break;\n\n                            case \"Underneath\":\n                                selfLocation = p;\n                                n.x = selfLocation.x;\n                                n.y = selfLocation.y;\n                                n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                                y = p.y + shapeHeight + this.options.underneathVerticalTopOffset;\n                                for (i = 0; i < node.children.length; i++) {\n                                    node = node.children[i];\n                                    x = selfLocation.x - node.associatedShape.width - this.options.underneathHorizontalOffset;\n                                    pp = new Point(x, y);\n                                    this.arrange(node, pp);\n                                    y += node.Size.height + this.options.underneathVerticalSeparation;\n                                }\n                                break;\n\n                            case \"Default\":\n                                selfLocation = new Point(p.x + n.Size.width - shapeWidth, p.y + ((n.Size.height - shapeHeight) / 2));\n                                n.x = selfLocation.x;\n                                n.y = selfLocation.y;\n                                n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                                x = selfLocation.x - this.options.horizontalSeparation; // alignment of children\n                                y = p.y;\n                                for (i = 0; i < n.children.length; i++) {\n                                    node = n.children[i];\n                                    pp = new Point(x - node.Size.width, y);\n                                    this.arrange(node, pp);\n                                    y += node.Size.height + this.options.verticalSeparation;\n                                }\n                                break;\n\n                            default:\n                                throw \"Unsupported TreeDirection\";\n                        }\n\n                        break;\n                    case \"Right\":\n                        switch (n.childrenLayout) {\n                            case \"TopAlignedWithParent\":\n                            case \"BottomAlignedWithParent\":\n                                break;\n\n                            case \"Underneath\":\n                                selfLocation = p;\n                                n.x = selfLocation.x;\n                                n.y = selfLocation.y;\n                                n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                                x = p.x + shapeWidth + this.options.underneathHorizontalOffset;\n\n                                // alignment of children left-underneath the parent\n                                y = p.y + shapeHeight + this.options.underneathVerticalTopOffset;\n                                for (i = 0; i < n.children.length; i++) {\n                                    node = n.children[i];\n                                    pp = new Point(x, y);\n                                    this.arrange(node, pp);\n                                    y += node.Size.height + this.options.underneathVerticalSeparation;\n                                }\n\n                                break;\n\n                            case \"Default\":\n                                selfLocation = new Point(p.x, p.y + ((n.Size.height - shapeHeight) / 2));\n                                n.x = selfLocation.x;\n                                n.y = selfLocation.y;\n                                n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                                x = p.x + shapeWidth + this.options.horizontalSeparation; // alignment of children\n                                y = p.y;\n                                for (i = 0; i < n.children.length; i++) {\n                                    node = n.children[i];\n                                    pp = new Point(x, y);\n                                    this.arrange(node, pp);\n                                    y += node.Size.height + this.options.verticalSeparation;\n                                }\n                                break;\n\n                            default:\n                                throw \"Unsupported TreeDirection\";\n                        }\n\n                        break;\n                    case \"Up\":\n                        selfLocation = new Point(p.x + ((n.Size.width - shapeWidth) / 2), p.y + n.Size.height - shapeHeight);\n                        n.x = selfLocation.x;\n                        n.y = selfLocation.y;\n                        n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                        if (Math.abs(selfLocation.x - p.x) < EPSILON) {\n                            childrenwidth = 0;\n                            // means there is an aberration due to the oversized Element with respect to the children\n                            for (i = 0; i < n.children.length; i++) {\n                                child = n.children[i];\n                                childrenwidth += child.Size.width + this.options.horizontalSeparation;\n                            }\n                            childrenwidth -= this.options.horizontalSeparation;\n                            x = p.x + ((shapeWidth - childrenwidth) / 2);\n                        }\n                        else {\n                            x = p.x;\n                        }\n\n                        for (i = 0; i < n.children.length; i++) {\n                            node = n.children[i];\n                            y = selfLocation.y - this.options.verticalSeparation - node.Size.height;\n                            pp = new Point(x, y);\n                            this.arrange(node, pp);\n                            x += node.Size.width + this.options.horizontalSeparation;\n                        }\n                        break;\n\n                    case \"Down\":\n\n                        switch (n.childrenLayout) {\n                            case \"TopAlignedWithParent\":\n                            case \"BottomAlignedWithParent\":\n                                break;\n                            case \"Underneath\":\n                                selfLocation = p;\n                                n.x = selfLocation.x;\n                                n.y = selfLocation.y;\n                                n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                                x = p.x + this.options.underneathHorizontalOffset; // alignment of children left-underneath the parent\n                                y = p.y + shapeHeight + this.options.underneathVerticalTopOffset;\n                                for (i = 0; i < n.children.length; i++) {\n                                    node = n.children[i];\n                                    pp = new Point(x, y);\n                                    this.arrange(node, pp);\n                                    y += node.Size.height + this.options.underneathVerticalSeparation;\n                                }\n                                break;\n\n                            case \"Default\":\n                                selfLocation = new Point(p.x + ((n.Size.width - shapeWidth) / 2), p.y);\n                                n.x = selfLocation.x;\n                                n.y = selfLocation.y;\n                                n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                                if (Math.abs(selfLocation.x - p.x) < EPSILON) {\n                                    childrenwidth = 0;\n                                    // means there is an aberration due to the oversized Element with respect to the children\n                                    for (i = 0; i < n.children.length; i++) {\n                                        child = n.children[i];\n                                        childrenwidth += child.Size.width + this.options.horizontalSeparation;\n                                    }\n\n                                    childrenwidth -= this.options.horizontalSeparation;\n                                    x = p.x + ((shapeWidth - childrenwidth) / 2);\n                                }\n                                else {\n                                    x = p.x;\n                                }\n\n                                for (i = 0; i < n.children.length; i++) {\n                                    node = n.children[i];\n                                    y = selfLocation.y + this.options.verticalSeparation + shapeHeight;\n                                    pp = new Point(x, y);\n                                    this.arrange(node, pp);\n                                    x += node.Size.width + this.options.horizontalSeparation;\n                                }\n                                break;\n\n                            default:\n                                throw \"Unsupported TreeDirection\";\n                        }\n                        break;\n\n                    case \"None\":\n                        break;\n\n                    default:\n                        throw \"Unsupported TreeDirection\";\n                }\n            }\n        },\n        layoutSwitch: function() {\n            if (!this.center) {\n                return;\n            }\n\n            if (Utils.isEmpty(this.center.children)) {\n                return;\n            }\n\n            var type = this.options.subtype;\n            if (Utils.isUndefined(type)) {\n                type = \"Down\";\n            }\n            var single, male, female, leftcount;\n            var children = this.center.children;\n            switch (type.toLowerCase()) {\n                case \"radial\":\n                case \"radialtree\":\n                    this.layoutRadialTree();\n                    break;\n\n                case \"mindmaphorizontal\":\n                case \"mindmap\":\n                    single = this.center.children;\n\n                    if (this.center.children.length === 1) {\n                        this.layoutRight(single);\n                    }\n                    else {\n                        // odd number will give one more at the right\n                        leftcount = children.length / 2;\n                        male = grep(this.center.children, function(n) {\n                            return Utils.indexOf(children, n) < leftcount;\n                        });\n                        female = grep(this.center.children, function(n) {\n                            return Utils.indexOf(children, n) >= leftcount;\n                        });\n\n                        this.layoutLeft(male);\n                        this.layoutRight(female);\n                    }\n                    break;\n\n                case \"mindmapvertical\":\n                    single = this.center.children;\n\n                    if (this.center.children.length === 1) {\n                        this.layoutDown(single);\n                    }\n                    else {\n                        // odd number will give one more at the right\n                        leftcount = children.length / 2;\n                        male = grep(this.center.children, function(n) {\n                            return Utils.indexOf(children, n) < leftcount;\n                        });\n                        female = grep(this.center.children, function(n) {\n                            return Utils.indexOf(children, n) >= leftcount;\n                        });\n                        this.layoutUp(male);\n                        this.layoutDown(female);\n                    }\n                    break;\n\n                case \"right\":\n                    this.layoutRight(this.center.children);\n                    break;\n\n                case \"left\":\n                    this.layoutLeft(this.center.children);\n                    break;\n\n                case \"up\":\n                case \"bottom\":\n                    this.layoutUp(this.center.children);\n                    break;\n\n                case \"down\":\n                case \"top\":\n                    this.layoutDown(this.center.children);\n                    break;\n\n                case \"tipover\":\n                case \"tipovertree\":\n                    if (this.options.tipOverTreeStartLevel < 0) {\n                        throw \"The tip-over level should be a positive integer.\";\n                    }\n                    this.tipOverTree(this.center.children, this.options.tipOverTreeStartLevel);\n                    break;\n\n                case \"undefined\":\n                case \"none\":\n                    break;\n            }\n        }\n    });\n\n    /**\n     * The various tree layout algorithms.\n     * @type {*}\n     */\n    var TreeLayout = LayoutBase.extend({\n        init: function(diagram) {\n            var that = this;\n            LayoutBase.fn.init.call(that);\n            if (Utils.isUndefined(diagram)) {\n                throw \"No diagram specified.\";\n            }\n            this.diagram = diagram;\n        },\n\n        /**\n         * Arranges the diagram in a tree-layout with the specified options and tree subtype.\n         */\n        layout: function(options) {\n\n            this.transferOptions(options);\n\n            // transform the diagram into a Graph\n            var adapter = new DiagramToHyperTreeAdapter(this.diagram);\n\n            /**\n             * The Graph reduction from the given diagram.\n             * @type {*}\n             */\n            this.graph = adapter.convert();\n\n            var finalNodeSet = this.layoutComponents();\n\n            // note that the graph contains the original data and\n            // the components are another instance of nodes referring to the same set of shapes\n            return new diagram.LayoutState(this.diagram, finalNodeSet);\n        },\n\n        layoutComponents: function() {\n            if (this.graph.isEmpty()) {\n                return;\n            }\n\n            // split into connected components\n            var components = this.graph.getConnectedComponents();\n            if (Utils.isEmpty(components)) {\n                return;\n            }\n\n            var layout = new TreeLayoutProcessor(this.options);\n            var trees = [];\n            // find a spanning tree for each component\n            for (var i = 0; i < components.length; i++) {\n                var component = components[i];\n\n                var treeGraph = this.getTree(component);\n                if (!treeGraph) {\n                    throw \"Failed to find a spanning tree for the component.\";\n                }\n                var root = treeGraph.root;\n                var tree = treeGraph.tree;\n                layout.layout(tree, root);\n\n                trees.push(tree);\n            }\n\n            return this.gridLayoutComponents(trees);\n\n        },\n\n        /**\n         * Gets a spanning tree (and root) for the given graph.\n         * Ensure that the given graph is connected!\n         * @param graph\n         * @returns {*} A literal object consisting of the found root and the spanning tree.\n         */\n        getTree: function(graph) {\n            var root = null;\n            if (this.options.roots && this.options.roots.length > 0) {\n                for (var i = 0, len = graph.nodes.length; i < len; i++) {\n                    var node = graph.nodes[i];\n                    for (var j = 0; j < this.options.roots.length; j++) {\n                        var givenRootShape = this.options.roots[j];\n                        if (givenRootShape === node.associatedShape) {\n                            root = node;\n                            break;\n                        }\n                    }\n                }\n            }\n            if (!root) {\n                // finds the most probable root on the basis of the longest path in the component\n                root = graph.root();\n                // should not happen really\n                if (!root) {\n                    throw \"Unable to find a root for the tree.\";\n                }\n            }\n            return this.getTreeForRoot(graph, root);\n        },\n\n        getTreeForRoot: function(graph, root) {\n\n            var tree = graph.getSpanningTree(root);\n            if (Utils.isUndefined(tree) || tree.isEmpty()) {\n                return null;\n            }\n            return {\n                tree: tree,\n                root: tree.root\n            };\n        }\n\n    });\n\n    /**\n     * The Sugiyama aka layered layout algorithm.\n     * @type {*}\n     */\n    var LayeredLayout = LayoutBase.extend({\n        init: function(diagram) {\n            var that = this;\n            LayoutBase.fn.init.call(that);\n            if (Utils.isUndefined(diagram)) {\n                throw \"Diagram is not specified.\";\n            }\n            this.diagram = diagram;\n        },\n\n        layout: function(options) {\n\n            this.transferOptions(options);\n\n            var adapter = new DiagramToHyperTreeAdapter(this.diagram);\n            var graph = adapter.convert(options);\n            if (graph.isEmpty()) {\n                return;\n            }\n            // split into connected components\n            var components = graph.getConnectedComponents();\n            if (Utils.isEmpty(components)) {\n                return;\n            }\n            for (var i = 0; i < components.length; i++) {\n                var component = components[i];\n                this.layoutGraph(component, options);\n            }\n            var finalNodeSet = this.gridLayoutComponents(components);\n            return new diagram.LayoutState(this.diagram, finalNodeSet);\n\n        },\n\n        /**\n         * Initializes the runtime data properties of the layout.\n         * @private\n         */\n        _initRuntimeProperties: function() {\n            for (var k = 0; k < this.graph.nodes.length; k++) {\n                var node = this.graph.nodes[k];\n                node.layer = -1;\n                node.downstreamLinkCount = 0;\n                node.upstreamLinkCount = 0;\n\n                node.isVirtual = false;\n\n                node.uBaryCenter = 0.0;\n                node.dBaryCenter = 0.0;\n\n                node.upstreamPriority = 0;\n                node.downstreamPriority = 0;\n\n                node.gridPosition = 0;\n            }\n        },\n        _prepare: function(graph) {\n            var current = [], i, l, link;\n\n            // defines a mapping of a node to the layer index\n            var layerMap = new Dictionary();\n            var layerCount = 0;\n            var targetLayer, next, target;\n\n            Utils.forEach(graph.nodes, function(node) {\n                if (node.incoming.length === 0) {\n                    layerMap.set(node, 0);\n                    current.push(node);\n                }\n            });\n\n            while (current.length > 0) {\n                next = current.shift();\n                for (i = 0; i < next.outgoing.length; i++) {\n                    link = next.outgoing[i];\n                    target = link.target;\n\n                    if (layerMap.containsKey(target)) {\n                        targetLayer = Math.max(layerMap.get(next) + 1, layerMap.get(target));\n                    } else {\n                        targetLayer = layerMap.get(next) + 1;\n                    }\n                    layerMap.set(target, targetLayer);\n                    if (targetLayer > layerCount) {\n                        layerCount = targetLayer;\n                    }\n\n                    if (!contains(current, target)) {\n                        current.push(target);\n                    }\n                }\n            }\n\n            var sortedNodes = layerMap.keys();\n\n            sortedNodes.sort(function(o1, o2) {\n                var o1layer = layerMap.get(o1);\n                var o2layer = layerMap.get(o2);\n                return Utils.sign(o2layer - o1layer);\n            });\n\n            for (var n = 0; n < sortedNodes.length; ++n) {\n                var node = sortedNodes[n];\n                var minLayer = Number.MAX_VALUE;\n\n                if (node.outgoing.length === 0) {\n                    continue;\n                }\n\n                for (l = 0; l < node.outgoing.length; ++l) {\n                    link = node.outgoing[l];\n                    minLayer = Math.min(minLayer, layerMap.get(link.target));\n                }\n\n                if (minLayer > 1) {\n                    layerMap.set(node, minLayer - 1);\n                }\n            }\n\n            this.layers = [];\n            var layer;\n            for (i = 0; i < layerCount + 1; i++) {\n                layer = [];\n                layer.linksTo = {};\n                this.layers.push(layer);\n            }\n\n            layerMap.forEach(function(node, layer) {\n                node.layer = layer;\n                this.layers[layer].push(node);\n            }, this);\n\n            // set initial grid positions\n            for (l = 0; l < this.layers.length; l++) {\n                layer = this.layers[l];\n                for (i = 0; i < layer.length; i++) {\n                    layer[i].gridPosition = i;\n                }\n            }\n        },\n        /**\n         * Performs the layout of a single component.\n         */\n        layoutGraph: function(graph, options) {\n            if (Utils.isUndefined(graph)) {\n                throw \"No graph given or graph analysis of the diagram failed.\";\n            }\n            if (Utils.isDefined(options)) {\n                this.transferOptions(options);\n            }\n            this.graph = graph;\n\n            // sets unique indices on the nodes\n            graph.setItemIndices();\n\n            // ensures no cycles present for this layout\n            var reversedEdges = graph.makeAcyclic();\n\n            // define the runtime props being used by the layout algorithm\n            this._initRuntimeProperties();\n\n            this._prepare(graph, options);\n\n            this._dummify();\n\n            this._optimizeCrossings();\n\n            this._swapPairs();\n\n            this.arrangeNodes();\n\n            this._moveThingsAround();\n\n            this._dedummify();\n\n            // re-reverse the links which were switched earlier\n            Utils.forEach(reversedEdges, function(e) {\n                if (e.points) {\n                    e.points.reverse();\n                }\n            });\n        },\n\n        setMinDist: function(m, n, minDist) {\n            var l = m.layer;\n            var i = m.layerIndex;\n            this.minDistances[l][i] = minDist;\n        },\n\n        getMinDist: function(m, n) {\n            var dist = 0,\n                i1 = m.layerIndex,\n                i2 = n.layerIndex,\n                l = m.layer,\n                min = Math.min(i1, i2),\n                max = Math.max(i1, i2);\n            // use Sum()?\n            for (var k = min; k < max; ++k) {\n                dist += this.minDistances[l][k];\n            }\n            return dist;\n        },\n\n        placeLeftToRight: function(leftClasses) {\n            var leftPos = new Dictionary(), n, node;\n            for (var c = 0; c < this.layers.length; ++c) {\n                var classNodes = leftClasses[c];\n                if (!classNodes) {\n                    continue;\n                }\n\n                for (n = 0; n < classNodes.length; n++) {\n                    node = classNodes[n];\n                    if (!leftPos.containsKey(node)) {\n                        this.placeLeft(node, leftPos, c);\n                    }\n                }\n\n                // adjust class\n                var d = Number.POSITIVE_INFINITY;\n                for (n = 0; n < classNodes.length; n++) {\n                    node = classNodes[n];\n                    var rightSibling = this.rightSibling(node);\n                    if (rightSibling && this.nodeLeftClass.get(rightSibling) !== c) {\n                        d = Math.min(d, leftPos.get(rightSibling) - leftPos.get(node) - this.getMinDist(node, rightSibling));\n                    }\n                }\n                if (d === Number.POSITIVE_INFINITY) {\n                    var D = [];\n                    for (n = 0; n < classNodes.length; n++) {\n                        node = classNodes[n];\n                        var neighbors = [];\n                        Utils.addRange(neighbors, this.upNodes.get(node));\n                        Utils.addRange(neighbors, this.downNodes.get(node));\n\n                        for (var e = 0; e < neighbors.length; e++) {\n                            var neighbor = neighbors[e];\n                            if (this.nodeLeftClass.get(neighbor) < c) {\n                                D.push(leftPos.get(neighbor) - leftPos.get(node));\n                            }\n                        }\n                    }\n                    D.sort();\n                    if (D.length === 0) {\n                        d = 0;\n                    }\n                    else if (D.length % 2 === 1) {\n                        d = D[this.intDiv(D.length, 2)];\n                    }\n                    else {\n                        d = (D[this.intDiv(D.length, 2) - 1] + D[this.intDiv(D.length, 2)]) / 2;\n                    }\n                }\n                for (n = 0; n < classNodes.length; n++) {\n                    node = classNodes[n];\n                    leftPos.set(node, leftPos.get(node) + d);\n                }\n            }\n            return leftPos;\n        },\n\n        placeRightToLeft: function(rightClasses) {\n            var rightPos = new Dictionary(), n, node;\n            for (var c = 0; c < this.layers.length; ++c) {\n                var classNodes = rightClasses[c];\n                if (!classNodes) {\n                    continue;\n                }\n\n                for (n = 0; n < classNodes.length; n++) {\n                    node = classNodes[n];\n                    if (!rightPos.containsKey(node)) {\n                        this.placeRight(node, rightPos, c);\n                    }\n                }\n\n                // adjust class\n                var d = Number.NEGATIVE_INFINITY;\n                for (n = 0; n < classNodes.length; n++) {\n                    node = classNodes[n];\n                    var leftSibling = this.leftSibling(node);\n                    if (leftSibling && this.nodeRightClass.get(leftSibling) !== c) {\n                        d = Math.max(d, rightPos.get(leftSibling) - rightPos.get(node) + this.getMinDist(leftSibling, node));\n                    }\n                }\n                if (d === Number.NEGATIVE_INFINITY) {\n                    var D = [];\n                    for (n = 0; n < classNodes.length; n++) {\n                        node = classNodes[n];\n                        var neighbors = [];\n                        Utils.addRange(neighbors, this.upNodes.get(node));\n                        Utils.addRange(neighbors, this.downNodes.get(node));\n\n                        for (var e = 0; e < neighbors.length; e++) {\n                            var neighbor = neighbors[e];\n                            if (this.nodeRightClass.get(neighbor) < c) {\n                                D.push(rightPos.get(node) - rightPos.get(neighbor));\n                            }\n                        }\n                    }\n                    D.sort();\n                    if (D.length === 0) {\n                        d = 0;\n                    }\n                    else if (D.length % 2 === 1) {\n                        d = D[this.intDiv(D.length, 2)];\n                    }\n                    else {\n                        d = (D[this.intDiv(D.length, 2) - 1] + D[this.intDiv(D.length, 2)]) / 2;\n                    }\n                }\n                for (n = 0; n < classNodes.length; n++) {\n                    node = classNodes[n];\n                    rightPos.set(node, rightPos.get(node) + d);\n                }\n            }\n            return rightPos;\n        },\n\n        _getLeftWing: function() {\n            var leftWing = { value: null };\n            var result = this.computeClasses(leftWing, 1);\n            this.nodeLeftClass = leftWing.value;\n            return result;\n        },\n\n        _getRightWing: function() {\n            var rightWing = { value: null };\n            var result = this.computeClasses(rightWing, -1);\n            this.nodeRightClass = rightWing.value;\n            return result;\n        },\n\n        computeClasses: function(wingPair, d) {\n            var currentWing = 0,\n                wing = wingPair.value = new Dictionary();\n\n            for (var l = 0; l < this.layers.length; ++l) {\n                currentWing = l;\n\n                var layer = this.layers[l];\n                for (var n = d === 1 ? 0 : layer.length - 1; n >= 0 && n < layer.length; n += d) {\n                    var node = layer[n];\n                    if (!wing.containsKey(node)) {\n                        wing.set(node, currentWing);\n                        if (node.isVirtual) {\n                            var ndsinl = this._nodesInLink(node);\n                            for (var kk = 0; kk < ndsinl.length; kk++) {\n                                var vnode = ndsinl[kk];\n                                wing.set(vnode, currentWing);\n                            }\n                        }\n                    }\n                    else {\n                        currentWing = wing.get(node);\n                    }\n                }\n            }\n\n            var wings = [];\n            for (var i = 0; i < this.layers.length; i++) {\n                wings.push(null);\n            }\n            wing.forEach(function(node, classIndex) {\n                if (wings[classIndex] === null) {\n                    wings[classIndex] = [];\n                }\n                wings[classIndex].push(node);\n            });\n\n            return wings;\n        },\n        _isVerticalLayout: function() {\n            return this.options.subtype.toLowerCase() === \"up\" || this.options.subtype.toLowerCase() === \"down\" || this.options.subtype.toLowerCase() === \"vertical\";\n        },\n\n        _isHorizontalLayout: function() {\n            return this.options.subtype.toLowerCase() === \"right\" || this.options.subtype.toLowerCase() === \"left\" || this.options.subtype.toLowerCase() === \"horizontal\";\n        },\n        _isIncreasingLayout: function() {\n            // meaning that the visiting of the layers goes in the natural order of increasing layer index\n            return this.options.subtype.toLowerCase() === \"right\" || this.options.subtype.toLowerCase() === \"down\";\n        },\n        _moveThingsAround: function() {\n            var i, l, node, layer, n, w;\n            // sort the layers by their grid position\n            for (l = 0; l < this.layers.length; ++l) {\n                layer = this.layers[l];\n                layer.sort(this._gridPositionComparer);\n            }\n\n            this.minDistances = [];\n            for (l = 0; l < this.layers.length; ++l) {\n                layer = this.layers[l];\n                this.minDistances[l] = [];\n                for (n = 0; n < layer.length; ++n) {\n                    node = layer[n];\n                    node.layerIndex = n;\n                    this.minDistances[l][n] = this.options.nodeDistance;\n                    if (n < layer.length - 1) {\n                        if (this._isVerticalLayout()) {\n                            this.minDistances[l][n] += (node.width + layer[n + 1].width) / 2;\n                        }\n                        else {\n                            this.minDistances[l][n] += (node.height + layer[n + 1].height) / 2;\n                        }\n                    }\n                }\n            }\n\n            this.downNodes = new Dictionary();\n            this.upNodes = new Dictionary();\n            Utils.forEach(this.graph.nodes, function(node) {\n                this.downNodes.set(node, []);\n                this.upNodes.set(node, []);\n            }, this);\n            Utils.forEach(this.graph.links, function(link) {\n                var origin = link.source;\n                var dest = link.target;\n                var down = null, up = null;\n                if (origin.layer > dest.layer) {\n                    down = link.source;\n                    up = link.target;\n                }\n                else {\n                    up = link.source;\n                    down = link.target;\n                }\n                this.downNodes.get(up).push(down);\n                this.upNodes.get(down).push(up);\n            }, this);\n            this.downNodes.forEachValue(function(list) {\n                list.sort(this._gridPositionComparer);\n            }, this);\n            this.upNodes.forEachValue(function(list) {\n                list.sort(this._gridPositionComparer);\n            }, this);\n\n            for (l = 0; l < this.layers.length - 1; ++l) {\n                layer = this.layers[l];\n                for (w = 0; w < layer.length - 1; w++) {\n                    var currentNode = layer[w];\n                    if (!currentNode.isVirtual) {\n                        continue;\n                    }\n\n                    var currDown = this.downNodes.get(currentNode)[0];\n                    if (!currDown.isVirtual) {\n                        continue;\n                    }\n\n                    for (n = w + 1; n < layer.length; ++n) {\n                        node = layer[n];\n                        if (!node.isVirtual) {\n                            continue;\n                        }\n\n                        var downNode = this.downNodes.get(node)[0];\n                        if (!downNode.isVirtual) {\n                            continue;\n                        }\n\n                        if (currDown.gridPosition > downNode.gridPosition) {\n                            var pos = currDown.gridPosition;\n                            currDown.gridPosition = downNode.gridPosition;\n                            downNode.gridPosition = pos;\n                            var i1 = currDown.layerIndex;\n                            var i2 = downNode.layerIndex;\n                            this.layers[l + 1][i1] = downNode;\n                            this.layers[l + 1][i2] = currDown;\n                            currDown.layerIndex = i2;\n                            downNode.layerIndex = i1;\n                        }\n                    }\n                }\n            }\n\n\n            var leftClasses = this._getLeftWing();\n            var rightClasses = this._getRightWing();\n\n\n            var leftPos = this.placeLeftToRight(leftClasses);\n            var rightPos = this.placeRightToLeft(rightClasses);\n            var x = new Dictionary();\n            Utils.forEach(this.graph.nodes, function(node) {\n                x.set(node, (leftPos.get(node) + rightPos.get(node)) / 2);\n            });\n\n\n            var order = new Dictionary();\n            var placed = new Dictionary();\n            for (l = 0; l < this.layers.length; ++l) {\n                layer = this.layers[l];\n                var sequenceStart = -1, sequenceEnd = -1;\n                for (n = 0; n < layer.length; ++n) {\n                    node = layer[n];\n                    order.set(node, 0);\n                    placed.set(node, false);\n                    if (node.isVirtual) {\n                        if (sequenceStart === -1) {\n                            sequenceStart = n;\n                        }\n                        else if (sequenceStart === n - 1) {\n                            sequenceStart = n;\n                        }\n                        else {\n                            sequenceEnd = n;\n                            order.set(layer[sequenceStart], 0);\n                            if (x.get(node) - x.get(layer[sequenceStart]) === this.getMinDist(layer[sequenceStart], node)) {\n                                placed.set(layer[sequenceStart], true);\n                            }\n                            else {\n                                placed.set(layer[sequenceStart], false);\n                            }\n                            sequenceStart = n;\n                        }\n                    }\n                }\n            }\n            var directions = [1, -1];\n            Utils.forEach(directions, function(d) {\n                var start = d === 1 ? 0 : this.layers.length - 1;\n                for (var l = start; l >= 0 && l < this.layers.length; l += d) {\n                    var layer = this.layers[l];\n                    var virtualStartIndex = this._firstVirtualNode(layer);\n                    var virtualStart = null;\n                    var sequence = null;\n                    if (virtualStartIndex !== -1) {\n                        virtualStart = layer[virtualStartIndex];\n                        sequence = [];\n                        for (i = 0; i < virtualStartIndex; i++) {\n                            sequence.push(layer[i]);\n                        }\n                    }\n                    else {\n                        virtualStart = null;\n                        sequence = layer;\n                    }\n                    if (sequence.length > 0) {\n                        this._sequencer(x, null, virtualStart, d, sequence);\n                        for (i = 0; i < sequence.length - 1; ++i) {\n                            this.setMinDist(sequence[i], sequence[i + 1], x.get(sequence[i + 1]) - x.get(sequence[i]));\n                        }\n                        if (virtualStart) {\n                            this.setMinDist(sequence[sequence.length - 1], virtualStart, x.get(virtualStart) - x.get(sequence[sequence.length - 1]));\n                        }\n                    }\n\n                    while (virtualStart) {\n                        var virtualEnd = this.nextVirtualNode(layer, virtualStart);\n                        if (!virtualEnd) {\n                            virtualStartIndex = virtualStart.layerIndex;\n                            sequence = [];\n                            for (i = virtualStartIndex + 1; i < layer.length; i++) {\n                                sequence.push(layer[i]);\n                            }\n                            if (sequence.length > 0) {\n                                this._sequencer(x, virtualStart, null, d, sequence);\n                                for (i = 0; i < sequence.length - 1; ++i) {\n                                    this.setMinDist(sequence[i], sequence[i + 1], x.get(sequence[i + 1]) - x.get(sequence[i]));\n                                }\n                                this.setMinDist(virtualStart, sequence[0], x.get(sequence[0]) - x.get(virtualStart));\n                            }\n                        }\n                        else if (order.get(virtualStart) === d) {\n                            virtualStartIndex = virtualStart.layerIndex;\n                            var virtualEndIndex = virtualEnd.layerIndex;\n                            sequence = [];\n                            for (i = virtualStartIndex + 1; i < virtualEndIndex; i++) {\n                                sequence.push(layer[i]);\n                            }\n                            if (sequence.length > 0) {\n                                this._sequencer(x, virtualStart, virtualEnd, d, sequence);\n                            }\n                            placed.set(virtualStart, true);\n                        }\n                        virtualStart = virtualEnd;\n                    }\n                    this.adjustDirections(l, d, order, placed);\n                }\n            }, this);\n\n\n            var fromLayerIndex = this._isIncreasingLayout() ? 0 : this.layers.length - 1;\n            var reachedFinalLayerIndex = function(k, ctx) {\n                if (ctx._isIncreasingLayout()) {\n                    return k < ctx.layers.length;\n                }\n                else {\n                    return k >= 0;\n                }\n            };\n            var layerIncrement = this._isIncreasingLayout() ? +1 : -1, offset = 0;\n\n            /**\n             * Calcs the max height of the given layer.\n             */\n            function maximumHeight(layer, ctx) {\n                var height = Number.MIN_VALUE;\n                for (var n = 0; n < layer.length; ++n) {\n                    var node = layer[n];\n                    if (ctx._isVerticalLayout()) {\n                        height = Math.max(height, node.height);\n                    }\n                    else {\n                        height = Math.max(height, node.width);\n                    }\n                }\n                return height;\n            }\n\n            for (i = fromLayerIndex; reachedFinalLayerIndex(i, this); i += layerIncrement) {\n                layer = this.layers[i];\n                var height = maximumHeight(layer, this);\n\n                for (n = 0; n < layer.length; ++n) {\n                    node = layer[n];\n                    if (this._isVerticalLayout()) {\n                        node.x = x.get(node);\n                        node.y = offset + height / 2;\n                    }\n                    else {\n                        node.x = offset + height / 2;\n                        node.y = x.get(node);\n                    }\n                }\n\n                offset += this.options.layerSeparation + height;\n            }\n        },\n\n        adjustDirections: function(l, d, order, placed) {\n            if (l + d < 0 || l + d >= this.layers.length) {\n                return;\n            }\n\n            var prevBridge = null, prevBridgeTarget = null;\n            var layer = this.layers[l + d];\n            for (var n = 0; n < layer.length; ++n) {\n                var nextBridge = layer[n];\n                if (nextBridge.isVirtual) {\n                    var nextBridgeTarget = this.getNeighborOnLayer(nextBridge, l);\n                    if (nextBridgeTarget.isVirtual) {\n                        if (prevBridge) {\n                            var p = placed.get(prevBridgeTarget);\n                            var clayer = this.layers[l];\n                            var i1 = prevBridgeTarget.layerIndex;\n                            var i2 = nextBridgeTarget.layerIndex;\n                            for (var i = i1 + 1; i < i2; ++i) {\n                                if (clayer[i].isVirtual) {\n                                    p = p && placed.get(clayer[i]);\n                                }\n                            }\n                            if (p) {\n                                order.set(prevBridge, d);\n                                var j1 = prevBridge.layerIndex;\n                                var j2 = nextBridge.layerIndex;\n                                for (var j = j1 + 1; j < j2; ++j) {\n                                    if (layer[j].isVirtual) {\n                                        order.set(layer[j], d);\n                                    }\n                                }\n                            }\n                        }\n                        prevBridge = nextBridge;\n                        prevBridgeTarget = nextBridgeTarget;\n                    }\n                }\n            }\n        },\n\n        getNeighborOnLayer: function(node, l) {\n            var neighbor = this.upNodes.get(node)[0];\n            if (neighbor.layer === l) {\n                return neighbor;\n            }\n            neighbor = this.downNodes.get(node)[0];\n            if (neighbor.layer === l) {\n                return neighbor;\n            }\n            return null;\n        },\n\n        _sequencer: function(x, virtualStart, virtualEnd, dir, sequence) {\n            if (sequence.length === 1) {\n                this._sequenceSingle(x, virtualStart, virtualEnd, dir, sequence[0]);\n            }\n\n            if (sequence.length > 1) {\n                var r = sequence.length, t = this.intDiv(r, 2);\n                this._sequencer(x, virtualStart, virtualEnd, dir, sequence.slice(0, t));\n                this._sequencer(x, virtualStart, virtualEnd, dir, sequence.slice(t));\n                this.combineSequences(x, virtualStart, virtualEnd, dir, sequence);\n            }\n        },\n\n        _sequenceSingle: function(x, virtualStart, virtualEnd, dir, node) {\n            var neighbors = dir === -1 ? this.downNodes.get(node) : this.upNodes.get(node);\n\n            var n = neighbors.length;\n            if (n !== 0) {\n                if (n % 2 === 1) {\n                    x.set(node, x.get(neighbors[this.intDiv(n, 2)]));\n                }\n                else {\n                    x.set(node, (x.get(neighbors[this.intDiv(n, 2) - 1]) + x.get(neighbors[this.intDiv(n, 2)])) / 2);\n                }\n\n                if (virtualStart) {\n                    x.set(node, Math.max(x.get(node), x.get(virtualStart) + this.getMinDist(virtualStart, node)));\n                }\n                if (virtualEnd) {\n                    x.set(node, Math.min(x.get(node), x.get(virtualEnd) - this.getMinDist(node, virtualEnd)));\n                }\n            }\n        },\n\n        combineSequences: function(x, virtualStart, virtualEnd, dir, sequence) {\n            var r = sequence.length, t = this.intDiv(r, 2);\n\n            // collect left changes\n            var leftHeap = [], i, c, n, neighbors, neighbor, pair;\n            for (i = 0; i < t; ++i) {\n                c = 0;\n                neighbors = dir === -1 ? this.downNodes.get(sequence[i]) : this.upNodes.get(sequence[i]);\n                for (n = 0; n < neighbors.length; ++n) {\n                    neighbor = neighbors[n];\n                    if (x.get(neighbor) >= x.get(sequence[i])) {\n                        c++;\n                    }\n                    else {\n                        c--;\n                        leftHeap.push({ k: x.get(neighbor) + this.getMinDist(sequence[i], sequence[t - 1]), v: 2 });\n                    }\n                }\n                leftHeap.push({ k: x.get(sequence[i]) + this.getMinDist(sequence[i], sequence[t - 1]), v: c });\n            }\n            if (virtualStart) {\n                leftHeap.push({ k: x.get(virtualStart) + this.getMinDist(virtualStart, sequence[t - 1]), v: Number.MAX_VALUE });\n            }\n            leftHeap.sort(this._positionDescendingComparer);\n\n            // collect right changes\n            var rightHeap = [];\n            for (i = t; i < r; ++i) {\n                c = 0;\n                neighbors = dir === -1 ? this.downNodes.get(sequence[i]) : this.upNodes.get(sequence[i]);\n                for (n = 0; n < neighbors.length; ++n) {\n                    neighbor = neighbors[n];\n                    if (x.get(neighbor) <= x.get(sequence[i])) {\n                        c++;\n                    }\n                    else {\n                        c--;\n                        rightHeap.push({ k: x.get(neighbor) - this.getMinDist(sequence[i], sequence[t]), v: 2 });\n                    }\n                }\n                rightHeap.push({ k: x.get(sequence[i]) - this.getMinDist(sequence[i], sequence[t]), v: c });\n            }\n            if (virtualEnd) {\n                rightHeap.push({ k: x.get(virtualEnd) - this.getMinDist(virtualEnd, sequence[t]), v: Number.MAX_VALUE });\n            }\n            rightHeap.sort(this._positionAscendingComparer);\n\n            var leftRes = 0, rightRes = 0;\n            var m = this.getMinDist(sequence[t - 1], sequence[t]);\n            while (x.get(sequence[t]) - x.get(sequence[t - 1]) < m) {\n                if (leftRes < rightRes) {\n                    if (leftHeap.length === 0) {\n                        x.set(sequence[t - 1], x.get(sequence[t]) - m);\n                        break;\n                    }\n                    else {\n                        pair = leftHeap.shift();\n                        leftRes = leftRes + pair.v;\n                        x.set(sequence[t - 1], pair.k);\n                        x.set(sequence[t - 1], Math.max(x.get(sequence[t - 1]), x.get(sequence[t]) - m));\n                    }\n                }\n                else {\n                    if (rightHeap.length === 0) {\n                        x.set(sequence[t], x.get(sequence[t - 1]) + m);\n                        break;\n                    }\n                    else {\n                        pair = rightHeap.shift();\n                        rightRes = rightRes + pair.v;\n                        x.set(sequence[t], pair.k);\n                        x.set(sequence[t], Math.min(x.get(sequence[t]), x.get(sequence[t - 1]) + m));\n                    }\n                }\n            }\n            for (i = t - 2; i >= 0; i--) {\n                x.set(sequence[i], Math.min(x.get(sequence[i]), x.get(sequence[t - 1]) - this.getMinDist(sequence[i], sequence[t - 1])));\n            }\n            for (i = t + 1; i < r; i++) {\n                x.set(sequence[i], Math.max(x.get(sequence[i]), x.get(sequence[t]) + this.getMinDist(sequence[i], sequence[t])));\n            }\n        },\n\n        placeLeft: function(node, leftPos, leftClass) {\n            var pos = Number.NEGATIVE_INFINITY;\n            Utils.forEach(this._getComposite(node), function(v) {\n                var leftSibling = this.leftSibling(v);\n                if (leftSibling && this.nodeLeftClass.get(leftSibling) === this.nodeLeftClass.get(v)) {\n                    if (!leftPos.containsKey(leftSibling)) {\n                        this.placeLeft(leftSibling, leftPos, leftClass);\n                    }\n                    pos = Math.max(pos, leftPos.get(leftSibling) + this.getMinDist(leftSibling, v));\n                }\n            }, this);\n            if (pos === Number.NEGATIVE_INFINITY) {\n                pos = 0;\n            }\n            Utils.forEach(this._getComposite(node), function(v) {\n                leftPos.set(v, pos);\n            });\n        },\n\n        placeRight: function(node, rightPos, rightClass) {\n            var pos = Number.POSITIVE_INFINITY;\n            Utils.forEach(this._getComposite(node), function(v) {\n                var rightSibling = this.rightSibling(v);\n                if (rightSibling && this.nodeRightClass.get(rightSibling) === this.nodeRightClass.get(v)) {\n                    if (!rightPos.containsKey(rightSibling)) {\n                        this.placeRight(rightSibling, rightPos, rightClass);\n                    }\n                    pos = Math.min(pos, rightPos.get(rightSibling) - this.getMinDist(v, rightSibling));\n                }\n            }, this);\n            if (pos === Number.POSITIVE_INFINITY) {\n                pos = 0;\n            }\n            Utils.forEach(this._getComposite(node), function(v) {\n                rightPos.set(v, pos);\n            });\n        },\n\n        leftSibling: function(node) {\n            var layer = this.layers[node.layer],\n                layerIndex = node.layerIndex;\n            return layerIndex === 0 ? null : layer[layerIndex - 1];\n        },\n\n        rightSibling: function(node) {\n            var layer = this.layers[node.layer];\n            var layerIndex = node.layerIndex;\n            return layerIndex === layer.length - 1 ? null : layer[layerIndex + 1];\n\n        },\n\n        _getComposite: function(node) {\n            return node.isVirtual ? this._nodesInLink(node) : [node];\n        },\n\n        arrangeNodes: function() {\n            var i, l, ni, layer, node;\n            // Initialize node's base priority\n            for (l = 0; l < this.layers.length; l++) {\n                layer = this.layers[l];\n\n                for (ni = 0; ni < layer.length; ni++) {\n                    node = layer[ni];\n                    node.upstreamPriority = node.upstreamLinkCount;\n                    node.downstreamPriority = node.downstreamLinkCount;\n                }\n            }\n\n            // Layout is invoked after MinimizeCrossings\n            // so we may assume node's barycenters are initially correct\n\n            var maxLayoutIterations = 2;\n            for (var it = 0; it < maxLayoutIterations; it++) {\n                for (i = this.layers.length - 1; i >= 1; i--) {\n                    this.layoutLayer(false, i);\n                }\n\n                for (i = 0; i < this.layers.length - 1; i++) {\n                    this.layoutLayer(true, i);\n                }\n            }\n\n            // Offset the whole structure so that there are no gridPositions < 0\n            var gridPos = Number.MAX_VALUE;\n            for (l = 0; l < this.layers.length; l++) {\n                layer = this.layers[l];\n\n                for (ni = 0; ni < layer.length; ni++) {\n                    node = layer[ni];\n                    gridPos = Math.min(gridPos, node.gridPosition);\n                }\n            }\n\n            if (gridPos < 0) {\n                for (l = 0; l < this.layers.length; l++) {\n                    layer = this.layers[l];\n\n                    for (ni = 0; ni < layer.length; ni++) {\n                        node = layer[ni];\n                        node.gridPosition = node.gridPosition - gridPos;\n                    }\n                }\n            }\n        },\n\n        /// <summary>\n        /// Layout of a single layer.\n        /// </summary>\n        /// <param name=\"layerIndex\">The layer to organize.</param>\n        /// <param name=\"movingDownwards\">If set to <c>true</c> we move down in the layer stack.</param>\n        /// <seealso cref=\"OptimizeCrossings()\"/>\n        layoutLayer: function(down, layer) {\n            var iconsidered;\n            var considered;\n\n            if (down) {\n                considered = this.layers[iconsidered = layer + 1];\n            }\n            else {\n                considered = this.layers[iconsidered = layer - 1];\n            }\n\n            // list containing the nodes in the considered layer sorted by priority\n            var sorted = [];\n            for (var n = 0; n < considered.length; n++) {\n                sorted.push(considered[n]);\n            }\n            sorted.sort(function(n1, n2) {\n                var n1Priority = (n1.upstreamPriority + n1.downstreamPriority) / 2;\n                var n2Priority = (n2.upstreamPriority + n2.downstreamPriority) / 2;\n\n                if (Math.abs(n1Priority - n2Priority) < 0.0001) {\n                    return 0;\n                }\n                if (n1Priority < n2Priority) {\n                    return 1;\n                }\n                return -1;\n            });\n\n            // each node strives for its barycenter; high priority nodes start first\n            Utils.forEach(sorted, function(node) {\n                var nodeGridPos = node.gridPosition;\n                var nodeBaryCenter = this.calcBaryCenter(node);\n                var nodePriority = (node.upstreamPriority + node.downstreamPriority) / 2;\n\n                if (Math.abs(nodeGridPos - nodeBaryCenter) < 0.0001) {\n                    // This node is exactly at its barycenter -> perfect\n                    return;\n                }\n\n                if (Math.abs(nodeGridPos - nodeBaryCenter) < 0.25 + 0.0001) {\n                    // This node is close enough to the barycenter -> should work\n                    return;\n                }\n\n                if (nodeGridPos < nodeBaryCenter) {\n                    // Try to move the node to the right in an\n                    // attempt to reach its barycenter\n                    while (nodeGridPos < nodeBaryCenter) {\n                        if (!this.moveRight(node, considered, nodePriority)) {\n                            break;\n                        }\n\n                        nodeGridPos = node.gridPosition;\n                    }\n                }\n                else {\n                    // Try to move the node to the left in an\n                    // attempt to reach its barycenter\n                    while (nodeGridPos > nodeBaryCenter) {\n                        if (!this.moveLeft(node, considered, nodePriority)) {\n                            break;\n                        }\n\n                        nodeGridPos = node.gridPosition;\n                    }\n                }\n            }, this);\n\n            // after the layer has been rearranged we need to recalculate the barycenters\n            // of the nodes in the surrounding layers\n            if (iconsidered > 0) {\n                this.calcDownData(iconsidered - 1);\n            }\n            if (iconsidered < this.layers.length - 1) {\n                this.calcUpData(iconsidered + 1);\n            }\n        },\n\n        /// <summary>\n        /// Moves the node to the right and returns <c>true</c> if this was possible.\n        /// </summary>\n        /// <param name=\"node\">The node.</param>\n        /// <param name=\"layer\">The layer.</param>\n        /// <returns>Returns <c>true</c> if the shift was possible, otherwise <c>false</c>.</returns>\n        moveRight: function(node, layer, priority) {\n            var index = Utils.indexOf(layer, node);\n            if (index === layer.length - 1) {\n                // this is the last node in the layer, so we can move to the right without troubles\n                node.gridPosition = node.gridPosition + 0.5;\n                return true;\n            }\n\n            var rightNode = layer[index + 1];\n            var rightNodePriority = (rightNode.upstreamPriority + rightNode.downstreamPriority) / 2;\n\n            // check if there is space between the right and the current node\n            if (rightNode.gridPosition > node.gridPosition + 1) {\n                node.gridPosition = node.gridPosition + 0.5;\n                return true;\n            }\n\n            // we have reached a node with higher priority; no movement is allowed\n            if (rightNodePriority > priority ||\n                Math.abs(rightNodePriority - priority) < 0.0001) {\n                return false;\n            }\n\n            // the right node has lower priority - try to move it\n            if (this.moveRight(rightNode, layer, priority)) {\n                node.gridPosition = node.gridPosition + 0.5;\n                return true;\n            }\n\n            return false;\n        },\n\n        /// <summary>\n        /// Moves the node to the left and returns <c>true</c> if this was possible.\n        /// </summary>\n        /// <param name=\"node\">The node.</param>\n        /// <param name=\"layer\">The layer.</param>\n        /// <returns>Returns <c>true</c> if the shift was possible, otherwise <c>false</c>.</returns>\n        moveLeft: function(node, layer, priority) {\n            var index = Utils.indexOf(layer, node);\n            if (index === 0) {\n                // this is the last node in the layer, so we can move to the left without troubles\n                node.gridPosition = node.gridPosition - 0.5;\n                return true;\n            }\n\n            var leftNode = layer[index - 1];\n            var leftNodePriority = (leftNode.upstreamPriority + leftNode.downstreamPriority) / 2;\n\n            // check if there is space between the left and the current node\n            if (leftNode.gridPosition < node.gridPosition - 1) {\n                node.gridPosition = node.gridPosition - 0.5;\n                return true;\n            }\n\n            // we have reached a node with higher priority; no movement is allowed\n            if (leftNodePriority > priority ||\n                Math.abs(leftNodePriority - priority) < 0.0001) {\n                return false;\n            }\n\n            // The left node has lower priority - try to move it\n            if (this.moveLeft(leftNode, layer, priority)) {\n                node.gridPosition = node.gridPosition - 0.5;\n                return true;\n            }\n\n            return false;\n        },\n\n        mapVirtualNode: function(node, link) {\n            this.nodeToLinkMap.set(node, link);\n            if (!this.linkToNodeMap.containsKey(link)) {\n                this.linkToNodeMap.set(link, []);\n            }\n            this.linkToNodeMap.get(link).push(node);\n        },\n\n        _nodesInLink: function(node) {\n            return this.linkToNodeMap.get(this.nodeToLinkMap.get(node));\n        },\n\n        /// <summary>\n        /// Inserts dummy nodes to break long links.\n        /// </summary>\n        _dummify: function() {\n            this.linkToNodeMap = new Dictionary();\n            this.nodeToLinkMap = new Dictionary();\n\n            var layer, pos, newNode, node, r, newLink, i, l, links = this.graph.links.slice(0);\n            var layers = this.layers;\n\n            var addLinkBetweenLayers = function(upLayer, downLayer, link) {\n                layers[upLayer].linksTo[downLayer] = layers[upLayer].linksTo[downLayer] || [];\n                layers[upLayer].linksTo[downLayer].push(link);\n            };\n\n            for (l = 0; l < links.length; l++) {\n                var link = links[l];\n                var o = link.source;\n                var d = link.target;\n\n                var oLayer = o.layer;\n                var dLayer = d.layer;\n                var oPos = o.gridPosition;\n                var dPos = d.gridPosition;\n\n                var step = (dPos - oPos) / Math.abs(dLayer - oLayer);\n\n                var p = o;\n                if (oLayer - dLayer > 1) {\n                    for (i = oLayer - 1; i > dLayer; i--) {\n                        newNode = new Node();\n                        newNode.x = o.x;\n                        newNode.y = o.y;\n                        newNode.width = o.width / 100;\n                        newNode.height = o.height / 100;\n\n                        layer = layers[i];\n                        pos = (i - dLayer) * step + oPos;\n                        if (pos > layer.length) {\n                            pos = layer.length;\n                        }\n\n                        // check if origin and dest are both last\n                        if (oPos >= layers[oLayer].length - 1 &&\n                            dPos >= layers[dLayer].length - 1) {\n                            pos = layer.length;\n                        }\n\n                        // check if origin and destination are both first\n                        else if (oPos === 0 && dPos === 0) {\n                            pos = 0;\n                        }\n\n                        newNode.layer = i;\n                        newNode.uBaryCenter = 0.0;\n                        newNode.dBaryCenter = 0.0;\n                        newNode.upstreamLinkCount = 0;\n                        newNode.downstreamLinkCount = 0;\n                        newNode.gridPosition = pos;\n                        newNode.isVirtual = true;\n\n                        Utils.insert(layer, newNode, pos);\n\n                        // translate rightwards nodes' positions\n                        for (r = pos + 1; r < layer.length; r++) {\n                            node = layer[r];\n                            node.gridPosition = node.gridPosition + 1;\n                        }\n\n                        newLink = new Link(p, newNode);\n                        newLink.depthOfDumminess = 0;\n\n                        addLinkBetweenLayers(i - 1, i, newLink);\n\n                        p = newNode;\n\n                        // add the new node and the new link to the graph\n                        this.graph._addNode(newNode);\n                        this.graph.addLink(newLink);\n\n                        newNode.index = this.graph.nodes.length - 1;\n                        this.mapVirtualNode(newNode, link);\n                    }\n\n                    // set the origin of the real arrow to the last dummy\n                    addLinkBetweenLayers(dLayer - 1, dLayer, newLink);\n                    link.changeSource(p);\n                    link.depthOfDumminess = oLayer - dLayer - 1;\n                } else if (oLayer - dLayer < -1) {\n                    for (i = oLayer + 1; i < dLayer; i++) {\n                        newNode = new Node();\n                        newNode.x = o.x;\n                        newNode.y = o.y;\n                        newNode.width = o.width / 100;\n                        newNode.height = o.height / 100;\n\n                        layer = layers[i];\n                        pos = (i - oLayer) * step + oPos;\n                        if (pos > layer.length) {\n                            pos = layer.length;\n                        }\n\n                        // check if origin and dest are both last\n                        if (oPos >= layers[oLayer].length - 1 &&\n                            dPos >= layers[dLayer].length - 1) {\n                            pos = layer.length;\n                        }\n\n                        // check if origin and destination are both first\n                        else if (oPos === 0 && dPos === 0) {\n                            pos = 0;\n                        }\n\n                        newNode.layer = i;\n                        newNode.uBaryCenter = 0.0;\n                        newNode.dBaryCenter = 0.0;\n                        newNode.upstreamLinkCount = 0;\n                        newNode.downstreamLinkCount = 0;\n                        newNode.gridPosition = pos;\n                        newNode.isVirtual = true;\n\n                        pos &= pos; // truncates to int\n                        Utils.insert(layer, newNode, pos);\n\n                        // translate rightwards nodes' positions\n                        for (r = pos + 1; r < layer.length; r++) {\n                            node = layer[r];\n                            node.gridPosition = node.gridPosition + 1;\n                        }\n\n                        newLink = new Link(p, newNode);\n                        newLink.depthOfDumminess = 0;\n                        addLinkBetweenLayers(i - 1, i, newLink);\n\n                        p = newNode;\n\n                        // add the new node and the new link to the graph\n                        this.graph._addNode(newNode);\n                        this.graph.addLink(newLink);\n\n                        newNode.index = this.graph.nodes.length - 1;\n                        this.mapVirtualNode(newNode, link);\n                    }\n                    addLinkBetweenLayers(dLayer - 1, dLayer, link);\n\n                    // Set the origin of the real arrow to the last dummy\n                    link.changeSource(p);\n                    link.depthOfDumminess = dLayer - oLayer - 1;\n                } else {\n                    addLinkBetweenLayers(oLayer, dLayer, link);\n                }\n            }\n        },\n\n        /// <summary>\n        /// Removes the dummy nodes inserted earlier to break long links.\n        /// </summary>\n        /// <remarks>The virtual nodes are effectively turned into intermediate connection points.</remarks>\n        _dedummify: function() {\n            var dedum = true;\n            while (dedum) {\n                dedum = false;\n\n                for (var l = 0; l < this.graph.links.length; l++) {\n                    var link = this.graph.links[l];\n                    if (!link.depthOfDumminess) {\n                        continue;\n                    }\n\n                    var points = [];\n\n                    // add points in reverse order\n                    points.unshift({ x: link.target.x, y: link.target.y });\n                    points.unshift({ x: link.source.x, y: link.source.y });\n\n                    // _dedummify the link\n                    var temp = link;\n                    var depthOfDumminess = link.depthOfDumminess;\n                    for (var d = 0; d < depthOfDumminess; d++) {\n                        var node = temp.source;\n                        var prevLink = node.incoming[0];\n\n                        points.unshift({ x: prevLink.source.x, y: prevLink.source.y });\n\n                        temp = prevLink;\n                    }\n\n                    // restore the original link origin\n                    link.changeSource(temp.source);\n\n                    // reset dummification flag\n                    link.depthOfDumminess = 0;\n\n                    // note that we only need the intermediate points, floating links have been dropped in the analysis\n                    if (points.length > 2) {\n                        // first and last are the endpoints\n                        points.splice(0, 1);\n                        points.splice(points.length - 1);\n                        link.points = points;\n                    }\n                    else {\n                        link.points = [];\n                    }\n\n                    // we are not going to delete the dummy elements;\n                    // they won't be needed anymore anyway.\n\n                    dedum = true;\n                    break;\n                }\n            }\n        },\n\n        /// <summary>\n        /// Optimizes/reduces the crossings between the layers by turning the crossing problem into a (combinatorial) number ordering problem.\n        /// </summary>\n        _optimizeCrossings: function() {\n            var moves = -1, i;\n            var maxIterations = 3;\n            var iter = 0;\n\n            while (moves !== 0) {\n                if (iter++ > maxIterations) {\n                    break;\n                }\n\n                moves = 0;\n\n                for (i = this.layers.length - 1; i >= 1; i--) {\n                    moves += this.optimizeLayerCrossings(false, i);\n                }\n\n                for (i = 0; i < this.layers.length - 1; i++) {\n                    moves += this.optimizeLayerCrossings(true, i);\n                }\n            }\n        },\n\n        calcUpData: function(layer) {\n            if (layer === 0) {\n                return;\n            }\n\n            var considered = this.layers[layer], i, l, link;\n            var upLayer = new Set();\n            var temp = this.layers[layer - 1];\n            for (i = 0; i < temp.length; i++) {\n                upLayer.add(temp[i]);\n            }\n\n            for (i = 0; i < considered.length; i++) {\n                var node = considered[i];\n\n                // calculate barycenter\n                var sum = 0;\n                var total = 0;\n\n                for (l = 0; l < node.incoming.length; l++) {\n                    link = node.incoming[l];\n                    if (upLayer.contains(link.source)) {\n                        total++;\n                        sum += link.source.gridPosition;\n                    }\n                }\n\n                for (l = 0; l < node.outgoing.length; l++) {\n                    link = node.outgoing[l];\n                    if (upLayer.contains(link.target)) {\n                        total++;\n                        sum += link.target.gridPosition;\n                    }\n                }\n\n                if (total > 0) {\n                    node.uBaryCenter = sum / total;\n                    node.upstreamLinkCount = total;\n                }\n                else {\n                    node.uBaryCenter = i;\n                    node.upstreamLinkCount = 0;\n                }\n            }\n        },\n\n        calcDownData: function(layer) {\n            if (layer === this.layers.length - 1) {\n                return;\n            }\n\n            var considered = this.layers[layer], i , l, link;\n            var downLayer = new Set();\n            var temp = this.layers[layer + 1];\n            for (i = 0; i < temp.length; i++) {\n                downLayer.add(temp[i]);\n            }\n\n            for (i = 0; i < considered.length; i++) {\n                var node = considered[i];\n\n                // calculate barycenter\n                var sum = 0;\n                var total = 0;\n\n                for (l = 0; l < node.incoming.length; l++) {\n                    link = node.incoming[l];\n                    if (downLayer.contains(link.source)) {\n                        total++;\n                        sum += link.source.gridPosition;\n                    }\n                }\n\n                for (l = 0; l < node.outgoing.length; l++) {\n                    link = node.outgoing[l];\n                    if (downLayer.contains(link.target)) {\n                        total++;\n                        sum += link.target.gridPosition;\n                    }\n                }\n\n                if (total > 0) {\n                    node.dBaryCenter = sum / total;\n                    node.downstreamLinkCount = total;\n                }\n                else {\n                    node.dBaryCenter = i;\n                    node.downstreamLinkCount = 0;\n                }\n            }\n        },\n\n        /// <summary>\n        /// Optimizes the crossings.\n        /// </summary>\n        /// <remarks>The big trick here is the usage of weights or values attached to connected nodes which turn a problem of crossing links\n        /// to an a problem of ordering numbers.</remarks>\n        /// <param name=\"layerIndex\">The layer index.</param>\n        /// <param name=\"movingDownwards\">If set to <c>true</c> we move down in the layer stack.</param>\n        /// <returns>The number of nodes having moved, i.e. the number of crossings reduced.</returns>\n        optimizeLayerCrossings: function(down, layer) {\n            var iconsidered;\n            var considered;\n\n            if (down) {\n                considered = this.layers[iconsidered = layer + 1];\n            }\n            else {\n                considered = this.layers[iconsidered = layer - 1];\n            }\n\n            // remember what it was\n            var presorted = considered.slice(0);\n\n            // calculate barycenters for all nodes in the considered layer\n            if (down) {\n                this.calcUpData(iconsidered);\n            }\n            else {\n                this.calcDownData(iconsidered);\n            }\n\n            var that = this;\n            // sort nodes within this layer according to the barycenters\n            considered.sort(function(n1, n2) {\n                var n1BaryCenter = that.calcBaryCenter(n1),\n                    n2BaryCenter = that.calcBaryCenter(n2);\n                if (Math.abs(n1BaryCenter - n2BaryCenter) < 0.0001) {\n                    // in case of coinciding barycenters compare by the count of in/out links\n                    if (n1.degree() === n2.degree()) {\n                        return that.compareByIndex(n1, n2);\n                    }\n                    else if (n1.degree() < n2.degree()) {\n                        return 1;\n                    }\n                    return -1;\n                }\n                var compareValue = (n2BaryCenter - n1BaryCenter) * 1000;\n                if (compareValue > 0) {\n                    return -1;\n                }\n                else if (compareValue < 0) {\n                    return 1;\n                }\n                return that.compareByIndex(n1, n2);\n            });\n\n            // count relocations\n            var i, moves = 0;\n            for (i = 0; i < considered.length; i++) {\n                if (considered[i] !== presorted[i]) {\n                    moves++;\n                }\n            }\n\n            if (moves > 0) {\n                // now that the boxes have been arranged, update their grid positions\n                var inode = 0;\n                for (i = 0; i < considered.length; i++) {\n                    var node = considered[i];\n                    node.gridPosition = inode++;\n                }\n            }\n\n            return moves;\n        },\n\n        /// <summary>\n        /// Swaps a pair of nodes in a layer.\n        /// </summary>\n        /// <param name=\"layerIndex\">Index of the layer.</param>\n        /// <param name=\"n\">The Nth node in the layer.</param>\n        _swapPairs: function() {\n            var maxIterations = this.options.layeredIterations;\n            var iter = 0;\n\n            while (true) {\n                if (iter++ > maxIterations) {\n                    break;\n                }\n\n                var downwards = (iter % 4 <= 1);\n                var secondPass = (iter % 4 === 1);\n\n                for (var l = (downwards ? 0 : this.layers.length - 1);\n                     downwards ? l <= this.layers.length - 1 : l >= 0; l += (downwards ? 1 : -1)) {\n                    var layer = this.layers[l];\n                    var hasSwapped = false;\n\n                    // there is no need to recalculate crossings if they were calculated\n                    // on the previous step and nothing has changed\n                    var calcCrossings = true;\n                    var memCrossings = 0;\n\n                    for (var n = 0; n < layer.length - 1; n++) {\n                        // count crossings\n                        var up = 0;\n                        var down = 0;\n                        var crossBefore = 0;\n\n                        if (calcCrossings) {\n                            if (l !== 0) {\n                                up = this.countLinksCrossingBetweenTwoLayers(l - 1, l);\n                            }\n                            if (l !== this.layers.length - 1) {\n                                down = this.countLinksCrossingBetweenTwoLayers(l, l + 1);\n                            }\n                            if (downwards) {\n                                up *= 2;\n                            }\n                            else {\n                                down *= 2;\n                            }\n\n                            crossBefore = up + down;\n                        }\n                        else {\n                            crossBefore = memCrossings;\n                        }\n\n                        if (crossBefore === 0) {\n                            continue;\n                        }\n\n                        // Swap nodes\n                        var node1 = layer[n];\n                        var node2 = layer[n + 1];\n\n                        var node1GridPos = node1.gridPosition;\n                        var node2GridPos = node2.gridPosition;\n                        layer[n] = node2;\n                        layer[n + 1] = node1;\n                        node1.gridPosition = node2GridPos;\n                        node2.gridPosition = node1GridPos;\n\n                        // count crossings again and if worse than before, restore swapping\n                        up = 0;\n                        if (l !== 0) {\n                            up = this.countLinksCrossingBetweenTwoLayers(l - 1, l);\n                        }\n                        down = 0;\n                        if (l !== this.layers.length - 1) {\n                            down = this.countLinksCrossingBetweenTwoLayers(l, l + 1);\n                        }\n                        if (downwards) {\n                            up *= 2;\n                        }\n                        else {\n                            down *= 2;\n                        }\n                        var crossAfter = up + down;\n\n                        var revert = false;\n                        if (secondPass) {\n                            revert = crossAfter >= crossBefore;\n                        }\n                        else {\n                            revert = crossAfter > crossBefore;\n                        }\n\n                        if (revert) {\n                            node1 = layer[n];\n                            node2 = layer[n + 1];\n\n                            node1GridPos = node1.gridPosition;\n                            node2GridPos = node2.gridPosition;\n                            layer[n] = node2;\n                            layer[n + 1] = node1;\n                            node1.gridPosition = node2GridPos;\n                            node2.gridPosition = node1GridPos;\n\n                            // nothing has changed, remember the crossings so that\n                            // they are not calculated again on the next step\n                            memCrossings = crossBefore;\n                            calcCrossings = false;\n                        }\n                        else {\n                            hasSwapped = true;\n                            calcCrossings = true;\n                        }\n                    }\n\n                    if (hasSwapped) {\n                        if (l !== this.layers.length - 1) {\n                            this.calcUpData(l + 1);\n                        }\n                        if (l !== 0) {\n                            this.calcDownData(l - 1);\n                        }\n                    }\n                }\n            }\n        },\n\n        /// <summary>\n        /// Counts the number of links crossing between two layers.\n        /// </summary>\n        /// <param name=\"layerIndex1\">The layer index.</param>\n        /// <param name=\"layerIndex2\">Another layer index.</param>\n        /// <returns></returns>\n        countLinksCrossingBetweenTwoLayers: function(ulayer, dlayer) {\n            var links = this.layers[ulayer].linksTo[dlayer];\n            var link1, link2, n11, n12, n21, n22, l1, l2;\n            var crossings = 0;\n            var length = links.length;\n\n            for (l1 = 0; l1 < length; l1++) {\n                link1 = links[l1];\n                for (l2 = l1 + 1; l2 < length; l2++) {\n\n                    link2 = links[l2];\n\n                    if (link1.target.layer === dlayer) {\n                        n11 = link1.source;\n                        n12 = link1.target;\n                    }\n                    else {\n                        n11 = link1.target;\n                        n12 = link1.source;\n                    }\n\n                    if (link2.target.layer === dlayer) {\n                        n21 = link2.source;\n                        n22 = link2.target;\n                    }\n                    else {\n                        n21 = link2.target;\n                        n22 = link2.source;\n                    }\n\n                    var n11gp = n11.gridPosition;\n                    var n12gp = n12.gridPosition;\n                    var n21gp = n21.gridPosition;\n                    var n22gp = n22.gridPosition;\n\n                    if ((n11gp - n21gp) * (n12gp - n22gp) < 0) {\n                        crossings++;\n                    }\n                }\n            }\n\n            return crossings;\n        },\n\n        calcBaryCenter: function(node) {\n            var upstreamLinkCount = node.upstreamLinkCount;\n            var downstreamLinkCount = node.downstreamLinkCount;\n            var uBaryCenter = node.uBaryCenter;\n            var dBaryCenter = node.dBaryCenter;\n\n            if (upstreamLinkCount > 0 && downstreamLinkCount > 0) {\n                return (uBaryCenter + dBaryCenter) / 2;\n            }\n            if (upstreamLinkCount > 0) {\n                return uBaryCenter;\n            }\n            if (downstreamLinkCount > 0) {\n                return dBaryCenter;\n            }\n\n            return 0;\n        },\n\n        _gridPositionComparer: function(x, y) {\n            if (x.gridPosition < y.gridPosition) {\n                return -1;\n            }\n            if (x.gridPosition > y.gridPosition) {\n                return 1;\n            }\n            return 0;\n        },\n\n        _positionAscendingComparer: function(x, y) {\n            return x.k < y.k ? -1 : x.k > y.k ? 1 : 0;\n        },\n\n        _positionDescendingComparer: function(x, y) {\n            return x.k < y.k ? 1 : x.k > y.k ? -1 : 0;\n        },\n\n        _firstVirtualNode: function(layer) {\n            for (var c = 0; c < layer.length; c++) {\n                if (layer[c].isVirtual) {\n                    return c;\n                }\n            }\n            return -1;\n        },\n\n        compareByIndex: function(o1, o2) {\n            var i1 = o1.index;\n            var i2 = o2.index;\n\n            if (i1 < i2) {\n                return 1;\n            }\n\n            if (i1 > i2) {\n                return -1;\n            }\n\n            return 0;\n        },\n\n        intDiv: function(numerator, denominator) {\n            return (numerator - numerator % denominator) / denominator;\n        },\n\n        nextVirtualNode: function(layer, node) {\n            var nodeIndex = node.layerIndex;\n            for (var i = nodeIndex + 1; i < layer.length; ++i) {\n                if (layer[i].isVirtual) {\n                    return layer[i];\n                }\n            }\n            return null;\n        }\n\n    });\n\n    /**\n     * Captures the state of a diagram; node positions, link points and so on.\n     * @type {*}\n     */\n    var LayoutState = kendo.Class.extend({\n        init: function(diagram, graphOrNodes) {\n            if (Utils.isUndefined(diagram)) {\n                throw \"No diagram given\";\n            }\n            this.diagram = diagram;\n            this.nodeMap = new Dictionary();\n            this.linkMap = new Dictionary();\n            this.capture(graphOrNodes ? graphOrNodes : diagram);\n        },\n\n        /**\n         * Will capture either\n         * - the state of the shapes and the intermediate points of the connections in the diagram\n         * - the bounds of the nodes contained in the Graph together with the intermediate points of the links in the Graph\n         * - the bounds of the nodes in the Array<Node>\n         * - the links points and node bounds in the literal object\n         * @param diagramOrGraphOrNodes\n         */\n        capture: function(diagramOrGraphOrNodes) {\n            var node,\n                nodes,\n                shape,\n                i,\n                conn,\n                link,\n                links;\n\n            if (diagramOrGraphOrNodes instanceof diagram.Graph) {\n\n                for (i = 0; i < diagramOrGraphOrNodes.nodes.length; i++) {\n                    node = diagramOrGraphOrNodes.nodes[i];\n                    shape = node.associatedShape;\n                    //shape.bounds(new Rect(node.x, node.y, node.width, node.height));\n                    this.nodeMap.set(shape.visual.id, new Rect(node.x, node.y, node.width, node.height));\n                }\n                for (i = 0; i < diagramOrGraphOrNodes.links.length; i++) {\n                    link = diagramOrGraphOrNodes.links[i];\n                    conn = link.associatedConnection;\n                    this.linkMap.set(conn.visual.id, link.points());\n                }\n            }\n            else if (diagramOrGraphOrNodes instanceof Array) {\n                nodes = diagramOrGraphOrNodes;\n                for (i = 0; i < nodes.length; i++) {\n                    node = nodes[i];\n                    shape = node.associatedShape;\n                    if (shape) {\n                        this.nodeMap.set(shape.visual.id, new Rect(node.x, node.y, node.width, node.height));\n                    }\n                }\n            }\n            else if (diagramOrGraphOrNodes.hasOwnProperty(\"links\") && diagramOrGraphOrNodes.hasOwnProperty(\"nodes\")) {\n                nodes = diagramOrGraphOrNodes.nodes;\n                links = diagramOrGraphOrNodes.links;\n                for (i = 0; i < nodes.length; i++) {\n                    node = nodes[i];\n                    shape = node.associatedShape;\n                    if (shape) {\n                        this.nodeMap.set(shape.visual.id, new Rect(node.x, node.y, node.width, node.height));\n                    }\n                }\n                for (i = 0; i < links.length; i++) {\n                    link = links[i];\n                    conn = link.associatedConnection;\n                    if (conn) {\n                        this.linkMap.set(conn.visual.id, link.points);\n                    }\n                }\n            }\n            else { // capture the diagram\n                var shapes = this.diagram.shapes;\n                var connections = this.diagram.connections;\n                for (i = 0; i < shapes.length; i++) {\n                    shape = shapes[i];\n                    this.nodeMap.set(shape.visual.id, shape.bounds());\n                }\n                for (i = 0; i < connections.length; i++) {\n                    conn = connections[i];\n                    this.linkMap.set(conn.visual.id, conn.points());\n                }\n            }\n        }\n    });\n\n    deepExtend(diagram, {\n        init: function(element) {\n            kendo.init(element, diagram.ui);\n        },\n        SpringLayout: SpringLayout,\n        TreeLayout: TreeLayout,\n        GraphAdapter: DiagramToHyperTreeAdapter,\n        LayeredLayout: LayeredLayout,\n        LayoutBase: LayoutBase,\n        LayoutState: LayoutState\n    });\n})(window.kendo.jQuery);\n\n(function($, undefined$1) {\n        // Imports ================================================================\n        var dataviz = kendo.dataviz,\n            draw = kendo.drawing,\n            geom = kendo.geometry,\n            diagram = dataviz.diagram,\n            Widget = kendo.ui.Widget,\n            Class = kendo.Class,\n            deepExtend = kendo.deepExtend,\n            outerWidth = kendo._outerWidth,\n            outerHeight = kendo._outerHeight,\n            extend = $.extend,\n            HierarchicalDataSource = kendo.data.HierarchicalDataSource,\n            Canvas = diagram.Canvas,\n            Group = diagram.Group,\n            Rectangle = diagram.Rectangle,\n            Circle = diagram.Circle,\n            CompositeTransform = diagram.CompositeTransform,\n            Rect = diagram.Rect,\n            Path = diagram.Path,\n            DeleteShapeUnit = diagram.DeleteShapeUnit,\n            DeleteConnectionUnit = diagram.DeleteConnectionUnit,\n            TextBlock = diagram.TextBlock,\n            Image = diagram.Image,\n            Point = diagram.Point,\n            Intersect = diagram.Intersect,\n            ConnectionEditAdorner = diagram.ConnectionEditAdorner,\n            UndoRedoService = diagram.UndoRedoService,\n            ToolService = diagram.ToolService,\n            Selector = diagram.Selector,\n            ResizingAdorner = diagram.ResizingAdorner,\n            ConnectorsAdorner = diagram.ConnectorsAdorner,\n            Cursors = diagram.Cursors,\n            Utils = diagram.Utils,\n            Observable = kendo.Observable,\n            ToBackUnit = diagram.ToBackUnit,\n            ToFrontUnit = diagram.ToFrontUnit,\n            PolylineRouter = diagram.PolylineRouter,\n            CascadingRouter = diagram.CascadingRouter,\n            isUndefined = Utils.isUndefined,\n            isDefined = Utils.isDefined,\n            defined = draw.util.defined,\n            isArray = Array.isArray,\n            isFunction = kendo.isFunction,\n            isString = Utils.isString,\n            isPlainObject = $.isPlainObject,\n\n            math = Math;\n\n        // Constants ==============================================================\n        var NS = \".kendoDiagram\",\n            CASCADING = \"cascading\",\n            ITEMBOUNDSCHANGE = \"itemBoundsChange\",\n            CHANGE = \"change\",\n            CLICK = \"click\",\n            DRAG = \"drag\",\n            DRAG_END = \"dragEnd\",\n            DRAG_START = \"dragStart\",\n            MOUSE_ENTER = \"mouseEnter\",\n            MOUSE_LEAVE = \"mouseLeave\",\n            ERROR = \"error\",\n            AUTO = \"Auto\",\n            TOP = \"Top\",\n            RIGHT = \"Right\",\n            LEFT = \"Left\",\n            BOTTOM = \"Bottom\",\n            MAXINT = 9007199254740992,\n            SELECT = \"select\",\n            ITEMROTATE = \"itemRotate\",\n            PAN = \"pan\",\n            ZOOM_START = \"zoomStart\",\n            ZOOM_END = \"zoomEnd\",\n            NONE = \"none\",\n            DEFAULT_CANVAS_WIDTH = 600,\n            DEFAULT_CANVAS_HEIGHT = 600,\n            DEFAULT_SHAPE_TYPE = \"rectangle\",\n            DEFAULT_SHAPE_WIDTH = 100,\n            DEFAULT_SHAPE_HEIGHT = 100,\n            DEFAULT_SHAPE_MINWIDTH = 20,\n            DEFAULT_SHAPE_MINHEIGHT = 20,\n            DEFAULT_SHAPE_POSITION = 0,\n            DEFAULT_CONNECTION_BACKGROUND = \"Yellow\",\n            MAX_VALUE = Number.MAX_VALUE,\n            MIN_VALUE = -Number.MAX_VALUE,\n            ABSOLUTE = \"absolute\",\n            TRANSFORMED = \"transformed\",\n            ROTATED = \"rotated\",\n            TRANSPARENT = \"transparent\",\n            WIDTH = \"width\",\n            HEIGHT = \"height\",\n            X = \"x\",\n            Y = \"y\",\n            MOUSEWHEEL_NS = \"DOMMouseScroll\" + NS + \" mousewheel\" + NS,\n            MOBILE_ZOOM_RATE = 0.05,\n            MOBILE_PAN_DISTANCE = 5,\n            BUTTON_TEMPLATE = ({ className, icon, themeColor, text }) =>\n                kendo.html.renderButton(`<button class=\"${className}\" href=\"#\">${text}</button>`, {\n                    icon: icon,\n                    themeColor\n                }),\n            CONNECTION_CONTENT_OFFSET = 5;\n\n        diagram.DefaultConnectors = [{\n            name: TOP\n        }, {\n            name: BOTTOM\n        }, {\n            name: LEFT\n        }, {\n            name: RIGHT\n        }, {\n            name: AUTO,\n            position: function(shape) {\n                return shape.getPosition(\"center\");\n            }\n        }];\n\n        var defaultButtons = {\n            cancel: {\n                text: \"Cancel\",\n                icon: \"cancel-outline\",\n                className: \"k-diagram-cancel\",\n            },\n            update: {\n                text: \"Save\",\n                imageClass: \"save\",\n                className: \"k-diagram-update\",\n                icon: \"save\",\n                themeColor: \"primary\"\n            }\n        };\n\n        diagram.shapeDefaults = function(extra) {\n            var defaults = {\n                type: DEFAULT_SHAPE_TYPE,\n                path: \"\",\n                autoSize: true,\n                visual: null,\n                x: DEFAULT_SHAPE_POSITION,\n                y: DEFAULT_SHAPE_POSITION,\n                minWidth: DEFAULT_SHAPE_MINWIDTH,\n                minHeight: DEFAULT_SHAPE_MINHEIGHT,\n                width: DEFAULT_SHAPE_WIDTH,\n                height: DEFAULT_SHAPE_HEIGHT,\n                hover: {},\n                editable: {\n                    connect: true,\n                    tools: []\n                },\n                connectors: diagram.DefaultConnectors,\n                rotation: {\n                    angle: 0\n                }\n            };\n\n            Utils.simpleExtend(defaults, extra);\n\n            return defaults;\n        };\n\n        function mwDelta(e) {\n            var origEvent = e.originalEvent,\n                delta = 0;\n\n            if (origEvent.wheelDelta) {\n                delta = -origEvent.wheelDelta / 40;\n                delta = delta > 0 ? math.ceil(delta) : math.floor(delta);\n            } else if (origEvent.detail) {\n                delta = origEvent.detail;\n            }\n\n            return delta;\n        }\n\n        function isAutoConnector(connector) {\n            return connector.options.name.toLowerCase() === AUTO.toLowerCase();\n        }\n\n        function closestConnector(point, connectors) {\n            var minimumDistance = MAXINT, resCtr, connector;\n            for (var i = 0; i < connectors.length; i++) {\n                connector = connectors[i];\n                if (!isAutoConnector(connector)) {\n                    var dist = point.distanceTo(connector.position());\n                    if (dist < minimumDistance) {\n                        minimumDistance = dist;\n                        resCtr = connector;\n                    }\n                }\n            }\n            return resCtr;\n        }\n\n        function indicesOfItems(group, visuals) {\n            var i, indices = [], visual;\n            var children = group.drawingContainer().children;\n            var length = children.length;\n            for (i = 0; i < visuals.length; i++) {\n                visual = visuals[i];\n                for (var j = 0; j < length; j++) {\n                    if (children[j] == visual.drawingContainer()) {\n                        indices.push(j);\n                        break;\n                    }\n                }\n            }\n            return indices;\n        }\n\n        var DiagramElement = Observable.extend({\n            init: function(options) {\n                var that = this;\n                that.dataItem = (options || {}).dataItem;\n                Observable.fn.init.call(that);\n                that.options = deepExtend({ id: diagram.randomId() }, that.options, options);\n                that.isSelected = false;\n                that.visual = new Group({\n                    id: that.options.id,\n                    autoSize: that.options.autoSize\n                });\n                that.id = that.options.id;\n                that._template();\n            },\n\n            options: {\n                hover: {},\n                cursor: Cursors.grip,\n                content: {\n                    align: \"center middle\"\n                },\n                selectable: true,\n                serializable: true,\n                enable: true\n            },\n\n            _getCursor: function(point) {\n                if (this.adorner) {\n                    return this.adorner._getCursor(point);\n                }\n                return this.options.cursor;\n            },\n\n            visible: function(value) {\n                if (isUndefined(value)) {\n                    return this.visual.visible();\n                } else {\n                    this.visual.visible(value);\n                }\n            },\n\n            bounds: function() {\n            },\n\n            refresh: function() {\n                this.visual.redraw();\n            },\n\n            position: function(point) {\n                this.options.x = point.x;\n                this.options.y = point.y;\n                this.visual.position(point);\n            },\n\n            toString: function() {\n                return this.options.id;\n            },\n\n            serialize: function() {\n                // the options json object describes the shape perfectly. So this object can serve as shape serialization.\n                var json = deepExtend({}, { options: this.options });\n                if (this.dataItem) {\n                    json.dataItem = this.dataItem.toString();\n                }\n                return json;\n            },\n\n            _content: function(content) {\n                if (content !== undefined$1) {\n                    var options = this.options;\n\n                    if (diagram.Utils.isString(content)) {\n                        options.content.text = content;\n                    } else {\n                        deepExtend(options.content, content);\n                    }\n\n                    var contentOptions = options.content;\n                    var contentVisual = this._contentVisual;\n\n                    if (!contentVisual) {\n                        this._createContentVisual(contentOptions);\n                    } else {\n                        this._updateContentVisual(contentOptions);\n                    }\n                }\n\n                return this.options.content.text;\n            },\n\n            _createContentVisual: function(options) {\n                if (options.text) {\n                    this._contentVisual = new TextBlock(options);\n                    this._contentVisual._includeInBBox = false;\n                    this.visual.append(this._contentVisual);\n                }\n            },\n\n            _updateContentVisual: function(options) {\n                this._contentVisual.redraw(options);\n            },\n\n            _hitTest: function(point) {\n                var bounds = this.bounds();\n                return this.visible() && bounds.contains(point) && this.options.enable;\n            },\n\n            _template: function() {\n                var that = this;\n                if (that.options.content.template) {\n                    var data = that.dataItem || {},\n                        elementTemplate = kendo.template(that.options.content.template, {\n                            paramName: \"dataItem\"\n                        });\n\n                    that.options.content.text = elementTemplate(data);\n                }\n            },\n\n            _canSelect: function() {\n                return this.options.selectable !== false;\n            },\n\n            toJSON: function() {\n                return {\n                    id: this.options.id\n                };\n            }\n        });\n\n        var Connector = Class.extend({\n            init: function(shape, options) {\n                this.options = deepExtend({}, this.options, options);\n                this.connections = [];\n                this.shape = shape;\n            },\n            options: {\n                width: 7,\n                height: 7,\n                fill: {\n                    color: DEFAULT_CONNECTION_BACKGROUND\n                },\n                hover: {}\n            },\n            position: function() {\n                if (this.options.position) {\n                    return this.options.position(this.shape);\n                } else {\n                    return this.shape.getPosition(this.options.name);\n                }\n            },\n            toJSON: function() {\n                return {\n                    shapeId: this.shape.toString(),\n                    connector: this.options.name\n                };\n            }\n        });\n\n        Connector.parse = function(diagram, str) {\n            var tempStr = str.split(\":\"),\n                id = tempStr[0],\n                name = tempStr[1] || AUTO;\n\n            for (var i = 0; i < diagram.shapes.length; i++) {\n                var shape = diagram.shapes[i];\n                if (shape.options.id == id) {\n                    return shape.getConnector(name.trim());\n                }\n            }\n        };\n\n        var Shape = DiagramElement.extend({\n            init: function(options, diagram) {\n                var that = this;\n                DiagramElement.fn.init.call(that, options);\n                this.diagram = diagram;\n                this.updateOptionsFromModel();\n                options = that.options;\n                that.connectors = [];\n                that.type = options.type;\n                that.createShapeVisual();\n                that.updateBounds();\n                that.content(that.content());\n\n                that._createConnectors();\n            },\n\n            options: diagram.shapeDefaults(),\n\n            _setOptionsFromModel: function(model) {\n                var modelOptions = filterShapeDataItem(model || this.dataItem);\n                this.options = deepExtend({}, this.options, modelOptions);\n\n                this.redrawVisual();\n            },\n\n            updateOptionsFromModel: function(model, field) {\n                if (this.diagram && this.diagram._isEditable) {\n                    var modelOptions = filterShapeDataItem(model || this.dataItem);\n\n                    if (model && field) {\n                        if (!dataviz.inArray(field, [\"x\", \"y\", \"width\", \"height\"])) {\n                            if (this.options.visual) {\n                                this._redrawVisual();\n                            } else if (modelOptions.type) {\n                                this.options = deepExtend({}, this.options, modelOptions);\n                                this._redrawVisual();\n                            }\n\n                            if (this.options.content) {\n                                this._template();\n                                this.content(this.options.content);\n                            }\n                        } else {\n                            var bounds = this.bounds();\n                            bounds[field] = model[field];\n                            this.bounds(bounds);\n                        }\n                    } else {\n                        this.options = deepExtend({}, this.options, modelOptions);\n                    }\n                }\n            },\n\n            _redrawVisual: function() {\n                this.visual.clear();\n                this._contentVisual = null;\n                this.options.dataItem = this.dataItem;\n                this.createShapeVisual();\n                this.updateBounds();\n            },\n\n            redrawVisual: function() {\n                this._redrawVisual();\n                if (this.options.content) {\n                    this._template();\n                    this.content(this.options.content);\n                }\n            },\n\n            updateModel: function(syncChanges) {\n                var diagram = this.diagram;\n                if (diagram && diagram._isEditable) {\n                    var bounds = this._bounds;\n                    var model = this.dataItem;\n\n                    if (model) {\n                        diagram._suspendModelRefresh();\n                        if (defined(model.x) && bounds.x !== model.x) {\n                            model.set(\"x\", bounds.x);\n                        }\n\n                        if (defined(model.y) && bounds.y !== model.y) {\n                            model.set(\"y\", bounds.y);\n                        }\n\n                        if (defined(model.width) && bounds.width !== model.width) {\n                            model.set(\"width\", bounds.width);\n                        }\n\n                        if (defined(model.height) && bounds.height !== model.height) {\n                            model.set(\"height\", bounds.height);\n                        }\n\n                        this.dataItem = model;\n                        diagram._resumeModelRefresh();\n\n                        if (syncChanges) {\n                            diagram._syncShapeChanges();\n                        }\n                    }\n                }\n            },\n\n            updateBounds: function() {\n                var bounds = this.visual._measure(true);\n                var options = this.options;\n                this.bounds(new Rect(options.x, options.y, bounds.width, bounds.height));\n                this._rotate();\n                this._alignContent();\n            },\n\n            content: function(content) {\n                var result = this._content(content);\n\n                this._alignContent();\n\n                return result;\n            },\n\n            _alignContent: function() {\n                var contentOptions = this.options.content || {};\n                var contentVisual = this._contentVisual;\n                if (contentVisual && contentOptions.align) {\n                    var containerRect = this.visual._measure();\n                    var aligner = new diagram.RectAlign(containerRect);\n                    var contentBounds = contentVisual.drawingElement.bbox(null);\n\n                    var contentRect = new Rect(0, 0, contentBounds.width(), contentBounds.height());\n                    var alignedBounds = aligner.align(contentRect, contentOptions.align);\n\n                    contentVisual.position(alignedBounds.topLeft());\n                }\n            },\n\n            _createConnectors: function() {\n                var options = this.options,\n                    length = options.connectors.length,\n                    connectorDefaults = options.connectorDefaults,\n                    connector, i;\n\n                for (i = 0; i < length; i++) {\n                    connector = new Connector(\n                        this, deepExtend({},\n                            connectorDefaults,\n                            options.connectors[i]\n                        )\n                    );\n                    this.connectors.push(connector);\n                }\n            },\n\n            bounds: function(value) {\n                var bounds;\n\n                if (value) {\n                    if (isString(value)) {\n                        switch (value) {\n                            case TRANSFORMED :\n                                bounds = this._transformedBounds();\n                                break;\n                            case ABSOLUTE :\n                                bounds = this._transformedBounds();\n                                var pan = this.diagram._pan;\n                                bounds.x += pan.x;\n                                bounds.y += pan.y;\n                                break;\n                            case ROTATED :\n                                bounds = this._rotatedBounds();\n                                break;\n                            default:\n                                bounds = this._bounds;\n                        }\n                    } else {\n                        this._setBounds(value);\n                        this._triggerBoundsChange();\n                        if (!(this.diagram && this.diagram._layouting)) {\n                            this.refreshConnections();\n                        }\n                    }\n                } else {\n                    bounds = this._bounds;\n                }\n\n                return bounds;\n            },\n\n            _setBounds: function(rect) {\n                var options = this.options;\n                var topLeft = rect.topLeft();\n                var x = options.x = topLeft.x;\n                var y = options.y = topLeft.y;\n                var width = options.width = math.max(rect.width, options.minWidth);\n                var height = options.height = math.max(rect.height, options.minHeight);\n\n                this._bounds = new Rect(x, y, width, height);\n\n                this.visual.redraw({\n                    x: x,\n                    y: y,\n                    width: width,\n                    height: height\n                });\n            },\n\n            position: function(point) {\n                if (point) {\n                    this.bounds(new Rect(point.x, point.y, this._bounds.width, this._bounds.height));\n                } else {\n                    return this._bounds.topLeft();\n                }\n            },\n            /**\n             * Returns a clone of this shape.\n             * @returns {Shape}\n             */\n            clone: function() {\n                var json = this.serialize();\n\n                json.options.id = diagram.randomId();\n\n                if (this.diagram && this.diagram._isEditable && defined(this.dataItem)) {\n                    json.options.dataItem = cloneDataItem(this.dataItem);\n                }\n\n                return new Shape(json.options);\n            },\n\n            select: function(value) {\n                var diagram = this.diagram, selected, deselected;\n                if (isUndefined(value)) {\n                    value = true;\n                }\n\n                if (this._canSelect()) {\n                    if (this.isSelected != value) {\n                        selected = [];\n                        deselected = [];\n                        this.isSelected = value;\n                        if (this.isSelected) {\n                            diagram._selectedItems.push(this);\n                            selected.push(this);\n                        } else {\n                            Utils.remove(diagram._selectedItems, this);\n                            deselected.push(this);\n                        }\n\n                        if (!diagram._internalSelection) {\n                            diagram._selectionChanged(selected, deselected);\n                        }\n\n                        return true;\n                    }\n                }\n            },\n\n            rotate: function(angle, center, undoable) { // we assume the center is always the center of the shape.\n                var rotate = this.visual.rotate();\n                if (angle !== undefined$1) {\n                    if (undoable !== false && this.diagram && this.diagram.undoRedoService && angle !== rotate.angle) {\n                        this.diagram.undoRedoService.add(\n                            new diagram.RotateUnit(this.diagram._resizingAdorner, [this], [rotate.angle]), false);\n                    }\n\n                    var b = this.bounds(),\n                        sc = new Point(b.width / 2, b.height / 2),\n                        deltaAngle,\n                        newPosition;\n\n                    if (center) {\n                        deltaAngle = angle - rotate.angle;\n                        newPosition = b.center().rotate(center, 360 - deltaAngle).minus(sc);\n                        this._rotationOffset = this._rotationOffset.plus(newPosition.minus(b.topLeft()));\n                        this.position(newPosition);\n                    }\n\n                    this.visual.rotate(angle, sc);\n                    this.options.rotation.angle = angle;\n\n                    if (this.diagram && this.diagram._connectorsAdorner) {\n                        this.diagram._connectorsAdorner.refresh();\n                    }\n\n                    this.refreshConnections();\n\n                    if (this.diagram) {\n                        this.diagram.trigger(ITEMROTATE, { item: this });\n                    }\n                }\n\n                return rotate;\n            },\n\n            connections: function(type) { // in, out, undefined = both\n                var result = [], i, j, con, cons, ctr;\n\n                for (i = 0; i < this.connectors.length; i++) {\n                    ctr = this.connectors[i];\n                    cons = ctr.connections;\n                    for (j = 0, cons; j < cons.length; j++) {\n                        con = cons[j];\n                        if (type == \"out\") {\n                            var source = con.source();\n                            if (source.shape && source.shape == this) {\n                                result.push(con);\n                            }\n                        } else if (type == \"in\") {\n                            var target = con.target();\n                            if (target.shape && target.shape == this) {\n                                result.push(con);\n                            }\n                        } else {\n                            result.push(con);\n                        }\n                    }\n                }\n\n                return result;\n            },\n\n            refreshConnections: function() {\n                $.each(this.connections(), function() {\n                    this.refresh();\n                });\n            },\n            /**\n             * Gets a connector of this shape either by the connector's supposed name or\n             * via a Point in which case the closest connector will be returned.\n             * @param nameOrPoint The name of a Connector or a Point.\n             * @returns {Connector}\n             */\n            getConnector: function(nameOrPoint) {\n                var i, ctr;\n                if (isString(nameOrPoint)) {\n                    nameOrPoint = nameOrPoint.toLocaleLowerCase();\n                    for (i = 0; i < this.connectors.length; i++) {\n                        ctr = this.connectors[i];\n                        if (ctr.options.name.toLocaleLowerCase() == nameOrPoint) {\n                            return ctr;\n                        }\n                    }\n                } else if (nameOrPoint instanceof Point) {\n                    return closestConnector(nameOrPoint, this.connectors);\n                } else {\n                    return this.connectors.length ? this.connectors[0] : null;\n                }\n            },\n\n            getPosition: function(side) {\n                var b = this.bounds(),\n                    fnName = side.charAt(0).toLowerCase() + side.slice(1);\n\n                if (isFunction(b[fnName])) {\n                    return this._transformPoint(b[fnName]());\n                }\n\n                return b.center();\n            },\n\n            redraw: function(options) {\n                if (options) {\n                    var shapeOptions = this.options;\n                    var boundsChange;\n\n                    this.shapeVisual.redraw(this._visualOptions(options));\n\n                    if (this._diffNumericOptions(options, [WIDTH, HEIGHT, X, Y])) {\n                        this.bounds(new Rect(shapeOptions.x, shapeOptions.y, shapeOptions.width, shapeOptions.height));\n                        boundsChange = true;\n                    }\n\n                    if (options.connectors) {\n                        shapeOptions.connectors = options.connectors;\n                        this._updateConnectors();\n                    }\n\n                    shapeOptions = deepExtend(shapeOptions, options);\n\n                    if (options.rotation || boundsChange) {\n                        this._rotate();\n                    }\n\n                    if (shapeOptions.content) {\n                        this.content(shapeOptions.content);\n                    }\n                }\n            },\n\n            _updateConnectors: function() {\n                var connections = this.connections();\n                this.connectors = [];\n                this._createConnectors();\n                var connection;\n                var source;\n                var target;\n\n                for (var idx = 0; idx < connections.length; idx++) {\n                    connection = connections[idx];\n                    source = connection.source();\n                    target = connection.target();\n                    if (source.shape && source.shape === this) {\n                        connection.source(this.getConnector(source.options.name) || null);\n                    } else if (target.shape && target.shape === this) {\n                        connection.target(this.getConnector(target.options.name) || null);\n                    }\n                    connection.updateModel();\n                }\n            },\n\n            _diffNumericOptions: diagram.diffNumericOptions,\n\n            _visualOptions: function(options) {\n                return {\n                    data: options.path,\n                    source: options.source,\n                    hover: options.hover,\n                    fill: options.fill,\n                    stroke: options.stroke\n                };\n            },\n\n            _triggerBoundsChange: function() {\n                if (this.diagram) {\n                    this.diagram.trigger(ITEMBOUNDSCHANGE, { item: this, bounds: this._bounds.clone() }); // the trigger modifies the arguments internally.\n                }\n            },\n\n            _transformPoint: function(point) {\n                var rotate = this.rotate(),\n                    bounds = this.bounds(),\n                    tl = bounds.topLeft();\n\n                if (rotate.angle) {\n                    point.rotate(rotate.center().plus(tl), 360 - rotate.angle);\n                }\n\n                return point;\n            },\n\n            _transformedBounds: function() {\n                var bounds = this.bounds(),\n                    tl = bounds.topLeft(),\n                    br = bounds.bottomRight();\n\n                return Rect.fromPoints(this.diagram.modelToView(tl), this.diagram.modelToView(br));\n            },\n\n            _rotatedBounds: function() {\n                var bounds = this.bounds().rotatedBounds(this.rotate().angle),\n                    tl = bounds.topLeft(),\n                    br = bounds.bottomRight();\n\n                return Rect.fromPoints(tl, br);\n            },\n\n            _rotate: function() {\n                var rotation = this.options.rotation;\n\n                if (rotation && rotation.angle) {\n                    this.rotate(rotation.angle);\n                }\n\n                this._rotationOffset = new Point();\n            },\n\n            _hover: function(value) {\n                var options = this.options,\n                    hover = options.hover,\n                    stroke = options.stroke,\n                    fill = options.fill;\n\n                if (value && isDefined(hover.stroke)) {\n                    stroke = deepExtend({}, stroke, hover.stroke);\n                }\n\n                if (value && isDefined(hover.fill)) {\n                    fill = hover.fill;\n                }\n\n                this.shapeVisual.redraw({\n                    stroke: stroke,\n                    fill: fill\n                });\n\n                if (options.editable && options.editable.connect) {\n                    this.diagram._showConnectors(this, value);\n                }\n            },\n\n            _hitTest: function(value) {\n                if (this.visible()) {\n                    var bounds = this.bounds(), rotatedPoint,\n                        angle = this.rotate().angle;\n\n                    if (value.isEmpty && !value.isEmpty()) { // rect selection\n                        return Intersect.rects(value, bounds, angle ? angle : 0);\n                    } else { // point\n                        rotatedPoint = value.clone().rotate(bounds.center(), angle); // cloning is important because rotate modifies the point inline.\n                        if (bounds.contains(rotatedPoint)) {\n                            return this;\n                        }\n                    }\n                }\n            },\n\n            toJSON: function() {\n                return {\n                    shapeId: this.options.id\n                };\n            },\n\n            createShapeVisual: function() {\n                var options = this.options;\n                var visualOptions = this._visualOptions(options);\n                var visualTemplate = options.visual;\n                var type = (options.type + \"\").toLocaleLowerCase();\n                var shapeVisual;\n\n                visualOptions.width = options.width;\n                visualOptions.height = options.height;\n\n                if (isFunction(visualTemplate)) { // custom template\n                    shapeVisual = visualTemplate.call(this, options);\n                } else if (visualOptions.data) {\n                    shapeVisual = new Path(visualOptions);\n                    translateToOrigin(shapeVisual);\n                } else if (type == \"rectangle\") {\n                    shapeVisual = new Rectangle(visualOptions);\n                } else if (type == \"circle\") {\n                    shapeVisual = new Circle(visualOptions);\n                } else if (type == \"text\") {\n                    shapeVisual = new TextBlock(visualOptions);\n                } else if (type == \"image\") {\n                    shapeVisual = new Image(visualOptions);\n                } else {\n                    shapeVisual = new Path(visualOptions);\n                }\n\n                this.shapeVisual = shapeVisual;\n                this.visual.append(this.shapeVisual);\n            }\n        });\n\n        /**\n         * The visual link between two Shapes through the intermediate of Connectors.\n         */\n        var Connection = DiagramElement.extend({\n            init: function(from, to, options) {\n                var that = this;\n                DiagramElement.fn.init.call(that, options);\n                this.updateOptionsFromModel();\n                this._initRouter();\n                that.path = new diagram.Polyline(that.options);\n                that.path.fill(TRANSPARENT);\n                that.visual.append(that.path);\n                that._sourcePoint = that._targetPoint = new Point();\n                that._setSource(from);\n                that._setTarget(to);\n                that.content(that.options.content);\n                that.definers = [];\n                if (defined(options) && options.points) {\n                    that.points(options.points);\n                }\n            },\n\n            options: {\n                hover: {\n                    stroke: {}\n                },\n                startCap: NONE,\n                endCap: NONE,\n                points: [],\n                selectable: true,\n                fromConnector: AUTO,\n                toConnector: AUTO\n            },\n\n            _setOptionsFromModel: function(model) {\n                this.updateOptionsFromModel(model || this.dataItem);\n            },\n\n            updateOptionsFromModel: function(model) {\n                if (this.diagram && this.diagram._isEditable) {\n                    var dataMap = this.diagram._dataMap;\n                    var options = filterConnectionDataItem(model || this.dataItem);\n\n                    if (model) {\n                        if (defined(options.from)) {\n                            var from = dataMap[options.from];\n                            if (from && defined(options.fromConnector)) {\n                               from = from.getConnector(options.fromConnector);\n                            }\n                            this.source(from);\n                        } else if (defined(options.fromX) && defined(options.fromY)) {\n                            this.source(new Point(options.fromX, options.fromY));\n                        }\n\n                        if (defined(options.to)) {\n                            var to = dataMap[options.to];\n                            if (to && defined(options.toConnector)) {\n                                to = to.getConnector(options.toConnector);\n                            }\n                            this.target(to);\n                        } else if (defined(options.toX) && defined(options.toY)) {\n                            this.target(new Point(options.toX, options.toY));\n                        }\n\n                        if (defined(options.type) && this.type() !== options.type) {\n                            this.points([]);\n                            this.type(options.type);\n                        }\n\n                        this.dataItem = model;\n\n                        this._template();\n                        this.redraw(this.options);\n                    } else {\n                        this.options = deepExtend({}, options, this.options);\n                    }\n                }\n            },\n\n            updateModel: function(syncChanges) {\n                if (this.diagram && this.diagram._isEditable) {\n                    if (this.diagram.connectionsDataSource) {\n                        var model = this.diagram.connectionsDataSource.getByUid(this.dataItem.uid);\n\n                        if (model) {\n                            this.diagram._suspendModelRefresh();\n                            if (defined(this.options.fromX) && this.options.fromX !== null) {\n                                clearField(\"from\", model);\n                                clearField(\"fromConnector\", model);\n                                model.set(\"fromX\", this.options.fromX);\n                                model.set(\"fromY\", this.options.fromY);\n                            } else {\n                                model.set(\"from\", this.options.from);\n                                if (defined(model.fromConnector)) {\n                                    model.set(\"fromConnector\", this.sourceConnector ? this.sourceConnector.options.name : null);\n                                }\n                                clearField(\"fromX\", model);\n                                clearField(\"fromY\", model);\n                            }\n\n                            if (defined(this.options.toX) && this.options.toX !== null) {\n                                clearField(\"to\", model);\n                                clearField(\"toConnector\", model);\n                                model.set(\"toX\", this.options.toX);\n                                model.set(\"toY\", this.options.toY);\n                            } else {\n                                model.set(\"to\", this.options.to);\n                                if (defined(model.toConnector)) {\n                                    model.set(\"toConnector\", this.targetConnector ? this.targetConnector.options.name : null);\n                                }\n                                clearField(\"toX\", model);\n                                clearField(\"toY\", model);\n                            }\n\n                            if (defined(this.options.type) && defined(model.type)) {\n                                model.set(\"type\", this.options.type);\n                            }\n\n                            this.dataItem = model;\n                            this.diagram._resumeModelRefresh();\n\n                            if (syncChanges) {\n                                this.diagram._syncConnectionChanges();\n                            }\n                        }\n                    }\n                }\n            },\n\n            /**\n             * Gets the Point where the source of the connection resides.\n             * If the endpoint in Auto-connector the location of the resolved connector will be returned.\n             * If the endpoint is floating the location of the endpoint is returned.\n             */\n            sourcePoint: function() {\n                return this._resolvedSourceConnector ? this._resolvedSourceConnector.position() : this._sourcePoint;\n            },\n\n            _setSource: function(source) {\n                var shapeSource = source instanceof Shape;\n                var defaultConnector = this.options.fromConnector || AUTO;\n                var dataItem;\n                if (shapeSource && !source.getConnector(defaultConnector)) {\n                    return;\n                }\n\n                if (source !== undefined$1) {\n                    this.from = source;\n                }\n\n                this._removeFromSourceConnector();\n\n                if (source === null) { // detach\n                    if (this.sourceConnector) {\n                        this._sourcePoint = (this._resolvedSourceConnector || this.sourceConnector).position();\n                        this._clearSourceConnector();\n                        this._setFromOptions(null, this._sourcePoint);\n                    }\n                } else if (source instanceof Connector) {\n                    dataItem = source.shape.dataItem;\n                    if (dataItem) {\n                        this._setFromOptions(dataItem.id);\n                    }\n                    this.sourceConnector = source;\n                    this.sourceConnector.connections.push(this);\n                } else if (source instanceof Point) {\n                    this._setFromOptions(null, source);\n                    this._sourcePoint = source;\n                    if (this.sourceConnector) {\n                        this._clearSourceConnector();\n                    }\n\n                } else if (shapeSource) {\n                    dataItem = source.dataItem;\n                    if (dataItem) {\n                        this._setFromOptions(dataItem.id);\n                    }\n\n                    this.sourceConnector = source.getConnector(defaultConnector);\n                    this.sourceConnector.connections.push(this);\n                }\n            },\n\n            source: function(source, undoable) {\n                if (isDefined(source)) {\n                    if (undoable && this.diagram) {\n                        this.diagram.undoRedoService.addCompositeItem(new diagram.ConnectionEditUnit(this, source));\n                    }\n                    this._setSource(source);\n                    this.refresh();\n                }\n                return this.sourceConnector ? this.sourceConnector : this._sourcePoint;\n            },\n\n            _setFromOptions: function(from, fromPoint) {\n                this.options.from = from;\n                if (fromPoint) {\n                    this.options.fromX = fromPoint.x;\n                    this.options.fromY = fromPoint.y;\n                } else {\n                    this.options.fromX = null;\n                    this.options.fromY = null;\n                }\n            },\n\n            /**\n             * Gets or sets the PathDefiner of the sourcePoint.\n             * The left part of this definer is always null since it defines the source tangent.\n             * @param value\n             * @returns {*}\n             */\n            sourceDefiner: function(value) {\n                if (value) {\n                    if (value instanceof diagram.PathDefiner) {\n                        value.left = null;\n                        this._sourceDefiner = value;\n                        this.source(value.point); // refresh implicit here\n                    } else {\n                        throw \"The sourceDefiner needs to be a PathDefiner.\";\n                    }\n                } else {\n                    if (!this._sourceDefiner) {\n                        this._sourceDefiner = new diagram.PathDefiner(this.sourcePoint(), null, null);\n                    }\n                    return this._sourceDefiner;\n                }\n            },\n\n            /**\n             * Gets  the Point where the target of the connection resides.\n             */\n            targetPoint: function() {\n                return this._resolvedTargetConnector ? this._resolvedTargetConnector.position() : this._targetPoint;\n            },\n\n            _setTarget: function(target) {\n                var shapeTarget = target instanceof Shape;\n                var defaultConnector = this.options.toConnector || AUTO;\n                var dataItem;\n\n                if (shapeTarget && !target.getConnector(defaultConnector)) {\n                    return;\n                }\n\n                if (target !== undefined$1) {\n                    this.to = target;\n                }\n\n                this._removeFromTargetConnector();\n\n                if (target === null) { // detach\n                    if (this.targetConnector) {\n                        this._targetPoint = (this._resolvedTargetConnector || this.targetConnector).position();\n                        this._clearTargetConnector();\n                        this._setToOptions(null, this._targetPoint);\n                    }\n                } else if (target instanceof Connector) {\n                    dataItem = target.shape.dataItem;\n                    if (dataItem) {\n                        this._setToOptions(dataItem.id);\n                    }\n                    this.targetConnector = target;\n                    this.targetConnector.connections.push(this);\n                } else if (target instanceof Point) {\n                    this._setToOptions(null, target);\n                    this._targetPoint = target;\n                    if (this.targetConnector) {\n                        this._clearTargetConnector();\n                    }\n                } else if (shapeTarget) {\n                    dataItem = target.dataItem;\n                    if (dataItem) {\n                        this._setToOptions(dataItem.id);\n                    }\n                    this.targetConnector = target.getConnector(defaultConnector);\n                    this.targetConnector.connections.push(this);\n                }\n            },\n\n            target: function(target, undoable) {\n                if (isDefined(target)) {\n                    if (undoable && this.diagram) {\n                        this.diagram.undoRedoService.addCompositeItem(new diagram.ConnectionEditUnit(this, undefined$1, target));\n                    }\n                    this._setTarget(target);\n\n                    this.refresh();\n                }\n                return this.targetConnector ? this.targetConnector : this._targetPoint;\n            },\n\n            _setToOptions: function(to, toPoint) {\n                this.options.to = to;\n                if (toPoint) {\n                    this.options.toX = toPoint.x;\n                    this.options.toY = toPoint.y;\n                } else {\n                    this.options.toX = null;\n                    this.options.toY = null;\n                }\n            },\n\n            /**\n             * Gets or sets the PathDefiner of the targetPoint.\n             * The right part of this definer is always null since it defines the target tangent.\n             * @param value\n             * @returns {*}\n             */\n            targetDefiner: function(value) {\n                if (value) {\n                    if (value instanceof diagram.PathDefiner) {\n                        value.right = null;\n                        this._targetDefiner = value;\n                        this.target(value.point); // refresh implicit here\n                    } else {\n                        throw \"The sourceDefiner needs to be a PathDefiner.\";\n                    }\n                } else {\n                    if (!this._targetDefiner) {\n                        this._targetDefiner = new diagram.PathDefiner(this.targetPoint(), null, null);\n                    }\n                    return this._targetDefiner;\n                }\n            },\n\n            _updateConnectors: function() {\n                this._updateConnector(this.source(), \"source\");\n                this._updateConnector(this.target(), \"target\");\n            },\n\n            _updateConnector: function(instance, name) {\n                var that = this;\n                var diagram = that.diagram;\n                if (instance instanceof Connector && !diagram.getShapeById(instance.shape.id)) {\n                    var dataItem = instance.shape.dataItem;\n                    var connectorName = instance.options.name;\n                    var setNewTarget = function() {\n                        var shape = diagram._dataMap[dataItem.id];\n                        instance = shape.getConnector(connectorName);\n                        that[name](instance, false);\n                        that.updateModel();\n                    };\n                    if (diagram._dataMap[dataItem.id]) {\n                       setNewTarget();\n                    } else {\n                        var inactiveItem = diagram._inactiveShapeItems.getByUid(dataItem.uid);\n                        if (inactiveItem) {\n                            diagram._deferredConnectionUpdates.push(inactiveItem.onActivate(setNewTarget));\n                        }\n                    }\n                } else {\n                    that[name](instance, false);\n                }\n            },\n\n            content: function(content) {\n                var result = this._content(content);\n                if (defined(content)) {\n                    this._alignContent();\n                }\n                return result;\n            },\n\n            _createContentVisual: function(options) {\n                var visual;\n                if (isFunction(options.visual)) {\n                    visual = options.visual.call(this, options);\n                } else if (options.text) {\n                    visual = new TextBlock(options);\n                }\n\n                if (visual) {\n                    this._contentVisual = visual;\n                    visual._includeInBBox = false;\n                    this.visual.append(visual);\n                }\n\n                return visual;\n            },\n\n            _updateContentVisual: function(options) {\n                if (isFunction(options.visual)) {\n                    this.visual.remove(this._contentVisual);\n                    this._createContentVisual(options);\n                } else {\n                    this._contentVisual.redraw(options);\n                }\n            },\n\n            _alignContent: function() {\n                if (this._contentVisual) {\n                    var offset = CONNECTION_CONTENT_OFFSET;\n                    var points = this.allPoints();\n                    var endIdx = math.floor(points.length / 2);\n                    var startIdx = endIdx - 1;\n\n                    while (startIdx > 0 && points[startIdx].equals(points[endIdx])) {\n                        startIdx--;\n                        endIdx++;\n                    }\n\n                    var endPoint = points[endIdx];\n                    var startPoint = points[startIdx];\n\n                    var boundingBox = this._contentVisual._measure();\n                    var width = boundingBox.width;\n                    var height = boundingBox.height;\n                    var alignToPath = points.length % 2 === 0;\n                    var distance = startPoint.distanceTo(endPoint);\n\n                    if (alignToPath && points.length > 2 && distance > 0 &&\n                        ((startPoint.y === endPoint.y && distance < width) || (startPoint.x === endPoint.x && distance < height))) {\n                        alignToPath = false;\n                        offset = 0;\n                    }\n\n                    var point;\n\n                    if (alignToPath) {\n                        var angle = draw.util.deg(math.atan2(endPoint.y - startPoint.y, endPoint.x - startPoint.x));\n                        point = new Point((endPoint.x - startPoint.x) / 2 + startPoint.x, (endPoint.y - startPoint.y) / 2 + startPoint.y);\n\n                        if (math.abs(angle) === 90) {\n                            point.x += offset;\n                            point.y -= height / 2;\n                        } else if (angle % 180 === 0) {\n                            point.x -= width / 2;\n                            point.y -= height + offset;\n                        } else if (angle < -90 || (0 < angle && angle < 90)) {\n                            point.y -= height;\n                        } else if (angle < 0 || angle > 90) {\n                            point.x -= width;\n                            point.y -= height;\n                        }\n                    } else {\n                        var midIdx = math.floor(points.length / 2);\n                        point = points[midIdx].clone();\n                        startPoint = points[midIdx - 1];\n                        endPoint = points[midIdx + 1];\n\n                        var offsetX = startPoint.x <= point.x && endPoint.x <= point.x ? offset : -boundingBox.width - offset;\n                        var offsetY = startPoint.y <= point.y && endPoint.y <= point.y ? offset : -boundingBox.height - offset;\n\n                        point.x += offsetX;\n                        point.y += offsetY;\n                    }\n\n                    this._contentVisual.position(point);\n                }\n            },\n\n            /**\n             * Selects or unselects this connections.\n             * @param value True to select, false to unselect.\n             */\n            select: function(value) {\n                var diagram = this.diagram, selected, deselected;\n                if (this._canSelect()) {\n                    if (this.isSelected !== value) {\n                        this.isSelected = value;\n                        selected = [];\n                        deselected = [];\n                        if (this.isSelected) {\n                            this.adorner = new ConnectionEditAdorner(this, this.options.selection);\n                            diagram._adorn(this.adorner, true);\n                            diagram._selectedItems.push(this);\n                            selected.push(this);\n                        } else {\n                            if (this.adorner) {\n                                diagram._adorn(this.adorner, false);\n                                Utils.remove(diagram._selectedItems, this);\n                                this.adorner = undefined$1;\n                                deselected.push(this);\n                            }\n                        }\n\n                        if (this.adorner) {\n                            this.adorner.refresh();\n                        }\n\n                        if (!diagram._internalSelection) {\n                            diagram._selectionChanged(selected, deselected);\n                        }\n                        return true;\n                    }\n                }\n            },\n            /**\n             * Gets or sets the bounds of this connection.\n             * @param value A Rect object.\n             * @remark This is automatically set in the refresh().\n             * @returns {Rect}\n             */\n            bounds: function(value) {\n                if (value && !isString(value)) {\n                    this._bounds = value;\n                } else {\n                    return this._bounds;\n                }\n            },\n            /**\n             * Gets or sets the connection type (see ConnectionType enumeration).\n             * @param value A ConnectionType value.\n             * @returns {ConnectionType}\n             */\n            type: function(value) {\n                var options = this.options;\n                if (value) {\n                    if (value !== options.type) {\n                        options.type = value;\n                        this._initRouter();\n                        this.refresh();\n                    }\n                } else {\n                    return options.type;\n                }\n            },\n\n            _initRouter: function() {\n                var type = (this.options.type || \"\").toLowerCase();\n                if (type == CASCADING) {\n                    this._router = new CascadingRouter(this);\n                } else {\n                    this._router = new PolylineRouter(this);\n                }\n            },\n            /**\n             * Gets or sets the collection of *intermediate* points.\n             * The 'allPoints()' property will return all the points.\n             * The 'definers' property returns the definers of the intermediate points.\n             * The 'sourceDefiner' and 'targetDefiner' return the definers of the endpoints.\n             * @param value\n             */\n            points: function(value) {\n                if (value) {\n                    this.definers = [];\n                    for (var i = 0; i < value.length; i++) {\n                        var definition = value[i];\n                        if (definition instanceof diagram.Point) {\n                            this.definers.push(new diagram.PathDefiner(definition));\n                        } else if (definition.hasOwnProperty(\"x\") && definition.hasOwnProperty(\"y\")) { // e.g. Clipboard does not preserve the Point definition and tunred into an Object\n                            this.definers.push(new diagram.PathDefiner(new Point(definition.x, definition.y)));\n                        } else {\n                            throw \"A Connection point needs to be a Point or an object with x and y properties.\";\n                        }\n                    }\n\n                } else {\n                    var pts = [];\n                    if (isDefined(this.definers)) {\n                        for (var k = 0; k < this.definers.length; k++) {\n                            pts.push(this.definers[k].point);\n                        }\n                    }\n                    return pts;\n                }\n            },\n            /**\n             * Gets all the points of this connection. This is the combination of the sourcePoint, the points and the targetPoint.\n             * @returns {Array}\n             */\n            allPoints: function() {\n                var pts = [this.sourcePoint()];\n                if (this.definers) {\n                    for (var k = 0; k < this.definers.length; k++) {\n                        pts.push(this.definers[k].point);\n                    }\n                }\n                pts.push(this.targetPoint());\n                return pts;\n            },\n\n            refresh: function() {\n                this._resolveConnectors();\n                this._refreshPath();\n                this._alignContent();\n\n                if (this.adorner) {\n                    this.adorner.refresh();\n                }\n            },\n\n            _resolveConnectors: function() {\n                var connection = this,\n                    sourcePoint, targetPoint,\n                    sourceConnectors, targetConnectors,\n                    source = connection.source(),\n                    target = connection.target();\n\n                if (source instanceof Point) {\n                    sourcePoint = source;\n                } else if (source instanceof Connector) {\n                    if (isAutoConnector(source)) {\n                        sourceConnectors = source.shape.connectors;\n                    } else {\n                        sourceConnectors = [source];\n                    }\n                }\n\n                if (target instanceof Point) {\n                    targetPoint = target;\n                } else if (target instanceof Connector) {\n                    if (isAutoConnector(target)) {\n                        targetConnectors = target.shape.connectors;\n                    } else {\n                        targetConnectors = [target];\n                    }\n                }\n\n                if (sourcePoint) {\n                    if (targetConnectors) {\n                        connection._resolvedTargetConnector = closestConnector(sourcePoint, targetConnectors);\n                    }\n                } else if (sourceConnectors) {\n                    if (targetPoint) {\n                        connection._resolvedSourceConnector = closestConnector(targetPoint, sourceConnectors);\n                    } else if (targetConnectors) {\n                        this._resolveAutoConnectors(sourceConnectors, targetConnectors);\n                    }\n                }\n            },\n\n            _resolveAutoConnectors: function(sourceConnectors, targetConnectors) {\n                var minNonConflict = MAXINT;\n                var minDist = MAXINT;\n                var minNonConflictSource, minNonConflictTarget;\n                var sourcePoint, targetPoint;\n                var minSource, minTarget;\n                var sourceConnector, targetConnector;\n                var sourceIdx, targetIdx;\n                var dist;\n\n                for (sourceIdx = 0; sourceIdx < sourceConnectors.length; sourceIdx++) {\n                    sourceConnector = sourceConnectors[sourceIdx];\n                    if (!isAutoConnector(sourceConnector)) {\n                        sourcePoint = sourceConnector.position();\n\n                        for (targetIdx = 0; targetIdx < targetConnectors.length; targetIdx++) {\n                            targetConnector = targetConnectors[targetIdx];\n                            if (!isAutoConnector(targetConnector)) {\n                                targetPoint = targetConnector.position();\n                                dist = math.round(sourcePoint.distanceTo(targetPoint));\n\n                                if (dist < minNonConflict && this.diagram && this._testRoutePoints(sourcePoint, targetPoint, sourceConnector, targetConnector)) {\n                                    minNonConflict = dist;\n                                    minNonConflictSource = sourceConnector;\n                                    minNonConflictTarget = targetConnector;\n                                }\n\n                                if (dist < minDist) {\n                                    minSource = sourceConnector;\n                                    minTarget = targetConnector;\n                                    minDist = dist;\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (minNonConflictSource) {\n                    minSource = minNonConflictSource;\n                    minTarget = minNonConflictTarget;\n                }\n\n                this._resolvedSourceConnector = minSource;\n                this._resolvedTargetConnector = minTarget;\n            },\n\n            _testRoutePoints: function(sourcePoint, targetPoint, sourceConnector, targetConnector) {\n                var router = this._router;\n                var passRoute = true;\n                if (router instanceof CascadingRouter) {\n                    var points = router.routePoints(sourcePoint, targetPoint, sourceConnector, targetConnector),\n                        start, end,\n                         rect, exclude;\n\n                    exclude = this._getRouteExclude(sourcePoint, targetPoint, sourceConnector.shape, targetConnector.shape);\n                    points.unshift(sourcePoint);\n                    points.push(targetPoint);\n\n\n                    for (var idx = 1; idx < points.length; idx++) {\n                        start = points[idx - 1];\n                        end = points[idx];\n                        rect = new Rect(math.min(start.x, end.x), math.min(start.y, end.y),\n                                        math.abs(start.x - end.x), math.abs(start.y - end.y));\n                        if (rect.width > 0) {\n                            rect.x++;\n                            rect.width -= 2;\n                        }\n                        if (rect.height > 0) {\n                            rect.y++;\n                            rect.height -= 2;\n                        }\n\n                        if (!rect.isEmpty() && this.diagram._shapesQuadTree.hitTestRect(rect, exclude)) {\n                            passRoute = false;\n                            break;\n                        }\n                    }\n                }\n                return passRoute;\n            },\n\n            _getRouteExclude: function(sourcePoint, targetPoint, sourceShape, targetShape) {\n                var exclude = [];\n                if (this._isPointInsideShape(sourcePoint, sourceShape)) {\n                    exclude.push(sourceShape);\n                }\n                if (this._isPointInsideShape(targetPoint, targetShape)) {\n                    exclude.push(targetShape);\n                }\n                return exclude;\n            },\n\n            _isPointInsideShape: function(point, shape) {\n                var bounds = shape.bounds(), rotatedPoint,\n                    angle = shape.rotate().angle,\n                    pointX, pointY,\n                    boundsX = bounds.x,\n                    boundsY = bounds.y;\n\n                rotatedPoint = point.clone().rotate(bounds.center(), angle);\n                pointX = rotatedPoint.x;\n                pointY = rotatedPoint.y;\n                return pointX > boundsX && pointX < (boundsX + bounds.width) && pointY > boundsY && pointY < (boundsY + bounds.height);\n            },\n\n            redraw: function(options) {\n                if (options) {\n                    this.options = deepExtend({}, this.options, options);\n\n                    var points = this.options.points;\n\n                    if (defined(points) && points.length > 0) {\n                        this.points(points);\n                        this._refreshPath();\n                    }\n\n                    if ((options && options.content) || options.text) {\n                        this.content(options.content);\n                    }\n\n                    this.path.redraw({\n                        fill: options.fill,\n                        stroke: options.stroke,\n                        startCap: options.startCap,\n                        endCap: options.endCap\n                    });\n                }\n            },\n            /**\n             * Returns a clone of this connection.\n             * @returns {Connection}\n             */\n            clone: function() {\n                var json = this.serialize();\n\n                if (this.diagram && this.diagram._isEditable && defined(this.dataItem)) {\n                    json.options.dataItem = cloneDataItem(this.dataItem);\n                }\n\n                return new Connection(this.from, this.to, json.options);\n            },\n            /**\n             * Returns a serialized connection in json format. Consist of the options and the dataItem.\n             * @returns {Connection}\n             */\n            serialize: function() {\n                var from = this.from.toJSON ? this.from.toJSON : this.from.toString(),\n                    to = this.to.toJSON ? this.to.toJSON : this.to.toString();\n\n                var json = deepExtend({}, {\n                    options: this.options,\n                    from: from,\n                    to: to\n                });\n\n                if (defined(this.dataItem)) {\n                    json.dataItem = this.dataItem.toString();\n                }\n\n                json.options.points = this.points();\n                return json;\n            },\n\n            /**\n             * Returns whether the given Point or Rect hits this connection.\n             * @param value\n             * @returns {Connection}\n             * @private\n             */\n            _hitTest: function(value) {\n                if (this.visible()) {\n                    var p = new Point(value.x, value.y), from = this.sourcePoint(), to = this.targetPoint();\n                    if (value.isEmpty && !value.isEmpty() && value.contains(from) && value.contains(to)) {\n                        return this;\n                    }\n                    if (this._router.hitTest(p)) {\n                        return this;\n                    }\n                }\n            },\n\n            _hover: function(value) {\n                var color = (this.options.stroke || {}).color;\n\n                if (value && isDefined(this.options.hover.stroke.color)) {\n                    color = this.options.hover.stroke.color;\n                }\n\n                this.path.redraw({\n                    stroke: {\n                        color: color\n                    }\n                });\n            },\n\n            _refreshPath: function() {\n                if (!defined(this.path)) {\n                    return;\n                }\n                this._drawPath();\n                this.bounds(this._router.getBounds());\n            },\n\n            _drawPath: function() {\n                if (this._router) {\n                    this._router.route(); // sets the intermediate points\n                }\n                var source = this.sourcePoint();\n                var target = this.targetPoint();\n                var points = this.points();\n\n                this.path.redraw({\n                    points: [source].concat(points, [target])\n                });\n            },\n\n            _clearSourceConnector: function() {\n                this.sourceConnector = undefined$1;\n                this._resolvedSourceConnector = undefined$1;\n            },\n\n            _clearTargetConnector: function() {\n                this.targetConnector = undefined$1;\n                this._resolvedTargetConnector = undefined$1;\n            },\n\n            _removeFromSourceConnector: function() {\n                if (this.sourceConnector) {\n                    Utils.remove(this.sourceConnector.connections, this);\n                }\n            },\n\n            _removeFromTargetConnector: function() {\n                if (this.targetConnector) {\n                    Utils.remove(this.targetConnector.connections, this);\n                }\n            },\n\n            toJSON: function() {\n                var connection = this;\n                var from, to, point;\n                if (connection.from && connection.from.toJSON) {\n                    from = connection.from.toJSON();\n                } else {\n                    point = connection._sourcePoint;\n                    from = {\n                        x: point.x,\n                        y: point.y\n                    };\n                }\n\n                if (connection.to && connection.to.toJSON) {\n                    to = connection.to.toJSON();\n                } else {\n                    point = connection._targetPoint;\n                    to = {\n                        x: point.x,\n                        y: point.y\n                    };\n                }\n\n                return {\n                    from: from,\n                    to: to\n                };\n            }\n        });\n\n        var Diagram = Widget.extend({\n            init: function(element, userOptions) {\n                var that = this;\n\n                kendo.destroy(element);\n                Widget.fn.init.call(that, element, userOptions);\n\n                that._initTheme();\n\n                that._initElements();\n                that._extendLayoutOptions(that.options);\n                that._initDefaults(userOptions);\n                that._interactionDefaults();\n\n                that._initCanvas();\n\n                that.mainLayer = new Group({\n                    id: \"main-layer\"\n                });\n                that.canvas.append(that.mainLayer);\n\n                that._shapesQuadTree = new ShapesQuadTree(that);\n\n                that._pan = new Point();\n                that._adorners = [];\n                that.adornerLayer = new Group({\n                    id: \"adorner-layer\"\n                });\n                that.canvas.append(that.adornerLayer);\n\n                that._createHandlers();\n\n                that._initialize();\n\n                that._resizingAdorner = new ResizingAdorner(that, { editable: that.options.editable });\n                that._connectorsAdorner = new ConnectorsAdorner(that);\n\n                that._adorn(that._resizingAdorner, true);\n                that._adorn(that._connectorsAdorner, true);\n\n                that.selector = new Selector(that);\n                // TODO: We may consider using real Clipboard API once is supported by the standard.\n                that._clipboard = [];\n\n                that.pauseMouseHandlers = false;\n\n                that._fetchFreshData();\n\n                that._createGlobalToolBar();\n\n                that._createOptionElements();\n\n                that.zoom(that.options.zoom);\n\n                that.canvas.draw();\n            },\n\n            options: {\n                name: \"Diagram\",\n                theme: \"sass\",\n                layout: \"\",\n                zoomRate: 0.1,\n                zoom: 1,\n                zoomMin: 0,\n                zoomMax: 2,\n                dataSource: {},\n                draggable: true,\n                template: \"\",\n                autoBind: true,\n                editable: {\n                    rotate: {},\n                    resize: {},\n                    text: true,\n                    tools: [],\n                    drag: {\n                        snap: {\n                            size: 10,\n                            angle: 10\n                        }\n                    },\n                    remove: true\n                },\n                pannable: {},\n                selectable: {\n                    key: \"none\"\n                },\n                tooltip: { enabled: true, format: \"{0}\" },\n                copy: {\n                    enabled: true,\n                    offsetX: 20,\n                    offsetY: 20\n                },\n                shapeDefaults: diagram.shapeDefaults({ undoable: true }),\n                connectionDefaults: {\n                    editable: {\n                        tools: []\n                    },\n                    type: CASCADING\n                },\n                shapes: [],\n                connections: []\n            },\n\n            events: [\n                ZOOM_END,\n                ZOOM_START,\n                PAN, SELECT,\n                ITEMROTATE,\n                ITEMBOUNDSCHANGE,\n                CHANGE,\n                CLICK,\n                MOUSE_ENTER,\n                MOUSE_LEAVE,\n                \"toolBarClick\",\n                \"save\",\n                \"cancel\",\n                \"edit\",\n                \"remove\",\n                \"add\",\n                \"dataBound\",\n                DRAG_START,\n                DRAG,\n                DRAG_END\n            ],\n\n            items: function() {\n                return $();\n            },\n\n            _createGlobalToolBar: function() {\n                var editable = this.options.editable;\n                if (editable) {\n                    var tools = editable.tools;\n                    if (this._isEditable && tools !== false && (!tools || tools.length === 0)) {\n                        tools = [\"createShape\", \"undo\", \"redo\", \"rotateClockwise\", \"rotateAnticlockwise\"];\n                    }\n\n                    if (tools && tools.length) {\n                        this.toolBar = new DiagramToolBar(this, {\n                            tools: tools || {},\n                            click: this._toolBarClick.bind(this),\n                            modal: false\n                        });\n\n                        this.toolBar.element.css({\n                            textAlign: \"left\"\n                        });\n\n                        this.element.prepend(this.toolBar.element);\n                        this._resize();\n                    }\n                }\n            },\n\n            createShape: function() {\n                if ((this.editor && this.editor.end()) || !this.editor) {\n                    var dataSource = this.dataSource;\n                    var view = dataSource.view() || [];\n                    var index = view.length;\n                    var model = createModel(dataSource, {});\n                    var shape = this._createShape(model, {});\n\n                    if (!this.trigger(\"add\", { shape: shape })) {\n                        dataSource.insert(index, model);\n                        var inactiveItem = this._inactiveShapeItems.getByUid(model.uid);\n                        inactiveItem.element = shape;\n                        this.edit(shape);\n                    }\n                }\n            },\n\n            _createShape: function(dataItem, options) {\n                options = deepExtend({}, this.options.shapeDefaults, options);\n                options.dataItem = dataItem;\n                var shape = new Shape(options, this);\n                return shape;\n            },\n\n            createConnection: function() {\n                if (((this.editor && this.editor.end()) || !this.editor)) {\n                    var connectionsDataSource = this.connectionsDataSource;\n                    var view = connectionsDataSource.view() || [];\n                    var index = view.length;\n                    var model = createModel(connectionsDataSource, {});\n                    var connection = this._createConnection(model);\n                    if (!this.trigger(\"add\", { connection: connection })) {\n                        this._connectionsDataMap[model.uid] = connection;\n                        connectionsDataSource.insert(index, model);\n                        this.addConnection(connection, false);\n                        this.edit(connection);\n                    }\n                }\n            },\n\n            _createConnection: function(dataItem, source, target) {\n                var options = deepExtend({}, this.options.connectionDefaults);\n                options.dataItem = dataItem;\n\n                var connection = new Connection(source || new Point(), target || new Point(), options);\n\n                return connection;\n            },\n\n            editModel: function(dataItem, editorType) {\n                this.cancelEdit();\n                var editors, template;\n                var editable = this.options.editable;\n\n                if (editorType == \"shape\") {\n                    editors = editable.shapeEditors;\n                    template = editable.shapeTemplate;\n                } else if (editorType == \"connection\") {\n                    var connectionSelectorHandler = connectionSelector.bind(this);\n                    editors = deepExtend({}, { from: connectionSelectorHandler, to: connectionSelectorHandler }, editable.connectionEditors);\n                    template = editable.connectionTemplate;\n                } else {\n                    return;\n                }\n\n                this.editor = new PopupEditor(this.element, {\n                    update: this._update.bind(this),\n                    cancel: this._cancel.bind(this),\n                    model: dataItem,\n                    type: editorType,\n                    target: this,\n                    editors: editors,\n                    template: template\n                });\n\n                this.trigger(\"edit\", this._editArgs());\n            },\n\n            edit: function(item) {\n                if (item.dataItem) {\n                    var editorType = item instanceof Shape ? \"shape\" : \"connection\";\n                    this.editModel(item.dataItem, editorType);\n                }\n            },\n\n            cancelEdit: function() {\n                if (this.editor) {\n                    this._getEditDataSource().cancelChanges(this.editor.model);\n\n                    this._destroyEditor();\n                }\n            },\n\n            saveEdit: function() {\n                if (this.editor && this.editor.end() &&\n                    !this.trigger(\"save\", this._editArgs())) {\n                    this._getEditDataSource().sync();\n                }\n            },\n\n            _update: function() {\n                if (this.editor && this.editor.end() &&\n                    !this.trigger(\"save\", this._editArgs())) {\n                    this._getEditDataSource().sync();\n                    this._destroyEditor();\n                }\n            },\n\n            _cancel: function() {\n                if (this.editor && !this.trigger(\"cancel\", this._editArgs())) {\n                    var model = this.editor.model;\n                    this._getEditDataSource().cancelChanges(model);\n                    var element = this._connectionsDataMap[model.uid] || this._dataMap[model.id];\n                    if (element) {\n                        element._setOptionsFromModel(model);\n                    }\n                    this._destroyEditor();\n                }\n            },\n\n            _getEditDataSource: function() {\n                return this.editor.options.type === \"shape\" ? this.dataSource : this.connectionsDataSource;\n            },\n\n            _editArgs: function() {\n                var result = { container: this.editor.wrapper };\n                result[this.editor.options.type] = this.editor.model;\n                return result;\n            },\n\n            _destroyEditor: function() {\n                if (this.editor) {\n                    this.editor.close();\n                    this.editor = null;\n                }\n            },\n\n            _initElements: function() {\n                this.wrapper = this.element.empty()\n                    .css(\"position\", \"relative\")\n                    .attr(\"tabindex\", 0)\n                    .addClass(\"k-widget k-diagram\");\n\n                this.scrollable = $(\"<div />\").appendTo(this.element);\n            },\n\n            _initDefaults: function(userOptions) {\n                var options = this.options;\n                var editable = options.editable;\n                var shapeDefaults = options.shapeDefaults;\n                var connectionDefaults = options.connectionDefaults;\n                var userShapeDefaults = (userOptions || {}).shapeDefaults;\n                if (editable === false) {\n                    shapeDefaults.editable = false;\n                    connectionDefaults.editable = false;\n                } else {\n                    copyDefaultOptions(editable, shapeDefaults.editable, [\"drag\", \"remove\", \"connect\"]);\n                    copyDefaultOptions(editable, connectionDefaults.editable, [\"drag\", \"remove\"]);\n                }\n\n                if (userShapeDefaults && userShapeDefaults.connectors) {\n                    options.shapeDefaults.connectors = userShapeDefaults.connectors;\n                }\n            },\n\n            _interactionDefaults: function() {\n                var options = this.options;\n                var selectable = options.selectable;\n                var pannable = options.pannable;\n                var mobile = kendo.support.mobileOS;\n\n                if (selectable && !defined(selectable.multiple)) {\n                    options.selectable = deepExtend({\n                        multiple: mobile ? false : true\n                    }, options.selectable);\n                }\n\n                if (pannable && !defined(pannable.key)) {\n                    options.pannable = deepExtend({\n                        key: mobile ? \"none\" : \"ctrl\"\n                    }, options.pannable);\n                }\n            },\n\n            _initCanvas: function() {\n                var canvasContainer = $(\"<div class='k-layer'></div>\").appendTo(this.scrollable)[0];\n                var viewPort = this.viewport();\n                this.canvas = new Canvas(canvasContainer, {\n                    width: viewPort.width || DEFAULT_CANVAS_WIDTH,\n                    height: viewPort.height || DEFAULT_CANVAS_HEIGHT\n                });\n            },\n\n            _createHandlers: function() {\n                var that = this;\n                var element = that.element;\n\n                element.on(MOUSEWHEEL_NS, that._wheel.bind(that))\n                .on(\"keydown\" + NS, that._keydown.bind(that));\n\n                that._userEvents = new kendo.UserEvents(this.scrollable, {\n                    multiTouch: true,\n                    fastTap: true,\n                    tap: that._tap.bind(that),\n                    start: that._dragStart.bind(that),\n                    move: that._drag.bind(that),\n                    end: that._dragEnd.bind(that),\n                    gesturestart: that._gestureStart.bind(that),\n                    gesturechange: that._gestureChange.bind(that),\n                    gestureend: that._gestureEnd.bind(that),\n                    doubleTap: that._doubleTap.bind(that),\n                    supportDoubleTap: true\n                });\n\n                that.toolService = new ToolService(that);\n\n                this.scrollable\n                    .on(\"mouseover\" + NS, that._mouseover.bind(that))\n                    .on(\"mouseout\" + NS, that._mouseout.bind(that))\n                    .on(\"mousemove\" + NS, that._mouseMove.bind(that))\n                    .on(\"mousedown\" + NS, that._mouseDown.bind(that))\n                    .on(\"mouseup\" + NS, that._mouseUp.bind(that));\n\n                this._syncHandler = that._syncChanges.bind(that);\n\n                that._resizeHandler = that.resize.bind(that, false);\n                kendo.onResize(that._resizeHandler);\n\n                this.bind(ZOOM_START, that._destroyToolBar.bind(that));\n                this.bind(PAN, that._destroyToolBar.bind(that));\n            },\n\n            _dragStart: function(e) {\n                this._pauseMouseHandlers = true;\n                var point = this._eventPositions(e, true);\n\n                var event = e.event;\n                if (this.toolService.start(point, this._meta(event))) {\n                    this._destroyToolBar();\n                    event.preventDefault();\n                }\n            },\n\n            _drag: function(e) {\n                var p = this._eventPositions(e);\n                var event = e.event;\n                if (this.toolService.move(p, this._meta(event))) {\n                    event.preventDefault();\n                }\n            },\n\n            _dragEnd: function(e) {\n                this._pauseMouseHandlers = false;\n                var p = this._eventPositions(e);\n                var event = e.event;\n                if (this.toolService.end(p, this._meta(event))) {\n                    this._createToolBar();\n                    event.preventDefault();\n                }\n            },\n\n            _mouseMove: function(e) {\n                if (!this._pauseMouseHandlers) {\n                    var p = this._eventPositions(e);\n                    this.toolService._updateHoveredItem(p);\n                    this.toolService._updateCursor(p);\n                }\n            },\n\n            _mouseDown: function() {\n                this._pauseMouseHandlers = true;\n            },\n\n            _mouseUp: function() {\n                this._pauseMouseHandlers = false;\n            },\n\n            _tap: function(e) {\n                var toolService = this.toolService;\n                var selectable = this.options.selectable;\n                var point = this._eventPositions(e);\n                var focused = this.focus();\n\n                toolService._updateHoveredItem(point);\n\n                if (toolService.hoveredItem) {\n                    var item = toolService.hoveredItem;\n\n                    this.trigger(\"click\", {\n                        item: item,\n                        point: point,\n                        meta: this._meta(e.event)\n                    });\n\n                    if (selectable && item.options.selectable !== false) {\n                        var multiple = selectable.multiple !== false;\n                        var ctrlPressed = kendo.support.mobileOS || this._meta(e.event).ctrlKey;\n\n                        if (item.isSelected) {\n                            if (ctrlPressed) {\n                                this._destroyToolBar();\n                                item.select(false);\n                            } else {\n                                this._createToolBar(focused);\n                            }\n                        } else {\n                            this._destroyToolBar();\n                            this.select(item, {\n                                addToSelection: multiple && ctrlPressed\n                            });\n                            this._createToolBar(focused);\n                        }\n                    }\n                } else if (selectable) {\n                    this._destroyToolBar();\n                    this.deselect();\n                }\n            },\n\n            _keydown: function(e) {\n                if (this.toolService.keyDown(e.keyCode, this._meta(e))) {\n                    e.preventDefault();\n                }\n            },\n\n            _wheel: function(e) {\n                var delta = mwDelta(e),\n                    p = this._eventPositions(e),\n                    meta = deepExtend(this._meta(e), { delta: delta });\n\n                if (this.toolService.wheel(p, meta)) {\n                    e.preventDefault();\n                }\n            },\n\n            _meta: function(e) {\n                return { ctrlKey: e.ctrlKey, metaKey: e.metaKey, altKey: e.altKey, shiftKey: e.shiftKey, type: e.type };\n            },\n\n            _eventPositions: function(e, start) {\n                var point;\n                if (e.touch) {\n                    var field = start ? \"startLocation\" : \"location\";\n                    point = new Point(e.x[field], e.y[field]);\n                } else {\n                    var event = e.originalEvent;\n                    point = new Point(event.pageX, event.pageY);\n                }\n\n                return this.documentToModel(point);\n            },\n\n            _gestureStart: function(e) {\n                this._destroyToolBar();\n                this.scroller.disable();\n                var initialCenter = this.documentToModel(new Point(e.center.x, e.center.y));\n                var eventArgs = {\n                    point: initialCenter,\n                    zoom: this.zoom()\n                };\n\n                if (this.trigger(ZOOM_START, eventArgs)) {\n                    return;\n                }\n\n                this._gesture = e;\n                this._initialCenter = initialCenter;\n            },\n\n            _gestureChange: function(e) {\n                var previousGesture = this._gesture;\n                var initialCenter = this._initialCenter;\n                var center = this.documentToView(new Point(e.center.x, e.center.y));\n                var scaleDelta = e.distance / previousGesture.distance;\n                var zoom = this._zoom;\n                var updateZoom = false;\n\n                if (math.abs(scaleDelta - 1) >= MOBILE_ZOOM_RATE) {\n                    this._zoom = zoom = this._getValidZoom(zoom * scaleDelta);\n                    this.options.zoom = zoom;\n                    this._gesture = e;\n                    updateZoom = true;\n                }\n\n                var zoomedPoint = initialCenter.times(zoom);\n                var pan = center.minus(zoomedPoint);\n                if (updateZoom || this._pan.distanceTo(pan) >= MOBILE_PAN_DISTANCE) {\n                    this._panTransform(pan);\n                    this._updateAdorners();\n                }\n\n                e.preventDefault();\n            },\n\n            _doubleTap: function(e) {\n                var diagram = this;\n                var pointPosition = this._eventPositions(e);\n                var options = diagram.options;\n                var zoomRate = options.zoomRate;\n                var zoom = diagram.zoom() + zoomRate;\n                var meta = this._meta(e);\n                var zoomOptions = { point: pointPosition, meta: meta, zoom: zoom };\n\n\n                if (diagram.trigger(ZOOM_START, zoomOptions)) {\n                    return;\n                }\n\n                zoom = kendo.dataviz.round(Math.max(options.zoomMin, Math.min(options.zoomMax, zoom)), 2);\n                zoomOptions.zoom = zoom;\n\n                diagram.zoom(zoom, zoomOptions);\n                diagram.trigger(ZOOM_END, zoomOptions);\n            },\n\n            _gestureEnd: function() {\n                if (this.options.pannable !== false) {\n                    this.scroller.enable();\n                }\n                this.trigger(ZOOM_END, {\n                    point: this._initialCenter,\n                    zoom: this.zoom()\n                });\n            },\n\n            _resize: function() {\n                var viewport = this.viewport();\n                if (this.canvas) {\n                    this.canvas.size(viewport);\n                }\n\n                if (this.scrollable && this.toolBar) {\n                    this.scrollable.height(viewport.height);\n                }\n            },\n\n            _mouseover: function(e) {\n                var node = e.target._kendoNode;\n                if (node && node.srcElement._hover) {\n                    node.srcElement._hover(true, node.srcElement);\n                }\n            },\n\n            _mouseout: function(e) {\n                var node = e.target._kendoNode;\n                if (node && node.srcElement._hover) {\n                    node.srcElement._hover(false, node.srcElement);\n                }\n            },\n\n            _initTheme: function() {\n                var that = this;\n                var themeName = ((that.options || {}).theme || \"\").toLowerCase();\n                var themes = dataviz.ui.themes || {};\n                var themeOptions;\n\n                if (dataviz.SASS_THEMES.indexOf(themeName) != -1) {\n                    themeOptions = dataviz.autoTheme().diagram;\n                }\n                else {\n                    themeOptions = (themes[themeName] || {}).diagram;\n                }\n\n                that.options = deepExtend({}, themeOptions, that.options);\n                if (that.options.editable === true) {\n                    deepExtend(that.options, {\n                        editable: (themeOptions || {}).editable\n                    });\n                }\n            },\n\n            _createOptionElements: function() {\n                var options = this.options;\n                var shapesLength = options.shapes.length;\n\n                if (shapesLength) {\n                    this._createShapes();\n                }\n\n                if (options.connections.length) {\n                    this._createConnections();\n                }\n\n                if (shapesLength && options.layout) {\n                    this.layout(options.layout);\n                }\n            },\n\n            _createShapes: function() {\n                var that = this,\n                    options = that.options,\n                    shapes = options.shapes,\n                    shape, i;\n\n                for (i = 0; i < shapes.length; i++) {\n                    shape = shapes[i];\n                    that.addShape(shape);\n                }\n            },\n\n            _createConnections: function() {\n                var diagram = this,\n                    options = diagram.options,\n                    defaults = options.connectionDefaults,\n                    connections = options.connections,\n                    conn, source, target, i;\n\n                for (i = 0; i < connections.length; i++) {\n                    conn = connections[i];\n                    source = diagram._findConnectionTarget(conn.from);\n                    target = diagram._findConnectionTarget(conn.to);\n\n                    diagram.connect(source, target, deepExtend({}, defaults, conn));\n                }\n            },\n\n            _findConnectionTarget: function(options) {\n                options = options || {};\n                var diagram = this;\n                var shapeId = isString(options) ? options : options.shapeId || options.id;\n                var target;\n                if (shapeId) {\n                    target = diagram.getShapeById(shapeId);\n                    if (options.connector) {\n                        target = target.getConnector(options.connector);\n                    }\n                } else {\n                    target = new Point(options.x || 0, options.y || 0);\n                }\n\n                return target;\n            },\n\n            destroy: function() {\n                var that = this;\n                Widget.fn.destroy.call(that);\n\n                if (this._userEvents) {\n                    this._userEvents.destroy();\n                }\n\n                kendo.unbindResize(that._resizeHandler);\n\n                that.clear();\n                that.element.off(NS);\n                that.scroller.wrapper.off(NS);\n                that.canvas.destroy(true);\n                that.canvas = undefined$1;\n\n                that._destroyEditor();\n                that.destroyScroller();\n                that._destroyGlobalToolBar();\n                that._destroyToolBar();\n            },\n\n            destroyScroller: function() {\n                var scroller = this.scroller;\n\n                if (!scroller) {\n                    return;\n                }\n\n                scroller.destroy();\n                scroller.element.remove();\n                this.scroller = null;\n            },\n\n            save: function() {\n                var json = {\n                    shapes: [],\n                    connections: []\n                };\n                var i, connection, shape;\n\n                for (i = 0; i < this.shapes.length; i++) {\n                    shape = this.shapes[i];\n                    if (shape.options.serializable) {\n                        json.shapes.push(shape.options);\n                    }\n                }\n\n                for (i = 0; i < this.connections.length; i++) {\n                    connection = this.connections[i];\n\n                    json.connections.push(deepExtend({}, connection.options, connection.toJSON()));\n                }\n\n                return json;\n            },\n\n            focus: function() {\n                if (!this.element.is(kendo._activeElement())) {\n                    var element = this.element,\n                        scrollContainer = element[0],\n                        containers = [],\n                        offsets = [],\n                        documentElement = document.documentElement,\n                        i;\n\n                    do {\n                        scrollContainer = scrollContainer.parentNode;\n\n                        if (scrollContainer.scrollHeight > scrollContainer.clientHeight) {\n                            containers.push(scrollContainer);\n                            offsets.push(scrollContainer.scrollTop);\n                        }\n                    } while (scrollContainer != documentElement);\n\n                    element.trigger(\"focus\");\n\n                    for (i = 0; i < containers.length; i++) {\n                        containers[i].scrollTop = offsets[i];\n                    }\n                    return true;\n                }\n            },\n\n            load: function(options) {\n                this.clear();\n\n                this.setOptions(options);\n                this._createShapes();\n                this._createConnections();\n            },\n\n            setOptions: function(options) {\n                deepExtend(this.options, options);\n            },\n\n            clear: function() {\n                var that = this;\n\n                that.select(false);\n                that.mainLayer.clear();\n                that._shapesQuadTree.clear();\n                that._initialize();\n            },\n            /**\n             * Connects two items.\n             * @param source Shape, Connector, Point.\n             * @param target Shape, Connector, Point.\n             * @param options Connection options that will be passed to the newly created connection.\n             * @returns The newly created connection.\n             */\n            connect: function(source, target, options) {\n                var connection;\n                if (this.connectionsDataSource && this._isEditable) {\n                    var dataItem = this.connectionsDataSource.add({});\n                    connection = this._connectionsDataMap[dataItem.uid];\n                    connection.source(source);\n                    connection.target(target);\n                    connection.redraw(options);\n                    connection.updateModel();\n                } else {\n                    connection = new Connection(source, target,\n                        deepExtend({ }, this.options.connectionDefaults, options));\n\n                    this.addConnection(connection);\n                }\n\n                return connection;\n            },\n            /**\n             * Determines whether the the two items are connected.\n             * @param source Shape, Connector, Point.\n             * @param target Shape, Connector, Point.\n             * @returns true if the two items are connected.\n             */\n            connected: function(source, target) {\n                for (var i = 0; i < this.connections.length; i++) {\n                    var c = this.connections[i];\n                    if (c.from == source && c.to == target) {\n                        return true;\n                    }\n                }\n\n                return false;\n            },\n            /**\n             * Adds connection to the diagram.\n             * @param connection Connection.\n             * @param undoable Boolean.\n             * @returns The newly created connection.\n             */\n            addConnection: function(connection, undoable) {\n                if (undoable !== false) {\n                    this.undoRedoService.add(\n                        new diagram.AddConnectionUnit(connection, this), false);\n                }\n\n                connection.diagram = this;\n                connection._setOptionsFromModel();\n                connection.refresh();\n                this.mainLayer.append(connection.visual);\n                this.connections.push(connection);\n\n                this.trigger(CHANGE, {\n                    added: [connection],\n                    removed: []\n                });\n\n                return connection;\n            },\n\n            _addConnection: function(connection, undoable) {\n                var connectionsDataSource = this.connectionsDataSource;\n                var dataItem;\n                if (connectionsDataSource && this._isEditable) {\n                    dataItem = createModel(connectionsDataSource, cloneDataItem(connection.dataItem));\n                    connection.dataItem = dataItem;\n                    connection.updateModel();\n\n                    if (!this.trigger(\"add\", { connection: connection })) {\n                        this._connectionsDataMap[dataItem.uid] = connection;\n\n                        connectionsDataSource.add(dataItem);\n                        this.addConnection(connection, undoable);\n                        connection._updateConnectors();\n\n                        return connection;\n                    }\n                } else if (!this.trigger(\"add\", { connection: connection })) {\n                    this.addConnection(connection, undoable);\n                    connection._updateConnectors();\n                    return connection;\n                }\n            },\n\n            /**\n             * Adds shape to the diagram.\n             * @param item Shape, Point. If point is passed it will be created new Shape and positioned at that point.\n             * @param options. The options to be passed to the newly created Shape.\n             * @returns The newly created shape.\n             */\n            addShape: function(item, undoable) {\n                var shape,\n                    shapeDefaults = this.options.shapeDefaults;\n\n                if (item instanceof Shape) {\n                    shape = item;\n                    this._parseBounds(shape.bounds());\n                } else if (!(item instanceof kendo.Class)) {\n                    shapeDefaults = deepExtend({}, shapeDefaults, item || {});\n                    shape = new Shape(shapeDefaults, this);\n                    this._parseBounds(shape.bounds());\n                } else {\n                    return;\n                }\n\n                if (undoable !== false) {\n                    this.undoRedoService.add(new diagram.AddShapeUnit(shape, this), false);\n                }\n\n                this.shapes.push(shape);\n                if (shape.diagram !== this) {\n                    this._shapesQuadTree.insert(shape);\n                    shape.diagram = this;\n                }\n                this.mainLayer.append(shape.visual);\n\n                this.trigger(CHANGE, {\n                    added: [shape],\n                    removed: []\n                });\n\n                return shape;\n            },\n\n            _addShape: function(shape, undoable) {\n                var that = this;\n                var dataSource = that.dataSource;\n                var dataItem;\n                if (dataSource && this._isEditable) {\n                    dataItem = createModel(dataSource, cloneDataItem(shape.dataItem));\n                    shape.dataItem = dataItem;\n                    shape.updateModel();\n\n                    if (!this.trigger(\"add\", { shape: shape })) {\n                        this.dataSource.add(dataItem);\n                        var inactiveItem = this._inactiveShapeItems.getByUid(dataItem.uid);\n                        inactiveItem.element = shape;\n                        inactiveItem.undoable = undoable;\n                        return shape;\n                    }\n                } else if (!this.trigger(\"add\", { shape: shape })) {\n                    return this.addShape(shape, undoable);\n                }\n            },\n\n            _parseBounds: function(bounds) {\n                bounds.x = typeof(bounds.x) == \"string\" ? parseFloat(bounds.x) : bounds.x;\n                bounds.y = typeof(bounds.y) == \"string\" ? parseFloat(bounds.y) : bounds.y;\n            },\n            /**\n             * Removes items (or single item) from the diagram.\n             * @param items DiagramElement, Array of Items.\n             * @param undoable.\n             */\n\n           remove: function(items, undoable) {\n                items = isArray(items) ? items.slice(0) : [items];\n                var elements = splitDiagramElements(items);\n                var shapes = elements.shapes;\n                var connections = elements.connections;\n                var i;\n\n                if (!defined(undoable)) {\n                    undoable = true;\n                }\n\n                if (undoable) {\n                    this.undoRedoService.begin();\n                }\n\n                this._suspendModelRefresh();\n                for (i = shapes.length - 1; i >= 0; i--) {\n                   this._removeItem(shapes[i], undoable, connections);\n                }\n\n                for (i = connections.length - 1; i >= 0; i--) {\n                    this._removeItem(connections[i], undoable);\n                }\n\n                this._resumeModelRefresh();\n\n                if (undoable) {\n                    this.undoRedoService.commit(false);\n                }\n\n                this.trigger(CHANGE, {\n                    added: [],\n                    removed: items\n                });\n            },\n\n            _removeShapeDataItem: function(item) {\n                if (this._isEditable) {\n                    this.dataSource.remove(item.dataItem);\n                    delete this._dataMap[item.dataItem.id];\n                }\n            },\n\n            _removeConnectionDataItem: function(item) {\n                if (this._isEditable) {\n                    this.connectionsDataSource.remove(item.dataItem);\n                    delete this._connectionsDataMap[item.dataItem.uid];\n                }\n            },\n\n            _triggerRemove: function(items) {\n                var toRemove = [];\n                var item, args, editable;\n\n                for (var idx = 0; idx < items.length; idx++) {\n                    item = items[idx];\n                    editable = item.options.editable;\n                    if (item instanceof Shape) {\n                        args = { shape: item };\n                    } else {\n                        args = { connection: item };\n                    }\n                    if (editable && editable.remove !== false && !this.trigger(\"remove\", args)) {\n                        toRemove.push(item);\n                    }\n                }\n                return toRemove;\n            },\n\n            /**\n             * Executes the next undoable action on top of the undo stack if any.\n             */\n            undo: function() {\n                this.undoRedoService.undo();\n            },\n            /**\n             * Executes the previous undoable action on top of the redo stack if any.\n             */\n            redo: function() {\n                this.undoRedoService.redo();\n            },\n            /**\n             * Selects items on the basis of the given input or returns the current selection if none.\n             * @param itemsOrRect DiagramElement, Array of elements, \"All\", false or Rect. A value 'false' will deselect everything.\n             * @param options\n             * @returns {Array}\n             */\n            select: function(item, options) {\n                if (isDefined(item)) {\n                    options = deepExtend({ addToSelection: false }, options);\n\n                    var addToSelection = options.addToSelection,\n                        items = [],\n                        selected = [],\n                        i, element;\n\n                    if (!addToSelection) {\n                        this.deselect();\n                    }\n\n                    this._internalSelection = true;\n\n                    if (item instanceof Array) {\n                        items = item;\n                    } else if (item instanceof DiagramElement) {\n                        items = [ item ];\n                    }\n\n                    for (i = 0; i < items.length; i++) {\n                        element = items[i];\n                        if (element.select(true)) {\n                            selected.push(element);\n                        }\n                    }\n\n                    this._selectionChanged(selected, []);\n\n                    this._internalSelection = false;\n                } else {\n                    return this._selectedItems;\n                }\n            },\n\n            selectAll: function() {\n                this.select(this.shapes.concat(this.connections));\n            },\n\n            selectArea: function(rect) {\n                var i, items, item;\n                this._internalSelection = true;\n                var selected = [];\n                if (rect instanceof Rect) {\n                    items = this.shapes.concat(this.connections);\n                    for (i = 0; i < items.length; i++) {\n                        item = items[i];\n                        if ((!rect || item._hitTest(rect)) && item.options.enable) {\n                            if (item.select(true)) {\n                                selected.push(item);\n                            }\n                        }\n                    }\n                }\n\n                this._selectionChanged(selected, []);\n                this._internalSelection = false;\n            },\n\n            deselect: function(item) {\n                this._internalSelection = true;\n                var deselected = [],\n                    items = [],\n                    element, i;\n\n                if (item instanceof Array) {\n                    items = item;\n                } else if (item instanceof DiagramElement) {\n                    items.push(item);\n                } else if (!isDefined(item)) {\n                    items = this._selectedItems.slice(0);\n                }\n\n                for (i = 0; i < items.length; i++) {\n                    element = items[i];\n                    if (element.select(false)) {\n                        deselected.push(element);\n                    }\n                }\n\n                this._selectionChanged([], deselected);\n                this._internalSelection = false;\n            },\n            /**\n             * Brings to front the passed items.\n             * @param items DiagramElement, Array of Items.\n             * @param undoable. By default the action is undoable.\n             */\n            toFront: function(items, undoable) {\n                if (!items) {\n                    items = this._selectedItems.slice();\n                }\n\n                var result = this._getDiagramItems(items), indices;\n                if (!defined(undoable) || undoable) {\n                    indices = indicesOfItems(this.mainLayer, result.visuals);\n                    var unit = new ToFrontUnit(this, items, indices);\n                    this.undoRedoService.add(unit);\n                } else {\n                    this.mainLayer.toFront(result.visuals);\n                    this._fixOrdering(result, true);\n                }\n            },\n            /**\n             * Sends to back the passed items.\n             * @param items DiagramElement, Array of Items.\n             * @param undoable. By default the action is undoable.\n             */\n            toBack: function(items, undoable) {\n                if (!items) {\n                    items = this._selectedItems.slice();\n                }\n\n                var result = this._getDiagramItems(items), indices;\n                if (!defined(undoable) || undoable) {\n                    indices = indicesOfItems(this.mainLayer, result.visuals);\n                    var unit = new ToBackUnit(this, items, indices);\n                    this.undoRedoService.add(unit);\n                } else {\n                    this.mainLayer.toBack(result.visuals);\n                    this._fixOrdering(result, false);\n                }\n            },\n            /**\n             * Bring into view the passed item(s) or rectangle.\n             * @param items DiagramElement, Array of Items, Rect.\n             * @param options. align - controls the position of the calculated rectangle relative to the viewport.\n             * \"Center middle\" will position the items in the center. animate - controls if the pan should be animated.\n             */\n            bringIntoView: function(item, options) { // jQuery|Item|Array|Rect\n                var viewport = this.viewport();\n                var aligner = new diagram.RectAlign(viewport);\n                var current, rect, original, newPan;\n\n                if (viewport.width === 0 || viewport.height === 0) {\n                    return;\n                }\n\n                options = deepExtend({ animate: false, align: \"center middle\" }, options);\n                if (options.align == \"none\") {\n                    options.align = \"center middle\";\n                }\n\n                if (item instanceof DiagramElement) {\n                    rect = item.bounds(TRANSFORMED);\n                } else if (isArray(item)) {\n                    rect = this.boundingBox(item);\n                } else if (item instanceof Rect) {\n                    rect = item.clone();\n                }\n\n                original = rect.clone();\n\n                rect.zoom(this._zoom);\n\n                if (rect.width > viewport.width || rect.height > viewport.height) {\n                    this._zoom = this._getValidZoom(math.min(viewport.width / original.width, viewport.height / original.height));\n                    rect = original.clone().zoom(this._zoom);\n                }\n\n                this._zoomMainLayer();\n\n                current = rect.clone();\n                aligner.align(rect, options.align);\n\n                newPan = rect.topLeft().minus(current.topLeft());\n                this.pan(newPan.times(-1), options.animate);\n            },\n\n            alignShapes: function(direction) {\n                if (isUndefined(direction)) {\n                    direction = \"Left\";\n                }\n                var items = this.select(),\n                    val,\n                    item,\n                    i;\n\n                if (items.length === 0) {\n                    return;\n                }\n\n                switch (direction.toLowerCase()) {\n                    case \"left\":\n                    case \"top\":\n                        val = MAX_VALUE;\n                        break;\n                    case \"right\":\n                    case \"bottom\":\n                        val = MIN_VALUE;\n                        break;\n                }\n\n                for (i = 0; i < items.length; i++) {\n                    item = items[i];\n                    if (item instanceof Shape) {\n                        switch (direction.toLowerCase()) {\n                            case \"left\":\n                                val = math.min(val, item.options.x);\n                                break;\n                            case \"top\":\n                                val = math.min(val, item.options.y);\n                                break;\n                            case \"right\":\n                                val = math.max(val, item.options.x);\n                                break;\n                            case \"bottom\":\n                                val = math.max(val, item.options.y);\n                                break;\n                        }\n                    }\n                }\n                var undoStates = [];\n                var shapes = [];\n                for (i = 0; i < items.length; i++) {\n                    item = items[i];\n                    if (item instanceof Shape) {\n                        shapes.push(item);\n                        undoStates.push(item.bounds());\n                        switch (direction.toLowerCase()) {\n                            case \"left\":\n                            case \"right\":\n                                item.position(new Point(val, item.options.y));\n                                break;\n                            case \"top\":\n                            case \"bottom\":\n                                item.position(new Point(item.options.x, val));\n                                break;\n                        }\n                    }\n                }\n                var unit = new diagram.TransformUnit(shapes, undoStates);\n                this.undoRedoService.add(unit, false);\n            },\n\n            zoom: function(zoom, options) {\n                if (zoom) {\n                    var staticPoint = options ? options.point : new diagram.Point(0, 0);\n                    // var meta = options ? options.meta : 0;\n                    zoom = this._zoom = this._getValidZoom(zoom);\n\n                    if (!isUndefined(staticPoint)) {//Viewpoint vector is constant\n                        staticPoint = new diagram.Point(math.round(staticPoint.x), math.round(staticPoint.y));\n                        var zoomedPoint = staticPoint.times(zoom);\n                        var viewportVector = this.modelToView(staticPoint);\n                        var raw = viewportVector.minus(zoomedPoint);//pan + zoomed point = viewpoint vector\n                        this._storePan(new diagram.Point(math.round(raw.x), math.round(raw.y)));\n                    }\n\n                    if (options) {\n                        options.zoom = zoom;\n                    }\n\n                    this._panTransform();\n\n                    this.canvas.surface.hideTooltip();\n\n                    this._updateAdorners();\n                }\n\n                return this._zoom;\n            },\n\n            _getPan: function(pan) {\n                var canvas = this.canvas;\n                if (!canvas.translate) {\n                    pan = pan.plus(this._pan);\n                }\n                return pan;\n            },\n\n            pan: function(pan, animate) {\n                if (pan instanceof Point) {\n                    var that = this;\n                    var scroller = that.scroller;\n                    pan = that._getPan(pan);\n                    pan = pan.times(-1);\n\n                    if (animate) {\n                        scroller.animatedScrollTo(pan.x, pan.y, function() {\n                            that._updateAdorners();\n                        });\n                    } else {\n                        scroller.scrollTo(pan.x, pan.y);\n                        that._updateAdorners();\n                    }\n                } else {\n                    return this._pan.times(-1);\n                }\n            },\n\n            viewport: function() {\n                var element = this.element;\n                var width = element.width();\n                var height = element.height();\n\n                if (this.toolBar) {\n                    height -= outerHeight(this.toolBar.element);\n                }\n\n                return new Rect(0, 0, width, height);\n            },\n            copy: function() {\n                if (this.options.copy.enabled) {\n                    this._clipboard = [];\n                    this._copyOffset = 1;\n                    for (var i = 0; i < this._selectedItems.length; i++) {\n                        var item = this._selectedItems[i];\n                        this._clipboard.push(item);\n                    }\n                }\n            },\n            cut: function() {\n                if (this.options.copy.enabled) {\n                    this._clipboard = [];\n                    this._copyOffset = 0;\n                    for (var i = 0; i < this._selectedItems.length; i++) {\n                        var item = this._selectedItems[i];\n                        this._clipboard.push(item);\n                    }\n                    this.remove(this._clipboard, true);\n                }\n            },\n\n            paste: function() {\n                if (this._clipboard.length > 0) {\n                    var item, copied, i;\n                    var mapping = {};\n                    var elements = splitDiagramElements(this._clipboard);\n                    var connections = elements.connections;\n                    var shapes = elements.shapes;\n                    var offset = {\n                        x: this._copyOffset * this.options.copy.offsetX,\n                        y: this._copyOffset * this.options.copy.offsetY\n                    };\n                    this.deselect();\n                    // first the shapes\n                    for (i = 0; i < shapes.length; i++) {\n                        item = shapes[i];\n                        copied = item.clone();\n                        mapping[item.id] = copied;\n                        copied.position(new Point(item.options.x + offset.x, item.options.y + offset.y));\n                        copied.diagram = this;\n                        copied = this._addShape(copied);\n                        if (copied) {\n                            copied.select();\n                        }\n                    }\n                    // then the connections\n                    for (i = 0; i < connections.length; i++) {\n                        item = connections[i];\n                        copied = this._addConnection(item.clone());\n                        if (copied) {\n                            this._updateCopiedConnection(copied, item, \"source\", mapping, offset);\n                            this._updateCopiedConnection(copied, item, \"target\", mapping, offset);\n\n                            copied.select(true);\n                            copied.updateModel();\n                        }\n                    }\n\n                    this._syncChanges();\n\n                    this._copyOffset += 1;\n                }\n            },\n\n            _updateCopiedConnection: function(connection, sourceConnection, connectorName, mapping, offset) {\n                var onActivate, inactiveItem, targetShape;\n                var target = sourceConnection[connectorName]();\n                var diagram = this;\n                if (target instanceof Connector && mapping[target.shape.id]) {\n                    targetShape = mapping[target.shape.id];\n                    if (diagram.getShapeById(targetShape.id)) {\n                        connection[connectorName](targetShape.getConnector(target.options.name));\n                    } else {\n                        inactiveItem = diagram._inactiveShapeItems.getByUid(targetShape.dataItem.uid);\n                        if (inactiveItem) {\n                            onActivate = function(item) {\n                                targetShape = diagram._dataMap[item.id];\n                                connection[connectorName](targetShape.getConnector(target.options.name));\n                                connection.updateModel();\n                            };\n                            diagram._deferredConnectionUpdates.push(inactiveItem.onActivate(onActivate));\n                        }\n                    }\n                } else {\n                    connection[connectorName](new Point(sourceConnection[connectorName + \"Point\"]().x + offset.x, sourceConnection[connectorName + \"Point\"]().y + offset.y));\n                }\n            },\n            /**\n             * Gets the bounding rectangle of the given items.\n             * @param items DiagramElement, Array of elements.\n             * @param origin Boolean. Pass 'true' if you need to get the bounding box of the shapes without their rotation offset.\n             * @returns {Rect}\n             */\n            boundingBox: function(items, origin) {\n                var rect = Rect.empty(), temp,\n                    di = isDefined(items) ? this._getDiagramItems(items) : { shapes: this.shapes };\n                if (di.shapes.length > 0) {\n                    var item = di.shapes[0];\n                    rect = item.bounds(ROTATED);\n                    for (var i = 1; i < di.shapes.length; i++) {\n                        item = di.shapes[i];\n                        temp = item.bounds(ROTATED);\n                        if (origin === true) {\n                            temp.x -= item._rotationOffset.x;\n                            temp.y -= item._rotationOffset.y;\n                        }\n                        rect = rect.union(temp);\n                    }\n                }\n                return rect;\n            },\n\n            _containerOffset: function() {\n                var containerOffset = this.element.offset();\n                if (this.toolBar) {\n                    containerOffset.top += outerHeight(this.toolBar.element);\n                }\n                return containerOffset;\n            },\n\n            documentToView: function(point) {\n                var containerOffset = this._containerOffset();\n\n                return new Point(point.x - containerOffset.left, point.y - containerOffset.top);\n            },\n            viewToDocument: function(point) {\n                var containerOffset = this._containerOffset();\n\n                return new Point(point.x + containerOffset.left, point.y + containerOffset.top);\n            },\n            viewToModel: function(point) {\n                return this._transformWithMatrix(point, this._matrixInvert);\n            },\n            modelToView: function(point) {\n                return this._transformWithMatrix(point, this._matrix);\n            },\n            modelToLayer: function(point) {\n                return this._transformWithMatrix(point, this._layerMatrix);\n            },\n            layerToModel: function(point) {\n                return this._transformWithMatrix(point, this._layerMatrixInvert);\n            },\n            documentToModel: function(point) {\n                var viewPoint = this.documentToView(point);\n                if (!this.canvas.translate) {\n                    viewPoint.x = viewPoint.x + this.scroller.scrollLeft;\n                    viewPoint.y = viewPoint.y + this.scroller.scrollTop;\n                }\n                return this.viewToModel(viewPoint);\n            },\n            modelToDocument: function(point) {\n                return this.viewToDocument(this.modelToView(point));\n            },\n            _transformWithMatrix: function(point, matrix) {\n                var result = point;\n                if (point instanceof Point) {\n                    if (matrix) {\n                        result = matrix.apply(point);\n                    }\n                }\n                else {\n                    var tl = this._transformWithMatrix(point.topLeft(), matrix),\n                        br = this._transformWithMatrix(point.bottomRight(), matrix);\n                    result = Rect.fromPoints(tl, br);\n                }\n                return result;\n            },\n\n            setDataSource: function(dataSource) {\n                this.options.dataSource = dataSource;\n                this._dataSource();\n                if (this.options.autoBind) {\n                    this.dataSource.fetch();\n                }\n            },\n\n            setConnectionsDataSource: function(dataSource) {\n                this.options.connectionsDataSource = dataSource;\n                this._connectionDataSource();\n                if (this.options.autoBind) {\n                    this.connectionsDataSource.fetch();\n                }\n            },\n\n            /**\n             * Performs a diagram layout of the given type.\n             * @param layoutType The layout algorithm to be applied (TreeLayout, LayeredLayout, SpringLayout).\n             * @param options Layout-specific options.\n             */\n            layout: function(options) {\n                this._layouting = true;\n                // TODO: raise layout event?\n                var type;\n                if (isUndefined(options)) {\n                    options = this.options.layout;\n                }\n                if (isUndefined(options) || isUndefined(options.type)) {\n                    type = \"Tree\";\n                }\n                else {\n                    type = options.type;\n                }\n                var l;\n                switch (type.toLowerCase()) {\n                    case \"tree\":\n                        l = new diagram.TreeLayout(this);\n                        break;\n\n                    case \"layered\":\n                        l = new diagram.LayeredLayout(this);\n                        break;\n\n                    case \"forcedirected\":\n                    case \"force\":\n                    case \"spring\":\n                    case \"springembedder\":\n                        l = new diagram.SpringLayout(this);\n                        break;\n                    default:\n                        throw \"Layout algorithm '\" + type + \"' is not supported.\";\n                }\n                var initialState = new diagram.LayoutState(this);\n                var finalState = l.layout(options);\n                if (finalState) {\n                    var unit = new diagram.LayoutUndoUnit(initialState, finalState, options ? options.animate : null);\n                    this.undoRedoService.add(unit);\n                }\n                this._layouting = false;\n                this._redrawConnections();\n            },\n            /**\n             * Gets a shape on the basis of its identifier.\n             * @param id (string) the identifier of a shape.\n             * @returns {Shape}\n             */\n            getShapeById: function(id) {\n                var found;\n                found = Utils.first(this.shapes, function(s) {\n                    return s.visual.id === id;\n                });\n                if (found) {\n                    return found;\n                }\n                found = Utils.first(this.connections, function(c) {\n                    return c.visual.id === id;\n                });\n                return found;\n            },\n\n            getShapeByModelId: function(id) {\n                var shape;\n                if (this._isEditable) {\n                    shape = this._dataMap[id];\n                } else {\n                    shape = Utils.first(this.shapes, function(shape) {\n                        return (shape.dataItem || {}).id === id;\n                    });\n                }\n                return shape;\n            },\n\n            getShapeByModelUid: function(uid) {\n                var shape;\n                if (this._isEditable) {\n                    shape = Utils.first(this.shapes, function(shape) {\n                        return (shape.dataItem || {}).uid === uid;\n                    });\n                } else {\n                    shape = this._dataMap[uid];\n                }\n                return shape;\n            },\n\n            getConnectionByModelId: function(id) {\n                var connection;\n                if (this.connectionsDataSource) {\n                    connection = Utils.first(this.connections, function(connection) {\n                        return (connection.dataItem || {}).id === id;\n                    });\n                }\n                return connection;\n            },\n\n            getConnectionByModelUid: function(uid) {\n                var connection;\n                if (this.connectionsDataSource) {\n                    connection = this._connectionsDataMap[uid];\n                }\n                return connection;\n            },\n\n            _extendLayoutOptions: function(options) {\n                if (options.layout) {\n                    options.layout = deepExtend({}, diagram.LayoutBase.fn.defaultOptions || {}, options.layout);\n                }\n            },\n\n            _selectionChanged: function(selected, deselected) {\n                if (selected.length || deselected.length) {\n                    this.trigger(SELECT, { selected: selected, deselected: deselected });\n                }\n            },\n            _getValidZoom: function(zoom) {\n                return math.min(math.max(zoom, this.options.zoomMin), this.options.zoomMax);\n            },\n            _panTransform: function(pos) {\n                var diagram = this,\n                    pan = pos || diagram._pan;\n\n                if (diagram.canvas.translate) {\n                    diagram.scroller.scrollTo(pan.x, pan.y);\n                    diagram._zoomMainLayer();\n                } else {\n                    diagram._storePan(pan);\n                    diagram._transformMainLayer();\n                }\n            },\n\n            _finishPan: function() {\n                this.trigger(PAN, { total: this._pan, delta: Number.NaN });\n            },\n            _storePan: function(pan) {\n                this._pan = pan;\n                this._storeViewMatrix();\n            },\n            _zoomMainLayer: function() {\n                var zoom = this._zoom;\n\n                var transform = new CompositeTransform(0, 0, zoom, zoom);\n                transform.render(this.mainLayer);\n                this._storeLayerMatrix(transform);\n                this._storeViewMatrix();\n            },\n            _transformMainLayer: function() {\n                var pan = this._pan,\n                    zoom = this._zoom;\n\n                var transform = new CompositeTransform(pan.x, pan.y, zoom, zoom);\n                transform.render(this.mainLayer);\n                this._storeLayerMatrix(transform);\n                this._storeViewMatrix();\n            },\n            _storeLayerMatrix: function(canvasTransform) {\n                this._layerMatrix = canvasTransform.toMatrix();\n                this._layerMatrixInvert = canvasTransform.invert().toMatrix();\n            },\n            _storeViewMatrix: function() {\n                var pan = this._pan,\n                    zoom = this._zoom;\n\n                var transform = new CompositeTransform(pan.x, pan.y, zoom, zoom);\n                this._matrix = transform.toMatrix();\n                this._matrixInvert = transform.invert().toMatrix();\n            },\n            _toIndex: function(items, indices) {\n                var result = this._getDiagramItems(items);\n                this.mainLayer.toIndex(result.visuals, indices);\n                this._fixOrdering(result, false);\n            },\n            _fixOrdering: function(result, toFront) {\n                var shapePos = toFront ? this.shapes.length - 1 : 0,\n                    conPos = toFront ? this.connections.length - 1 : 0,\n                    i, item;\n                for (i = 0; i < result.shapes.length; i++) {\n                    item = result.shapes[i];\n                    Utils.remove(this.shapes, item);\n                    Utils.insert(this.shapes, item, shapePos);\n                }\n                for (i = 0; i < result.cons.length; i++) {\n                    item = result.cons[i];\n                    Utils.remove(this.connections, item);\n                    Utils.insert(this.connections, item, conPos);\n                }\n            },\n            _getDiagramItems: function(items) {\n                var i, result = {}, args = items;\n                result.visuals = [];\n                result.shapes = [];\n                result.cons = [];\n\n                if (!items) {\n                    args = this._selectedItems.slice();\n                } else if (!isArray(items)) {\n                    args = [items];\n                }\n\n                for (i = 0; i < args.length; i++) {\n                    var item = args[i];\n                    if (item instanceof Shape) {\n                        result.shapes.push(item);\n                        result.visuals.push(item.visual);\n                    } else if (item instanceof Connection) {\n                        result.cons.push(item);\n                        result.visuals.push(item.visual);\n                    }\n                }\n\n                return result;\n            },\n\n            _removeItem: function(item, undoable, removedConnections) {\n                item.select(false);\n                if (item instanceof Shape) {\n                    this._removeShapeDataItem(item);\n                    this._removeShape(item, undoable, removedConnections);\n                } else if (item instanceof Connection) {\n                    this._removeConnectionDataItem(item);\n                    this._removeConnection(item, undoable);\n                }\n\n                this.mainLayer.remove(item.visual);\n            },\n\n            _removeShape: function(shape, undoable, removedConnections) {\n                var i, connection, connector,\n                    sources = [], targets = [];\n                this.toolService._removeHover();\n\n                if (undoable) {\n                    this.undoRedoService.addCompositeItem(new DeleteShapeUnit(shape));\n                }\n                Utils.remove(this.shapes, shape);\n                this._shapesQuadTree.remove(shape);\n\n                for (i = 0; i < shape.connectors.length; i++) {\n                    connector = shape.connectors[i];\n                    for (var j = 0; j < connector.connections.length; j++) {\n                        connection = connector.connections[j];\n                        if (!removedConnections || !dataviz.inArray(connection, removedConnections)) {\n                            if (connection.sourceConnector == connector) {\n                                sources.push(connection);\n                            } else if (connection.targetConnector == connector) {\n                                targets.push(connection);\n                            }\n                        }\n                    }\n                }\n\n                for (i = 0; i < sources.length; i++) {\n                    sources[i].source(null, undoable);\n                    sources[i].updateModel();\n                }\n                for (i = 0; i < targets.length; i++) {\n                    targets[i].target(null, undoable);\n                    targets[i].updateModel();\n                }\n            },\n\n            _removeConnection: function(connection, undoable) {\n                if (connection.sourceConnector) {\n                    Utils.remove(connection.sourceConnector.connections, connection);\n                }\n                if (connection.targetConnector) {\n                    Utils.remove(connection.targetConnector.connections, connection);\n                }\n                if (undoable) {\n                    this.undoRedoService.addCompositeItem(new DeleteConnectionUnit(connection));\n                }\n\n                Utils.remove(this.connections, connection);\n            },\n\n            _removeDataItems: function(items, recursive) {\n                var item, children, shape, idx;\n                items = isArray(items) ? items : [items];\n\n                while (items.length) {\n                    item = items.shift();\n                    shape = this._dataMap[item.uid];\n                    if (shape) {\n                        this._removeShapeConnections(shape);\n                        this._removeItem(shape, false);\n                        delete this._dataMap[item.uid];\n                        if (recursive && item.hasChildren && item.loaded()) {\n                            children = item.children.data();\n                            for (idx = 0; idx < children.length; idx++) {\n                                items.push(children[idx]);\n                            }\n                        }\n                    }\n                }\n            },\n\n            _removeShapeConnections: function(shape) {\n                var connections = shape.connections();\n                var idx;\n\n                if (connections) {\n                    for (idx = 0; idx < connections.length; idx++) {\n                        this._removeItem(connections[idx], false);\n                    }\n                }\n            },\n\n            _addDataItem: function(dataItem, undoable) {\n                if (!defined(dataItem)) {\n                    return;\n                }\n\n                var shape = this._dataMap[dataItem.id];\n                if (shape) {\n                    return shape;\n                }\n\n                var options = deepExtend({}, this.options.shapeDefaults);\n                options.dataItem = dataItem;\n                shape = new Shape(options, this);\n                this.addShape(shape, undoable !== false);\n                this._dataMap[dataItem.id] = shape;\n                return shape;\n            },\n\n            _addDataItemByUid: function(dataItem) {\n                if (!defined(dataItem)) {\n                    return;\n                }\n\n                var shape = this._dataMap[dataItem.uid];\n                if (shape) {\n                    return shape;\n                }\n\n                var options = deepExtend({}, this.options.shapeDefaults);\n                options.dataItem = dataItem;\n                shape = new Shape(options, this);\n                this.addShape(shape);\n                this._dataMap[dataItem.uid] = shape;\n                return shape;\n            },\n\n            _addDataItems: function(items, parent) {\n                var item, idx, shape, parentShape, connection;\n                for (idx = 0; idx < items.length; idx++) {\n                    item = items[idx];\n                    shape = this._addDataItemByUid(item);\n                    parentShape = this._addDataItemByUid(parent);\n                    if (parentShape && !this.connected(parentShape, shape)) { // check if connected to not duplicate connections.\n                        connection = this.connect(parentShape, shape);\n                    }\n                }\n            },\n\n            _refreshSource: function(e) {\n                var that = this,\n                    node = e.node,\n                    action = e.action,\n                    items = e.items,\n                    options = that.options,\n                    idx,\n                    dataBound;\n\n                if (e.field) {\n                    for (idx = 0; idx < items.length; idx++) {\n                        if (this._dataMap[items[idx].uid]) {\n                            this._dataMap[items[idx].uid].redrawVisual();\n                        }\n                    }\n                    return;\n                }\n\n                if (action == \"remove\") {\n                    this._removeDataItems(e.items, true);\n                } else {\n\n                    if ((!action || action === \"itemloaded\") && !this._bindingRoots) {\n                        this._bindingRoots = true;\n                        dataBound = true;\n                    }\n\n                    if (!action && !node) {\n                        that.clear();\n                    }\n\n                    this._addDataItems(items, node);\n\n                    for (idx = 0; idx < items.length; idx++) {\n                        items[idx].load();\n                    }\n                }\n\n                if (options.layout && (dataBound || action == \"remove\" || action == \"add\")) {\n                    that.layout(options.layout);\n                }\n\n                if (dataBound) {\n                    this.trigger(\"dataBound\");\n                    this._bindingRoots = false;\n                }\n            },\n\n            _addItem: function(item) {\n                if (item instanceof Shape) {\n                    this.addShape(item);\n                } else if (item instanceof Connection) {\n                    this.addConnection(item);\n                }\n            },\n\n            _createToolBar: function(preventClosing) {\n                var diagram = this.toolService.diagram;\n\n                if (!this.singleToolBar && diagram.select().length === 1) {\n                    var element = diagram.select()[0];\n                    if (element && element.options.editable !== false) {\n                        var editable = element.options.editable;\n                        var tools = editable.tools;\n                        if (this._isEditable && tools.length === 0) {\n                            if (element instanceof Shape) {\n                                tools = [\"edit\", \"rotateClockwise\", \"rotateAnticlockwise\"];\n                            } else if (element instanceof Connection) {\n                                tools = [\"edit\"];\n                            }\n\n                            if (editable && editable.remove !== false) {\n                                tools.push(\"delete\");\n                            }\n                        }\n\n                        if (tools && tools.length) {\n                            var padding = 20;\n                            var point;\n                            this.singleToolBar = new DiagramToolBar(diagram, {\n                                tools: tools,\n                                click: this._toolBarClick.bind(this),\n                                modal: true,\n                                popupZIndex: parseInt(diagram.element.closest(\".k-window\").css(\"zIndex\"), 10) + 10\n                            });\n                            var popupWidth = outerWidth(this.singleToolBar._popup.element);\n                            var popupHeight = outerHeight(this.singleToolBar._popup.element);\n                            if (element instanceof Shape) {\n                                var shapeBounds = this.modelToView(element.bounds(ROTATED));\n                                point = new Point(shapeBounds.x, shapeBounds.y).minus(new Point(\n                                    (popupWidth - shapeBounds.width) / 2,\n                                    popupHeight + padding));\n                            } else if (element instanceof Connection) {\n                                var connectionBounds = this.modelToView(element.bounds());\n\n                                point = new Point(connectionBounds.x, connectionBounds.y)\n                                    .minus(new Point(\n                                        (popupWidth - connectionBounds.width - 20) / 2,\n                                        popupHeight + padding\n                                    ));\n                            }\n\n                            if (point) {\n                                if (!this.canvas.translate) {\n                                    point = point.minus(new Point(this.scroller.scrollLeft, this.scroller.scrollTop));\n                                }\n                                point = this.viewToDocument(point);\n                                point = new Point(math.max(point.x, 0), math.max(point.y, 0));\n                                this.singleToolBar.showAt(point);\n                                if (preventClosing) {\n                                    this.singleToolBar._popup.one(\"close\", preventDefault);\n                                }\n                            } else {\n                                this._destroyToolBar();\n                            }\n                        }\n                    }\n                }\n            },\n\n            _toolBarClick: function(e) {\n                this.trigger(\"toolBarClick\", e);\n                this._destroyToolBar();\n            },\n\n            _normalizePointZoom: function(point) {\n                return point.times(1 / this.zoom());\n            },\n\n            _initialize: function() {\n                this.shapes = [];\n                this._selectedItems = [];\n                this.connections = [];\n                this._dataMap = {};\n                this._connectionsDataMap = {};\n                this._inactiveShapeItems = new InactiveItemsCollection();\n                this._deferredConnectionUpdates = [];\n                this.undoRedoService = new UndoRedoService({\n                    undone: this._syncHandler,\n                    redone: this._syncHandler\n                });\n                this.id = diagram.randomId();\n            },\n\n            _fetchFreshData: function() {\n                var that = this;\n                that._dataSource();\n\n                if (that._isEditable) {\n                    that._connectionDataSource();\n                }\n\n                if (that.options.autoBind) {\n                    if (that._isEditable) {\n                        this._loadingShapes = true;\n                        this._loadingConnections = true;\n                        that.dataSource.fetch();\n                        that.connectionsDataSource.fetch();\n                    } else {\n                        that.dataSource.fetch();\n                    }\n                }\n            },\n\n            _dataSource: function() {\n                if (defined(this.options.connectionsDataSource)) {\n                    this._isEditable = true;\n                    var dsOptions = this.options.dataSource || {};\n                    var ds = isArray(dsOptions) ? { data: dsOptions } : dsOptions;\n\n                    if (this.dataSource && this._shapesRefreshHandler) {\n                        this.dataSource\n                            .unbind(\"change\", this._shapesRefreshHandler)\n                            .unbind(\"requestStart\", this._shapesRequestStartHandler)\n                            .unbind(\"error\", this._shapesErrorHandler);\n                    } else {\n                        this._shapesRefreshHandler = this._refreshShapes.bind(this);\n                        this._shapesRequestStartHandler = this._shapesRequestStart.bind(this);\n                        this._shapesErrorHandler = this._error.bind(this);\n                    }\n\n                    this.dataSource = kendo.data.DataSource.create(ds)\n                        .bind(\"change\", this._shapesRefreshHandler)\n                        .bind(\"requestStart\", this._shapesRequestStartHandler)\n                        .bind(\"error\", this._shapesErrorHandler);\n                } else {\n                    this._treeDataSource();\n                    this._isEditable = false;\n                }\n            },\n\n            _connectionDataSource: function() {\n                var dsOptions = this.options.connectionsDataSource;\n                if (dsOptions) {\n                    var ds = isArray(dsOptions) ? { data: dsOptions } : dsOptions;\n\n                    if (this.connectionsDataSource && this._connectionsRefreshHandler) {\n                        this.connectionsDataSource\n                            .unbind(\"change\", this._connectionsRefreshHandler)\n                            .unbind(\"requestStart\", this._connectionsRequestStartHandler)\n                            .unbind(\"error\", this._connectionsErrorHandler);\n                    } else {\n                        this._connectionsRefreshHandler = this._refreshConnections.bind(this);\n                        this._connectionsRequestStartHandler = this._connectionsRequestStart.bind(this);\n                        this._connectionsErrorHandler = this._connectionsError.bind(this);\n                    }\n\n                    this.connectionsDataSource = kendo.data.DataSource.create(ds)\n                        .bind(\"change\", this._connectionsRefreshHandler)\n                        .bind(\"requestStart\", this._connectionsRequestStartHandler)\n                        .bind(\"error\", this._connectionsErrorHandler);\n                }\n            },\n\n            _shapesRequestStart: function(e) {\n                if (e.type == \"read\") {\n                    this._loadingShapes = true;\n                }\n            },\n\n            _connectionsRequestStart: function(e) {\n                if (e.type == \"read\") {\n                    this._loadingConnections = true;\n                }\n            },\n\n            _error: function() {\n                this._loadingShapes = false;\n            },\n\n            _connectionsError: function() {\n                this._loadingConnections = false;\n            },\n\n            _refreshShapes: function(e) {\n                if (e.action === \"remove\") {\n                    if (this._shouldRefresh()) {\n                        this._removeShapes(e.items);\n                    }\n                } else if (e.action === \"itemchange\") {\n                    if (this._shouldRefresh()) {\n                        this._updateShapes(e.items, e.field);\n                    }\n                } else if (e.action === \"add\") {\n                    this._inactiveShapeItems.add(e.items);\n                } else if (e.action === \"sync\") {\n                    this._syncShapes(e.items);\n                } else {\n                    this.refresh();\n                }\n            },\n\n            _shouldRefresh: function() {\n                return !this._suspended;\n            },\n\n            _suspendModelRefresh: function() {\n                this._suspended = (this._suspended || 0) + 1;\n            },\n\n            _resumeModelRefresh: function() {\n                this._suspended = math.max((this._suspended || 0) - 1, 0);\n            },\n\n            refresh: function() {\n                this._loadingShapes = false;\n                if (!this._loadingConnections) {\n                    this._rebindShapesAndConnections();\n                }\n            },\n\n            _rebindShapesAndConnections: function() {\n                this.clear();\n                this._addShapes(this.dataSource.view());\n                if (this.connectionsDataSource) {\n                    this._addConnections(this.connectionsDataSource.view(), false);\n                }\n\n                if (this.options.layout) {\n                    this.layout(this.options.layout);\n                } else {\n                    this._redrawConnections();\n                }\n                this.trigger(\"dataBound\");\n            },\n\n            refreshConnections: function() {\n                this._loadingConnections = false;\n                if (!this._loadingShapes) {\n                    this._rebindShapesAndConnections();\n                }\n            },\n\n            _redrawConnections: function() {\n                var connections = this.connections;\n                for (var idx = 0; idx < connections.length; idx++) {\n                    connections[idx].refresh();\n                }\n            },\n\n            _removeShapes: function(items) {\n                var dataMap = this._dataMap;\n                var item, i;\n                for (i = 0; i < items.length; i++) {\n                    item = items[i];\n                    if (dataMap[item.id]) {\n                        this.remove(dataMap[item.id], false);\n                        dataMap[item.id] = null;\n                    }\n                }\n            },\n\n            _syncShapes: function() {\n                var diagram = this;\n                var inactiveItems = diagram._inactiveShapeItems;\n                inactiveItems.forEach(function(inactiveItem) {\n                    var dataItem = inactiveItem.dataItem;\n                    var shape = inactiveItem.element;\n                    if (!dataItem.isNew()) {\n                        if (shape) {\n                            shape._setOptionsFromModel();\n                            diagram.addShape(shape, inactiveItem.undoable);\n                            diagram._dataMap[dataItem.id] = shape;\n                        } else {\n                            diagram._addDataItem(dataItem);\n                        }\n                        inactiveItem.activate();\n                        inactiveItems.remove(dataItem);\n                    }\n                });\n            },\n\n            _updateShapes: function(items, field) {\n                for (var i = 0; i < items.length; i++) {\n                    var dataItem = items[i];\n\n                    var shape = this._dataMap[dataItem.id];\n                    if (shape) {\n                        shape.updateOptionsFromModel(dataItem, field);\n                    }\n                }\n            },\n\n            _addShapes: function(dataItems) {\n                for (var i = 0; i < dataItems.length; i++) {\n                    this._addDataItem(dataItems[i], false);\n                }\n            },\n\n            _refreshConnections: function(e) {\n                if (e.action === \"remove\") {\n                    if (this._shouldRefresh()) {\n                        this._removeConnections(e.items);\n                    }\n                } else if (e.action === \"add\") {\n                    this._addConnections(e.items);\n                } else if (e.action === \"sync\") {\n                    //TO DO: include logic to update the connections with different values returned from the server.\n                } else if (e.action === \"itemchange\") {\n                    if (this._shouldRefresh()) {\n                        this._updateConnections(e.items);\n                    }\n                } else {\n                    this.refreshConnections();\n                }\n            },\n\n            _removeConnections: function(items) {\n                for (var i = 0; i < items.length; i++) {\n                    this.remove(this._connectionsDataMap[items[i].uid], false);\n                    this._connectionsDataMap[items[i].uid] = null;\n                }\n            },\n\n            _updateConnections: function(items) {\n                for (var i = 0; i < items.length; i++) {\n                    var dataItem = items[i];\n\n                    var connection = this._connectionsDataMap[dataItem.uid];\n                    connection.updateOptionsFromModel(dataItem);\n                }\n            },\n\n            _addConnections: function(connections, undoable) {\n                var length = connections.length;\n\n                for (var i = 0; i < length; i++) {\n                    var dataItem = connections[i];\n                    this._addConnectionDataItem(dataItem, undoable);\n                }\n            },\n\n            _addConnectionDataItem: function(dataItem, undoable) {\n                if (!this._connectionsDataMap[dataItem.uid]) {\n                    var from = this._validateConnector(dataItem.from);\n                    if (!defined(from) || from === null) {\n                        from = new Point(dataItem.fromX, dataItem.fromY);\n                    }\n\n                    var to = this._validateConnector(dataItem.to);\n                    if (!defined(to) || to === null) {\n                        to = new Point(dataItem.toX, dataItem.toY);\n                    }\n\n                    if (defined(from) && defined(to)) {\n                        var options = deepExtend({}, this.options.connectionDefaults);\n                        options.dataItem = dataItem;\n                        var connection = new Connection(from, to, options);\n\n                        this._connectionsDataMap[dataItem.uid] = connection;\n                        this.addConnection(connection, undoable);\n                    }\n                }\n            },\n\n            _validateConnector: function(value) {\n                var connector;\n\n                if (defined(value) && value !== null) {\n                    connector = this._dataMap[value];\n                }\n\n                return connector;\n            },\n\n            _treeDataSource: function() {\n                var that = this,\n                    options = that.options,\n                    dataSource = options.dataSource;\n\n                dataSource = isArray(dataSource) ? { data: dataSource } : dataSource;\n\n                if (dataSource instanceof kendo.data.DataSource && !(dataSource instanceof kendo.data.HierarchicalDataSource)) {\n                    throw new Error(\"Incorrect DataSource type. If a single dataSource instance is set to the diagram then it should be a HierarchicalDataSource. You should set only the options instead of an instance or a HierarchicalDataSource instance or supply connectionsDataSource as well.\");\n                }\n\n                if (!dataSource.fields) {\n                    dataSource.fields = [\n                        { field: \"text\" },\n                        { field: \"url\" },\n                        { field: \"spriteCssClass\" },\n                        { field: \"imageUrl\" }\n                    ];\n                }\n                if (that.dataSource && that._refreshHandler) {\n                    that._unbindDataSource();\n                }\n\n                that._refreshHandler = that._refreshSource.bind(that);\n                that._errorHandler = that._error.bind(that);\n\n                that.dataSource = HierarchicalDataSource.create(dataSource)\n                    .bind(CHANGE, that._refreshHandler)\n                    .bind(ERROR, that._errorHandler);\n            },\n\n            _unbindDataSource: function() {\n                var that = this;\n\n                that.dataSource.unbind(CHANGE, that._refreshHandler).unbind(ERROR, that._errorHandler);\n            },\n\n            _adorn: function(adorner, isActive) {\n                if (isActive !== undefined$1 && adorner) {\n                    if (isActive) {\n                        this._adorners.push(adorner);\n                        this.adornerLayer.append(adorner.visual);\n                    }\n                    else {\n                        Utils.remove(this._adorners, adorner);\n                        this.adornerLayer.remove(adorner.visual);\n                    }\n                }\n            },\n\n            _showConnectors: function(shape, value) {\n                if (value) {\n                    this._connectorsAdorner.show(shape);\n                } else {\n                    this._connectorsAdorner.destroy();\n                }\n            },\n\n            _updateAdorners: function() {\n                var adorners = this._adorners;\n\n                for (var i = 0; i < adorners.length; i++) {\n                    var adorner = adorners[i];\n\n                    if (adorner.refreshBounds) {\n                        adorner.refreshBounds();\n                    }\n                    adorner.refresh();\n                }\n            },\n\n            _refresh: function() {\n                for (var i = 0; i < this.connections.length; i++) {\n                    this.connections[i].refresh();\n                }\n            },\n\n            _destroyToolBar: function() {\n                if (this.singleToolBar) {\n                    this.singleToolBar.hide();\n                    this.singleToolBar.destroy();\n                    this.singleToolBar = null;\n                }\n            },\n\n            _destroyGlobalToolBar: function() {\n                if (this.toolBar) {\n                    this.toolBar.hide();\n                    this.toolBar.destroy();\n                    this.toolBar = null;\n                }\n            },\n\n            exportDOMVisual: function() {\n                var viewBox = this.canvas._viewBox;\n                var scrollOffset = geom.transform()\n                                       .translate(-viewBox.x, -viewBox.y);\n\n                var viewRect = new geom.Rect([0, 0], [viewBox.width, viewBox.height]);\n                var clipPath = draw.Path.fromRect(viewRect);\n                var wrap = new draw.Group({ transform: scrollOffset });\n                var clipWrap = new draw.Group({ clip: clipPath });\n                var root = this.canvas.drawingElement.children[0];\n\n                clipWrap.append(wrap);\n\n                // Don't reparent the root\n                wrap.children.push(root);\n\n                return clipWrap;\n            },\n\n            exportVisual: function() {\n                var scale = geom.transform().scale(1 / this._zoom);\n                var wrap = new draw.Group({\n                    transform: scale\n                });\n\n                var root = this.mainLayer.drawingElement;\n                wrap.children.push(root);\n\n                return wrap;\n            },\n\n            _syncChanges: function() {\n                this._syncShapeChanges();\n                this._syncConnectionChanges();\n            },\n\n            _syncShapeChanges: function() {\n                if (this.dataSource && this._isEditable) {\n                    this.dataSource.sync();\n                }\n            },\n\n            _syncConnectionChanges: function() {\n                var that = this;\n                if (that.connectionsDataSource && that._isEditable) {\n                    $.when.apply($, that._deferredConnectionUpdates).then(function() {\n                        that.connectionsDataSource.sync();\n                    });\n                    that.deferredConnectionUpdates = [];\n                }\n            }\n        });\n\n        dataviz.ExportMixin.extend(Diagram.fn, true);\n\n        if (kendo.PDFMixin) {\n            kendo.PDFMixin.extend(Diagram.fn);\n        }\n\n        function filterShapeDataItem(dataItem) {\n            var result = {};\n\n            dataItem = dataItem || {};\n\n            if (defined(dataItem.text) && dataItem.text !== null) {\n                result.text = dataItem.text;\n            }\n\n            if (defined(dataItem.x) && dataItem.x !== null) {\n                result.x = dataItem.x;\n            }\n\n            if (defined(dataItem.y) && dataItem.y !== null) {\n                result.y = dataItem.y;\n            }\n\n            if (defined(dataItem.width) && dataItem.width !== null) {\n                result.width = dataItem.width;\n            }\n\n            if (defined(dataItem.height) && dataItem.height !== null) {\n                result.height = dataItem.height;\n            }\n\n            if (defined(dataItem.type) && dataItem.type !== null) {\n                result.type = dataItem.type;\n            }\n\n            return result;\n        }\n\n        function filterConnectionDataItem(dataItem) {\n            var result = {};\n\n            dataItem = dataItem || {};\n\n            if (defined(dataItem.text) && dataItem.text !== null) {\n                result.content = dataItem.text;\n            }\n\n            if (defined(dataItem.type) && dataItem.type !== null) {\n                result.type = dataItem.type;\n            }\n\n            if (defined(dataItem.from) && dataItem.from !== null) {\n                result.from = dataItem.from;\n            }\n\n            if (defined(dataItem.fromConnector) && dataItem.fromConnector !== null) {\n                result.fromConnector = dataItem.fromConnector;\n            }\n\n            if (defined(dataItem.fromX) && dataItem.fromX !== null) {\n                result.fromX = dataItem.fromX;\n            }\n\n            if (defined(dataItem.fromY) && dataItem.fromY !== null) {\n                result.fromY = dataItem.fromY;\n            }\n\n            if (defined(dataItem.to) && dataItem.to !== null) {\n                result.to = dataItem.to;\n            }\n\n            if (defined(dataItem.toConnector) && dataItem.toConnector !== null) {\n                result.toConnector = dataItem.toConnector;\n            }\n\n            if (defined(dataItem.toX) && dataItem.toX !== null) {\n                result.toX = dataItem.toX;\n            }\n\n            if (defined(dataItem.toY) && dataItem.toY !== null) {\n                result.toY = dataItem.toY;\n            }\n\n            return result;\n        }\n\n\n        var DiagramToolBar = kendo.Observable.extend({\n            init: function(diagram, options) {\n                kendo.Observable.fn.init.call(this);\n                this.diagram = diagram;\n                this.options = deepExtend({}, this.options, options);\n                this._tools = [];\n                this.createToolBar();\n                this.createTools();\n                this.appendTools();\n\n                if (this.options.modal) {\n                    this.createPopup();\n                }\n\n                this.bind(this.events, options);\n            },\n\n            events: [\"click\"],\n\n            createPopup: function() {\n                this.container = $(\"<div/>\").append(this.element);\n                this._popup = this.container.kendoPopup({}).getKendoPopup();\n            },\n\n            appendTools: function() {\n                for (var i = 0; i < this._tools.length; i++) {\n                    var tool = this._tools[i];\n                    if (tool.buttons && tool.buttons.length || !defined(tool.buttons)) {\n                        this._toolBar.add(tool);\n                    }\n                }\n            },\n\n            createToolBar: function() {\n                this.element = $(\"<div/>\");\n                this._toolBar = this.element\n                    .kendoToolBar({\n                        click: this.click.bind(this),\n                        resizable: false\n                    }).getKendoToolBar();\n\n                this.element.css(\"border\", \"none\");\n            },\n\n            createTools: function() {\n                for (var i = 0; i < this.options.tools.length; i++) {\n                    this.createTool(this.options.tools[i]);\n                }\n            },\n\n            createTool: function(tool) {\n                if (!isPlainObject(tool)) {\n                    tool = {\n                        name: tool\n                    };\n                }\n                var toolName = tool.name + \"Tool\";\n                if (this[toolName]) {\n                    this[toolName](tool);\n                } else {\n                    this._tools.push(deepExtend({}, tool, {\n                        attributes: this._setAttributes({ action: tool.name })\n                    }));\n                }\n            },\n\n            showAt: function(point) {\n                var popupZIndex = parseInt(this.options.popupZIndex, 10);\n\n                if (this._popup) {\n                    this._popup.open(point.x, point.y);\n\n                    if (popupZIndex) {\n                        this._popup.wrapper.css(\"zIndex\", popupZIndex);\n                    }\n                }\n            },\n\n            hide: function() {\n                if (this._popup) {\n                    this._popup.close();\n                }\n            },\n\n            newGroup: function() {\n                return {\n                    type: \"buttonGroup\",\n                    buttons: []\n                };\n            },\n\n            editTool: function() {\n                this._tools.push({\n                    icon: \"pencil\",\n                    showText: \"overflow\",\n                    type: \"button\",\n                    text: \"Edit\",\n                    attributes: this._setAttributes({ action: \"edit\" })\n                });\n            },\n\n            deleteTool: function() {\n                this._tools.push({\n                    icon: \"x\",\n                    showText: \"overflow\",\n                    type: \"button\",\n                    text: \"Delete\",\n                    attributes: this._setAttributes({ action: \"delete\" })\n                });\n            },\n\n            rotateAnticlockwiseTool: function(options) {\n                this._appendGroup(\"rotate\");\n                this._rotateGroup.buttons.push({\n                    icon: \"rotate-left\",\n                    showText: \"overflow\",\n                    text: \"RotateAnticlockwise\",\n                    group: \"rotate\",\n                    attributes: this._setAttributes({ action: \"rotateAnticlockwise\", step: options.step })\n                });\n            },\n\n            rotateClockwiseTool: function(options) {\n                this._appendGroup(\"rotate\");\n                this._rotateGroup.buttons.push({\n                    icon: \"rotate-right\",\n                    attributes: this._setAttributes({ action: \"rotateClockwise\", step: options.step }),\n                    showText: \"overflow\",\n                    text: \"RotateClockwise\",\n                    group: \"rotate\"\n                });\n            },\n\n            createShapeTool: function() {\n                this._appendGroup(\"create\");\n                this._createGroup.buttons.push({\n                    icon: \"shapes\",\n                    showText: \"overflow\",\n                    text: \"CreateShape\",\n                    group: \"create\",\n                    attributes: this._setAttributes({ action: \"createShape\" })\n                });\n            },\n\n            createConnectionTool: function() {\n                this._appendGroup(\"create\");\n                this._createGroup.buttons.push({\n                    icon: \"connector\",\n                    showText: \"overflow\",\n                    text: \"CreateConnection\",\n                    group: \"create\",\n                    attributes: this._setAttributes({ action: \"createConnection\" })\n                });\n            },\n\n            undoTool: function() {\n                this._appendGroup(\"history\");\n                this._historyGroup.buttons.push({\n                    icon: \"undo\",\n                    showText: \"overflow\",\n                    text: \"Undo\",\n                    group: \"history\",\n                    attributes: this._setAttributes({ action: \"undo\" })\n                });\n            },\n\n            redoTool: function() {\n                this._appendGroup(\"history\");\n                this._historyGroup.buttons.push({\n                    icon: \"redo\",\n                    showText: \"overflow\",\n                    text: \"Redo\",\n                    group: \"history\",\n                    attributes: this._setAttributes({ action: \"redo\" })\n                });\n            },\n\n            _appendGroup: function(name) {\n                var prop = \"_\" + name + \"Group\";\n                if (!this[prop]) {\n                    this[prop] = this.newGroup();\n                    this._tools.push(this[prop]);\n                }\n            },\n\n            _setAttributes: function(attributes) {\n                var attr = {};\n\n                if (attributes.action) {\n                    attr[kendo.attr(\"action\")] = attributes.action;\n                }\n\n                if (attributes.step) {\n                    attr[kendo.attr(\"step\")] = attributes.step;\n                }\n\n                return attr;\n            },\n\n            _getAttributes: function(element) {\n                var attr = {};\n\n                var action = element.attr(kendo.attr(\"action\"));\n                if (action) {\n                    attr.action = action;\n                }\n\n                var step = element.attr(kendo.attr(\"step\"));\n                if (step) {\n                    attr.step = step;\n                }\n\n                return attr;\n            },\n\n            click: function(e) {\n                var attributes = this._getAttributes($(e.target));\n                var action = attributes.action;\n\n                if (action && this[action]) {\n                    this[action](attributes);\n                }\n\n                this.trigger(\"click\", this.eventData(action, e.target));\n            },\n\n            eventData: function(action, target) {\n                var elements = this.selectedElements(),\n                    length = elements.length,\n                    shapes = [], connections = [], element;\n\n                for (var idx = 0; idx < length; idx++) {\n                    element = elements[idx];\n                    if (element instanceof Shape) {\n                        shapes.push(element);\n                    } else {\n                        connections.push(element);\n                    }\n                }\n\n                return {\n                    shapes: shapes,\n                    connections: connections,\n                    action: action,\n                    target: target\n                };\n            },\n\n            \"delete\": function() {\n                var diagram = this.diagram;\n                var toRemove = diagram._triggerRemove(this.selectedElements());\n                if (toRemove.length) {\n                    this.diagram.remove(toRemove, true);\n                    this.diagram._syncChanges();\n                }\n            },\n\n            edit: function() {\n                var selectedElemens = this.selectedElements();\n                if (selectedElemens.length === 1) {\n                    this.diagram.edit(selectedElemens[0]);\n                }\n            },\n\n            rotateClockwise: function(options) {\n                var angle = parseFloat(options.step || 90);\n                this._rotate(angle);\n            },\n\n            rotateAnticlockwise: function(options) {\n                var angle = parseFloat(options.step || 90);\n                this._rotate(-angle);\n            },\n\n            _rotate: function(angle) {\n                var adorner = this.diagram._resizingAdorner;\n                adorner.angle(adorner.angle() + angle);\n                adorner.rotate();\n            },\n\n            selectedElements: function() {\n                return this.diagram.select();\n            },\n\n            createShape: function() {\n                this.diagram.createShape();\n            },\n\n            createConnection: function() {\n                this.diagram.createConnection();\n            },\n\n            undo: function() {\n                this.diagram.undo();\n            },\n\n            redo: function() {\n                this.diagram.redo();\n            },\n\n            destroy: function() {\n                this.diagram = null;\n                this.element = null;\n                this.options = null;\n\n                if (this._toolBar) {\n                    this._toolBar.destroy();\n                }\n\n                if (this._popup) {\n                    this._popup.destroy();\n                }\n            }\n        });\n\n        var Editor = kendo.Observable.extend({\n            init: function(element, options) {\n                kendo.Observable.fn.init.call(this);\n\n                this.options = extend(true, {}, this.options, options);\n                this.element = element;\n                this.model = this.options.model;\n                this.fields = this._getFields();\n                this._initContainer();\n                this.createEditable();\n            },\n\n            options: {\n                editors: {}\n            },\n\n            _initContainer: function() {\n                this.wrapper = this.element;\n            },\n\n            createEditable: function() {\n                var options = this.options;\n\n                this.editable = new kendo.ui.Editable(this.wrapper, {\n                    fields: this.fields,\n                    target: options.target,\n                    clearContainer: false,\n                    model: this.model\n                });\n            },\n\n            _isEditable: function(field) {\n                return this.model.editable && this.model.editable(field);\n            },\n\n            _getFields: function() {\n                var fields = [];\n                var modelFields = this.model.fields;\n\n                for (var field in modelFields) {\n                    var result = {};\n                    if (this._isEditable(field)) {\n                        var editor = this.options.editors[field];\n                        if (editor) {\n                            result.editor = editor;\n                        }\n                        result.field = field;\n                        fields.push(result);\n                    }\n                }\n\n                return fields;\n            },\n\n            end: function() {\n                return this.editable.end();\n            },\n\n            destroy: function() {\n                this.editable.destroy();\n                this.editable.element.find(\"[\" + kendo.attr(\"container-for\") + \"]\").empty();\n                this.model = this.wrapper = this.element = this.columns = this.editable = null;\n            }\n        });\n\n        var PopupEditor = Editor.extend({\n            init: function(element, options) {\n                Editor.fn.init.call(this, element, options);\n                this.bind(this.events, this.options);\n\n                this.open();\n            },\n\n            events: [ \"update\", \"cancel\" ],\n\n            options: {\n                window: {\n                    modal: true,\n                    resizable: false,\n                    draggable: true,\n                    title: \"Edit\",\n                    visible: false\n                }\n            },\n\n            _initContainer: function() {\n                var that = this;\n                this.wrapper = $('<div class=\"k-popup-edit-form\"/>')\n                    .attr(kendo.attr(\"uid\"), this.model.uid);\n\n                var formContent = \"\";\n\n                if (this.options.template) {\n                    formContent += this._renderTemplate();\n                    this.fields = [];\n                } else {\n                    formContent += this._renderFields();\n                }\n\n                formContent += this._renderButtons();\n\n                this.wrapper.append(\n                    $('<div class=\"k-edit-form-container\"/>').append(formContent));\n\n                this.window = new kendo.ui.Window(this.wrapper.appendTo(this.element), this.options.window);\n                this.window.bind(\"close\", function(e) {\n                    //The bellow line is required due to: draggable window in IE, change event will be triggered while the window is closing\n                    if (e.userTriggered) {\n                        e.sender.element.trigger(\"focus\");\n                        that._cancelClick(e);\n                    }\n                });\n\n                this._attachButtonEvents();\n            },\n\n            _renderTemplate: function() {\n                var template = this.options.template;\n\n                if (typeof template === \"string\") {\n                    template = kendo.unescape(template);\n                }\n\n                template = kendo.template(template)(this.model);\n\n                return template;\n            },\n\n            _renderFields: function() {\n                var form = \"\";\n                for (var i = 0; i < this.fields.length; i++) {\n                    var field = this.fields[i];\n\n                    form += '<div class=\"k-edit-label\"><label for=\"' + field.field + '\">' + (field.field || \"\") + '</label></div>';\n\n                    if (this._isEditable(field.field)) {\n                        form += '<div ' + kendo.attr(\"container-for\") + '=\"' + field.field +\n                        '\" class=\"k-edit-field\"></div>';\n                    }\n                }\n\n                return form;\n            },\n\n            _renderButtons: function() {\n                var form = '<div class=\"k-edit-buttons\">';\n                form += this._createButton(\"update\");\n                form += this._createButton(\"cancel\");\n                form += '</div>';\n                return form;\n            },\n\n            _createButton: function(name) {\n                return kendo.template(BUTTON_TEMPLATE)(defaultButtons[name]);\n            },\n\n            _attachButtonEvents: function() {\n                this._cancelClickHandler = this._cancelClick.bind(this);\n                this.window.element.on(CLICK + NS, \"button.k-diagram-cancel\", this._cancelClickHandler);\n\n                this._updateClickHandler = this._updateClick.bind(this);\n                this.window.element.on(CLICK + NS, \"button.k-diagram-update\", this._updateClickHandler);\n            },\n\n            _updateClick: function(e) {\n                e.preventDefault();\n                this.trigger(\"update\");\n            },\n\n            _cancelClick: function(e) {\n                e.preventDefault();\n                this.trigger(\"cancel\");\n            },\n\n            open: function() {\n                this.window.center().open();\n            },\n\n            close: function() {\n                this.window.bind(\"deactivate\", this.destroy.bind(this)).close();\n            },\n\n            destroy: function() {\n                this.window.close().destroy();\n                this.window.element.off(CLICK + NS, \"a.k-diagram-cancel\", this._cancelClickHandler);\n                this.window.element.off(CLICK + NS, \"a.k-diagram-update\", this._updateClickHandler);\n                this._cancelClickHandler = null;\n                this._editUpdateClickHandler = null;\n                this.window = null;\n                Editor.fn.destroy.call(this);\n            }\n        });\n\n        function connectionSelector(container, options) {\n            var model = this.dataSource.reader.model;\n            if (model) {\n                var textField = model.fn.fields.text ? \"text\" : model.idField;\n                $(\"<input name='\" + options.field + \"' />\")\n                    .appendTo(container).kendoDropDownList({\n                        dataValueField: model.idField,\n                        dataTextField: textField,\n                        dataSource: this.dataSource.data().toJSON(),\n                        optionLabel: \" \",\n                        valuePrimitive: true\n                    });\n            }\n        }\n\n        function InactiveItem(dataItem) {\n            this.dataItem = dataItem;\n            this.callbacks = [];\n        }\n\n        InactiveItem.fn = InactiveItem.prototype = {\n            onActivate: function(callback) {\n                var deffered = $.Deferred();\n                this.callbacks.push({\n                    callback: callback,\n                    deferred: deffered\n                });\n                return deffered;\n            },\n\n            activate: function() {\n                var callbacks = this.callbacks;\n                var item;\n                for (var idx = 0; idx < callbacks.length; idx++) {\n                    item = this.callbacks[idx];\n                    item.callback(this.dataItem);\n                    item.deferred.resolve();\n                }\n                this.callbacks = [];\n            }\n        };\n\n        function InactiveItemsCollection() {\n            this.items = {};\n        }\n\n        InactiveItemsCollection.fn = InactiveItemsCollection.prototype = {\n            add: function(items) {\n                for (var idx = 0; idx < items.length; idx++) {\n                    this.items[items[idx].uid] = new InactiveItem(items[idx]);\n                }\n            },\n\n            forEach: function(callback) {\n                for (var uid in this.items) {\n                    callback(this.items[uid]);\n                }\n            },\n\n            getByUid: function(uid) {\n                return this.items[uid];\n            },\n\n            remove: function(item) {\n                delete this.items[item.uid];\n            }\n        };\n\n        var QuadRoot = Class.extend({\n            init: function() {\n                this.shapes = [];\n            },\n\n            _add: function(shape, bounds) {\n                this.shapes.push({\n                    bounds: bounds,\n                    shape: shape\n                });\n                shape._quadNode = this;\n            },\n\n            insert: function(shape, bounds) {\n                this._add(shape, bounds);\n            },\n\n            remove: function(shape) {\n                var shapes = this.shapes;\n                var length = shapes.length;\n\n                for (var idx = 0; idx < length; idx++) {\n                    if (shapes[idx].shape === shape) {\n                        shapes.splice(idx, 1);\n                        break;\n                    }\n                }\n            },\n\n            hitTestRect: function(rect, exclude) {\n                var shapes = this.shapes;\n                var length = shapes.length;\n\n                for (var i = 0; i < length; i++) {\n                    if (this._testRect(shapes[i].shape, rect) && !dataviz.inArray(shapes[i].shape, exclude)) {\n                        return true;\n                    }\n                }\n            },\n\n            _testRect: function(shape, rect) {\n                var angle = shape.rotate().angle;\n                var bounds = shape.bounds();\n                var hit;\n                if (!angle) {\n                    hit = bounds.overlaps(rect);\n                } else {\n                    hit = Intersect.rects(rect, bounds, -angle);\n                }\n                return hit;\n            }\n        });\n\n        var QuadNode = QuadRoot.extend({\n            init: function(rect) {\n                QuadRoot.fn.init.call(this);\n                this.children = [];\n                this.rect = rect;\n            },\n\n            inBounds: function(rect) {\n                var nodeRect = this.rect;\n                var nodeBottomRight = nodeRect.bottomRight();\n                var bottomRight = rect.bottomRight();\n                var inBounds = nodeRect.x <= rect.x && nodeRect.y <= rect.y && bottomRight.x <= nodeBottomRight.x &&\n                    bottomRight.y <= nodeBottomRight.y;\n                return inBounds;\n            },\n\n            overlapsBounds: function(rect) {\n                return this.rect.overlaps(rect);\n            },\n\n            insert: function(shape, bounds) {\n                var inserted = false;\n                var children = this.children;\n                var length = children.length;\n                if (this.inBounds(bounds)) {\n                    if (!length && this.shapes.length < 4) {\n                        this._add(shape, bounds);\n                    } else {\n                        if (!length) {\n                            this._initChildren();\n                        }\n\n                        for (var idx = 0; idx < children.length; idx++) {\n                            if (children[idx].insert(shape, bounds)) {\n                                inserted = true;\n                                break;\n                            }\n                        }\n\n                        if (!inserted) {\n                            this._add(shape, bounds);\n                        }\n                    }\n                    inserted = true;\n                }\n\n                return inserted;\n            },\n\n            _initChildren: function() {\n                var rect = this.rect,\n                    children = this.children,\n                    shapes = this.shapes,\n                    center = rect.center(),\n                    halfWidth = rect.width / 2,\n                    halfHeight = rect.height / 2,\n                    childIdx, shapeIdx;\n\n                children.push(\n                    new QuadNode(new Rect(rect.x, rect.y, halfWidth, halfHeight)),\n                    new QuadNode(new Rect(center.x, rect.y, halfWidth, halfHeight)),\n                    new QuadNode(new Rect(rect.x, center.y, halfWidth, halfHeight)),\n                    new QuadNode(new Rect(center.x, center.y, halfWidth, halfHeight))\n                );\n                for (shapeIdx = shapes.length - 1; shapeIdx >= 0; shapeIdx--) {\n                    for (childIdx = 0; childIdx < children.length; childIdx++) {\n                        if (children[childIdx].insert(shapes[shapeIdx].shape, shapes[shapeIdx].bounds)) {\n                            shapes.splice(shapeIdx, 1);\n                            break;\n                        }\n                    }\n                }\n            },\n\n            hitTestRect: function(rect, exclude) {\n                var idx;\n                var children = this.children;\n                var length = children.length;\n                var hit = false;\n\n                if (this.overlapsBounds(rect)) {\n                    if (QuadRoot.fn.hitTestRect.call(this, rect, exclude)) {\n                        hit = true;\n                    } else {\n                         for (idx = 0; idx < length; idx++) {\n                            if (children[idx].hitTestRect(rect, exclude)) {\n                               hit = true;\n                               break;\n                            }\n                        }\n                    }\n                }\n\n                return hit;\n            }\n        });\n\n        var ShapesQuadTree = Class.extend({\n            ROOT_SIZE: 1000,\n\n            init: function(diagram) {\n                var boundsChangeHandler = this._boundsChange.bind(this);\n                diagram.bind(ITEMBOUNDSCHANGE, boundsChangeHandler);\n                diagram.bind(ITEMROTATE, boundsChangeHandler);\n                this.initRoots();\n            },\n\n            initRoots: function() {\n                this.rootMap = {};\n                this.root = new QuadRoot();\n            },\n\n            clear: function() {\n                this.initRoots();\n            },\n\n            _boundsChange: function(e) {\n                if (e.item._quadNode) {\n                    e.item._quadNode.remove(e.item);\n                }\n                this.insert(e.item);\n            },\n\n            insert: function(shape) {\n                var bounds = shape.bounds(ROTATED);\n                var rootSize = this.ROOT_SIZE;\n                var sectors = this.getSectors(bounds);\n                var x = sectors[0][0];\n                var y = sectors[1][0];\n\n                if (this.inRoot(sectors)) {\n                    this.root.insert(shape, bounds);\n                } else {\n                    if (!this.rootMap[x]) {\n                        this.rootMap[x] = {};\n                    }\n\n                    if (!this.rootMap[x][y]) {\n                        this.rootMap[x][y] = new QuadNode(\n                            new Rect(x * rootSize, y * rootSize, rootSize, rootSize)\n                        );\n                    }\n\n                    this.rootMap[x][y].insert(shape, bounds);\n                }\n            },\n\n            remove: function(shape) {\n                if (shape._quadNode) {\n                    shape._quadNode.remove(shape);\n                }\n            },\n\n            inRoot: function(sectors) {\n                return sectors[0].length > 1 || sectors[1].length > 1;\n            },\n\n            getSectors: function(rect) {\n                var rootSize = this.ROOT_SIZE;\n                var bottomRight = rect.bottomRight();\n                var bottomX = math.floor(bottomRight.x / rootSize);\n                var bottomY = math.floor(bottomRight.y / rootSize);\n                var sectors = [[],[]];\n                for (var x = math.floor(rect.x / rootSize); x <= bottomX; x++) {\n                    sectors[0].push(x);\n                }\n                for (var y = math.floor(rect.y / rootSize); y <= bottomY; y++) {\n                    sectors[1].push(y);\n                }\n                return sectors;\n            },\n\n            hitTestRect: function(rect, exclude) {\n                var sectors = this.getSectors(rect);\n                var xIdx, yIdx, x, y;\n                var root;\n\n                if (this.root.hitTestRect(rect, exclude)) {\n                    return true;\n                }\n\n                for (xIdx = 0; xIdx < sectors[0].length; xIdx++) {\n                    x = sectors[0][xIdx];\n                    for (yIdx = 0; yIdx < sectors[1].length; yIdx++) {\n                        y = sectors[1][yIdx];\n                        root = (this.rootMap[x] || {})[y];\n                        if (root && root.hitTestRect(rect, exclude)) {\n                            return true;\n                        }\n                    }\n                }\n\n                return false;\n            }\n        });\n\n        function cloneDataItem(dataItem) {\n            var result = dataItem;\n            if (dataItem instanceof kendo.data.Model) {\n                result = dataItem.toJSON();\n                result[dataItem.idField] = dataItem._defaultId;\n            }\n            return result;\n        }\n\n        function splitDiagramElements(elements) {\n            var connections = [];\n            var shapes = [];\n            var element, idx;\n            for (idx = 0; idx < elements.length; idx++) {\n                element = elements[idx];\n                if (element instanceof Shape) {\n                    shapes.push(element);\n                } else {\n                    connections.push(element);\n                }\n            }\n            return {\n                shapes: shapes,\n                connections: connections\n            };\n        }\n\n        function createModel(dataSource, model) {\n            if (dataSource.reader.model) {\n                return new dataSource.reader.model(model);\n            }\n\n            return new kendo.data.ObservableObject(model);\n        }\n\n        function clearField(field, model) {\n            if (defined(model[field])) {\n                model.set(field, null);\n            }\n        }\n\n        function copyDefaultOptions(mainOptions, elementOptions, fields) {\n            var field;\n            for (var idx = 0; idx < fields.length; idx++) {\n                field = fields[idx];\n                if (elementOptions && !defined(elementOptions[field])) {\n                    elementOptions[field] = mainOptions[field];\n                }\n            }\n        }\n\n        function translateToOrigin(visual) {\n            var bbox = visual.drawingContainer().clippedBBox(null);\n            if (bbox.origin.x !== 0 || bbox.origin.y !== 0) {\n                visual.position(-bbox.origin.x, -bbox.origin.y);\n            }\n        }\n\n        function preventDefault(e) {\n            e.preventDefault();\n        }\n\n        dataviz.ui.plugin(Diagram);\n\n        deepExtend(diagram, {\n            Shape: Shape,\n            Connection: Connection,\n            Connector: Connector,\n            DiagramToolBar: DiagramToolBar,\n            QuadNode: QuadNode,\n            QuadRoot: QuadRoot,\n            ShapesQuadTree: ShapesQuadTree,\n            PopupEditor: PopupEditor\n        });\n})(window.kendo.jQuery);\n\nvar __meta__ = {\n        id: \"dataviz.diagram\",\n        name: \"Diagram\",\n        category: \"dataviz\",\n        description: \"The Kendo DataViz Diagram \",\n        depends: [ \"data\", \"userevents\", \"mobile.scroller\", \"draganddrop\", \"drawing\", \"dataviz.core\", \"dataviz.themes\", \"toolbar\" ],\n        features: [{\n            id: \"dataviz.diagram-pdf-export\",\n            name: \"PDF export\",\n            description: \"Export Diagram as PDF\",\n            depends: [ \"pdf\" ]\n        },{\n            id: \"dataviz.diagram-editing\",\n            name: \"Editing\",\n            description: \"Support for model editing\",\n            depends: [ \"editable\", \"window\", \"dropdownlist\" ]\n        }]\n    };\n    var kendo$1 = kendo;\n\nexport { kendo$1 as default };\n"]}