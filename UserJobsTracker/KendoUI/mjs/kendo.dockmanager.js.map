{"version":3,"sources":["raw-mjs/kendo.dockmanager.js"],"names":["__meta__","id","name","category","description","depends","$","undefined$1","kendo","window","Widget","ui","NS","extend","percentageUnitsRegex","DOCK_MANAGER_TOOLBAR","isPlainObject","TOOLBAR_TEMPLATE","KSTATIC_PANE","KPANE_TABBED","SPLITTER","KSPLITBAR","PANE_SIZING_PROP","HORIZONTAL","VERTICAL","KHIDDEN","KBUTTON","MAX_NUMBER_VALUE","Number","MAX_SAFE_INTEGER","KPANE","KPANES_CONTAINER","KPANE_ACTIONS","KDOCK_INDICATOR","KDOCK_NAVIGATOR","KDOCK_PREVIEW","KSELECTED","KACTIVE","KTABSTRIP","KSPLITBAR_DRAGGABLE","SPLIT","TAB","HEIGHT","WIDTH","TOP","BOTTOM","LEFT","RIGHT","MIDDLE","CLICK","PIN","UNPIN","UNSHIFT","PANE","paneSelector","uid","attr","unpinnedResizeSplitbar","UID_ATTR","INDICATOR_ATTR","ACTION_ATTR","INDICATOR_TEMPLATE","NAVIGATOR_TEMPLATE","CLOSE","DOCK","INNER_DOCK","RESIZE","DRAG","DRAGSTART","DRAGEND","isPercentageSize","size","test","DockSplitter","init","element","options","that","this","fn","call","_marker","guid","substring","addClass","orientation","_initPanes","_initResizable","notify","panes","events","paneElements","children","panesCount","length","sizedPanes","i","paneElement","eq","pane","css","collapsed","splitter","insertAfter","push","pop","markerAttribute","_resizable","Resizable","handle","clickMoveClick","invalidClass","resizeend","find","remove","resize","e","delta","splitterBarIndex","_getElementIndex","currentTarget","splitterBar","rtlModifier","support","isRtl","x","y","leftPane","rightPane","_dragSplitterBar","trigger","start","_onResizeStart","bind","_getAdjacentPanes","leftPaneNewSize","computedSize","isLeftPaneSizeInBounds","min","max","panesWithoutSize","_getPaneElements","filter","style","canResizeBothPanes","_resizePane","leftPaneIndex","rightPaneIndex","leftPaneELement","_getPaneElement","rightPaneELement","_getPane","leftPaneSize","_getPaneOffsetSize","rightPaneSize","totalPaneSize","splitterSize","_getElementClientSize","getPixelSize","paneSize","_calculatePixelSize","leftPaneMaxSize","rightPaneMaxSize","_getAdjacentPanesMaxSize","rightMaxPixelSize","leftMaxPixelSize","index","collapsible","constrainedSize","value","Math","newSize","toPercentages","parseFloat","toPixel","_setPaneSize","_allExpandedPanesHaveSize","expandedPanes","paneIndex","_getPaneSizes","containerSize","numericSize","_getElementOffsetSize","rect","getBoundingClientRect","width","height","_getElementSize","sizeType","_getPaneIndex","indexOf","leftPaneMinSize","leftPaneMaxPixelSize","rightPaneMinSize","rightPaneMaxPixelSize","stopPropagation","_addResizeOverlays","_addResizeOverlay","overlay","append","Array","from","hasClass","childrenSelector","parent","matches","destroy","off","empty","DockManager","panesContainer","appendTo","_processPanes","rootPane","_refreshToolbar","_createPane","_bindEvents","_initNavigator","_initUnpinnedResizable","type","paneDefaults","visible","closeable","actions","icon","shouldAdd","unpinnable","unpinned","minimizable","maximizable","indicators","top","left","transform","previewTop","previewLeft","rotate","hoveredPaneHeight","draggedPaneHeight","hoveredPaneWidth","draggedPaneWidth","togglePane","_getPaneById","_togglePane","removePane","_removePane","getOptions","setOptions","currentOptions","deepExtend","_unpinnedResizable","unpinnedContainer","containerWidth","on","_toolbarButtonClick","_hideUnpinnedPanes","_pinPaneClick","_closePane","_displayDockPreview","_hideDockPreview","currentlyOpened","unpinnedContainerVisible","is","_toolbar","removeClass","itemUid","preventDefault","_showUnpinnedPane","paneUid","toolbarWidth","outerWidth","_findPaneByUid","hasUnpinnedSize","unpinnedSize","button","isTabbed","action","closest","isUnpinned","parentPane","parentUid","eventData","_refreshRootPane","toggleClass","event","splice","_shouldHideParent","some","_refreshPane","parentElement","_extendPane","forEach","childPane","j","subItem","unpinnedPanes","_unpinnedPanes","unpinnedPannesContainer","insertBefore","prepend","html","renderButton","fillMode","_paneHeader","wrapper","refresh","rootPaneElement","_createSplitPane","splitterElement","splitterOptions","paneOptions","_createUnpinnedPane","_updatePaneSize","ev","_createTabPane","tabStripElement","tabContainer","selectedPane","selected","tab","title","contentElement","_addActions","kendoTabStrip","animation","_createContentPane","content","template","data","isUnnpinned","actionsContainer","string","charAt","toUpperCase","slice","result","concat","header","tabHeader","found","prop","params","navigatorDraggable","Draggable","autoScroll","hint","actionsHtml","_getActionButtons","hintTemplate","dragstart","_dragStart","dragend","_dragEnd","drag","_drag","target","draggedPane","_displayGlobalIndicators","draggableEvent","hoveredIndicator","hide","_updateLayout","_showHiddenPanes","hoveredPane","currentPane","elementUnderCursor","navigator","currentPaneUid","prevPaneUid","position","dockable","innerDock","_showTab","_showPane","tabstrip","show","activateTab","splitbar","siblings","_hideDraggedPane","draggedElement","_hideTab","_hidePane","prevElement","prev","nextElement","next","isActive","buttons","container","each","_","clone","indicator","isGlobalIndicator","indicatorName","indicatorUid","indicatorData","previewElement","containerHeight","outerHeight","existingPreview","preview","location","draggedPaneParent","draggedPaneIndex","_tabDock","_splitDock","_adjustSiblingSizes","targetPane","isGlobalDock","targetPaneParent","targetPaneIndex","dimension","newParentPane","unshift","_getSiblings","parentSize","draggedPaneSize","newParentSize","noSizePanes","freeSpace","_calculateNewSize","noSizePane","proportion","noUnitSize","unit","replace","p","plugin","jQuery","kendo$1"],"mappings":"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","file":"kendo.dockmanager.js","sourcesContent":["import './kendo.core.js';\nimport './kendo.splitter.js';\nimport './kendo.tabstrip.js';\nimport './kendo.window.js';\nimport './kendo.html.button.js';\nimport './kendo.resizable.js';\nimport './kendo.draganddrop.js';\n\nconst __meta__ = {\n    id: \"dockManager\",\n    name: \"DockManager\",\n    category: \"web\",\n    description: \"The DockManager widget represents a layout component that allows users to achieve custom layouts by docking panes.\",\n    depends: [\"core\", \"splitter\", \"tabstrip\", \"window\", \"html.button\"]\n};\n\n(function($, undefined$1) {\n    const kendo = window.kendo,\n        Widget = kendo.ui.Widget,\n        NS = \".kendoDockManager\",\n        ui = kendo.ui,\n        extend = $.extend,\n        pxUnitsRegex = /^\\d+(\\.\\d+)?px$/i,\n        percentageUnitsRegex = /^\\d+(\\.\\d+)?%$/i,\n        isPlainObject = $.isPlainObject,\n        DOCK_MANAGER = \"k-dock-manager\",\n        DOCK_MANAGER_TOOLBAR = \"k-dock-manager-toolbar\",\n        TOOLBAR_TEMPLATE = `<div class=\"${DOCK_MANAGER_TOOLBAR} k-toolbar-left k-toolbar k-toolbar-md\"></div>`,\n        TOOLBAR_BUTTON = \"k-toolbar-button\",\n        SEPARATOR = `<div class=\"k-separator k-separator-horizontal\"></div>`,\n        KSTATIC_PANE = \"k-pane-static\",\n        KKPINNED_PANE = \"k-pane-pinned\",\n        KPANE_TABBED = \"k-pane-tabbed\",\n        SPLITTER = \"k-splitter\",\n        KSPLITBAR = \"k-splitbar\",\n        SPLITTER_FLEX = \"k-splitter-flex\",\n        DOCK_SPLITTER = \"k-dock-manager-splitter\",\n        KUNPINNED_CONTAINER = \"k-dock-manager-unpinned-container\",\n        PANE_SIZING_PROP = \"flex-basis\",\n        HORIZONTAL = \"horizontal\",\n        VERTICAL = \"vertical\",\n        KHIDDEN = \"k-hidden\",\n        KBUTTON = \"k-button\",\n        MAX_NUMBER_VALUE = Number.MAX_SAFE_INTEGER,\n        KPANE = \"k-pane\",\n        KPANE_FLEX = \"k-pane-flex\",\n        KPANES_CONTAINER = \"k-dock-manager-pane-container\",\n        KPANE_SCROLLABLE = \"k-pane-scrollable\",\n        KPANE_ACTIONS = \"k-pane-actions\",\n        KDOCK_INDICATOR = \"k-dock-indicator\",\n        KDOCK_NAVIGATOR = \"k-dock-navigator\",\n        KDOCK_PREVIEW = \"k-docking-preview\",\n        KSELECTED = \"k-selected\",\n        KACTIVE = \"k-active\",\n        KTABSTRIP = \"k-tabstrip\",\n        KSPLITBAR_DRAGGABLE = \"k-splitbar-draggable\",\n        SPLIT = \"split\",\n        TAB = \"tab\",\n        CONTENT = \"content\",\n        HEIGHT = \"height\",\n        WIDTH = \"width\",\n        TOP = \"top\",\n        BOTTOM = \"bottom\",\n        LEFT = \"left\",\n        RIGHT = \"right\",\n        MIDDLE = \"middle\",\n        CLICK = \"click\",\n        PIN = \"pin\",\n        UNPIN = \"unpin\",\n        UNSHIFT = \"unshift\",\n        PUSH = \"push\",\n        PANE = `<div class=\"${KPANE} ${KPANE_FLEX} ${KSTATIC_PANE}\"></div>`,\n        paneSelector = uid => `.${KPANE}[${kendo.attr(\"uid\")}=\"${uid}\"]`,\n        buttonTextTemplate = text => `<span class=\"k-button-text\">${text}</span>`,\n        contentPaneTemplate = data => `<div class=\"${KPANE_SCROLLABLE}\">\n                                            <div class=\"k-pane-header\">\n                                                <span class=\"k-pane-title\">${data.title}</span>\n                                                <div class=\"${KPANE_ACTIONS}\"></div>\n                                            </div>\n                                            <div class=\"k-pane-content\">${data.content}</div>\n                                        </div>`,\n        tabTemplate = title => `<li><span class=\"k-link\">${title}</span></li>`,\n        unpinnedResizeSplitbar = `<div class=\"k-splitbar k-splitbar-horizontal ${KSPLITBAR_DRAGGABLE}-horizontal\">\n                                    <div class=\"k-resize-handle\"></div>\n                                </div>`,\n        UID_ATTR = kendo.attr(\"uid\"),\n        INDICATOR_ATTR = kendo.attr(\"indicator\"),\n        ACTION_ATTR = kendo.attr(\"action\"),\n        hintTemplate = pane => `<div class=\"k-tooltip k-tooltip-primary\">\n                                    <div class=\"k-tooltip-content\">${pane.title}</div>\n                                </div>`,\n        INDICATOR_TEMPLATE = `<div class=\"${KDOCK_INDICATOR}\">\n                        <span class=\"k-svg-icon k-icon-xl k-svg-i-position-top\">\n                        <svg aria-hidden=\"true\" focusable=\"false\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\">\n                            <path d=\"M480 448V32H32v448h448v-32zm-416 0V64h384v384H64zM96 96h320v96H96z\"></path>\n                        </svg>\n                        </span>\n                    </div>`,\n        NAVIGATOR_TEMPLATE = `<div class=\"${KDOCK_NAVIGATOR}\" style=\"position: relative;\">\n                                <div class=\"k-dock-indicator k-dock-indicator-top\" ${INDICATOR_ATTR}=\"top\">\n                                <span class=\"k-svg-icon k-icon-xl k-svg-i-position-top\">\n                                    <svg aria-hidden=\"true\" focusable=\"false\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\">\n                                        <path d=\"M480 448V32H32v448h448v-32zm-416 0V64h384v384H64zM96 96h320v96H96z\"></path>\n                                    </svg>\n                                </span>\n                                </div>\n                                <div class=\"k-dock-indicator k-dock-indicator-right\" ${INDICATOR_ATTR}=\"right\">\n                                <span class=\"k-svg-icon k-icon-xl k-svg-i-position-right\">\n                                    <svg aria-hidden=\"true\" focusable=\"false\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\">\n                                        <path d=\"M64 480h416V32H32v448h32zm0-416h384v384H64V64zm256 32h96v320h-96z\"></path>\n                                    </svg>\n                                </span>\n                                </div>\n                                <div class=\"k-dock-indicator k-dock-indicator-bottom\" ${INDICATOR_ATTR}=\"bottom\">\n                                <span class=\"k-svg-icon k-icon-xl k-svg-i-position-bottom\">\n                                    <svg aria-hidden=\"true\" focusable=\"false\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\">\n                                        <path d=\"M32 64v416h448V32H32v32zm416 0v384H64V64h384zM96 320h320v96H96z\"></path>\n                                    </svg>\n                                </span>\n                                </div>\n                                <div class=\"k-dock-indicator k-dock-indicator-left\" ${INDICATOR_ATTR}=\"left\">\n                                <span class=\"k-svg-icon k-icon-xl k-svg-i-position-left\">\n                                    <svg aria-hidden=\"true\" focusable=\"false\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\">\n                                        <path d=\"M448 32H32v448h448V32h-32zm0 416H64V64h384v384zM96 96h96v320H96z\"></path>\n                                    </svg>\n                                </span>\n                                </div>\n                                <div class=\"k-dock-indicator k-dock-indicator-middle\" ${INDICATOR_ATTR}=\"middle\">\n                                <span class=\"k-svg-icon k-icon-xl k-svg-i-window\">\n                                    <svg aria-hidden=\"true\" focusable=\"false\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\">\n                                        <path d=\"M96 96v320h320V96H96zm288 288H128V192h256v192z\"></path>\n                                    </svg>\n                                </span>\n                                </div>\n                            </div>`,\n        SPLITBAR = (splitter) => $(`<div class=\"${KSPLITBAR} ${KSPLITBAR}-${splitter.options.orientation} ${KSPLITBAR_DRAGGABLE}-${splitter.options.orientation}\" ${kendo.attr(\"marker\")}=\"${splitter._marker}\" >\n                        <div class=\"k-resize-handle\"></div>\n                    </div>`),\n        CLOSE = \"close\",\n        DOCK = \"dock\",\n        INNER_DOCK = \"innerDock\",\n        RESIZE = \"resize\",\n        DRAG = \"drag\",\n        DRAGSTART = \"dragStart\",\n        DRAGEND = \"dragEnd\",\n        CHANGE = \"change\";\n\n    function capitalizeFirstLetter(string) {\n        return string.charAt(0).toUpperCase() + string.slice(1);\n    }\n\n    function isPercentageSize(size) {\n        return percentageUnitsRegex.test(size);\n    }\n\n    function isPixelSize(size) {\n        return pxUnitsRegex.test(size) || /^\\d+$/.test(size);\n    }\n\n    function isFluid(size) {\n        return !isPercentageSize(size) && !isPixelSize(size);\n    }\n\n    function calculateSize(size, total) {\n        let output = parseInt(size, 10);\n\n        if (isPercentageSize(size)) {\n            output = Math.floor(output * total / 100);\n        }\n\n        return output;\n    }\n\n    function toPercentages(value) {\n        return `${value}%`;\n    }\n\n    function toPixel(value ) {\n        return kendo.parseFloat(value) + \"px\";\n    }\n\n    function percentage(partialValue, totalValue) {\n        return (100 * partialValue) / totalValue;\n    }\n\n    function clamp(value, min, max) {\n        return Math.min(max, Math.max(min, value));\n    }\n\n    const DockSplitter = Widget.extend({\n        init: function(element, options) {\n            const that = this;\n\n            Widget.fn.init.call(that, element, options);\n            options = $.extend(true, {}, options);\n            that._marker = kendo.guid().substring(0, 8);\n            that.element.addClass(`${SPLITTER} ${SPLITTER_FLEX} ${SPLITTER}-${options.orientation} ${DOCK_SPLITTER}`);\n            that._initPanes();\n            that._initResizable();\n            kendo.notify(that);\n        },\n\n        options: {\n            orientation: \"horizontal\",\n            panes: []\n        },\n\n        events: [\n            RESIZE\n        ],\n\n        _initPanes: function() {\n            const that = this;\n            const paneElements = that.element.children();\n            const panesCount = paneElements.length;\n            const orientation = that.options.orientation;\n            const markerAttribute = kendo.attr(\"marker\");\n            const sizedPanes = [];\n\n            for (let i = 0; i < panesCount; i++) {\n                const paneElement = paneElements.eq(i);\n                let pane = that.options.panes[i];\n\n                if (!pane) {\n                    pane = that.options.panes[i] = {};\n                }\n\n                pane.size = pane.size || \"auto\";\n                paneElement.attr(kendo.attr(\"uid\"), pane.uid)\n                            .attr(\"role\", \"group\")\n                            .css(\"flex-basis\", pane.size)\n                            .addClass();\n\n                if (pane.collapsed) {\n                    pane.css(\"display\", \"none\");\n                }\n\n                if (i < panesCount - 1 && !that.options.panes[i + 1].collapsed) {\n                    let splitbar = SPLITBAR(that);\n\n                    splitbar.insertAfter(paneElement);\n                }\n\n                if (pane.size) {\n                    sizedPanes.push(paneElement);\n                }\n            }\n\n            if (sizedPanes.length === 1 && panesCount > 1) {\n                sizedPanes.pop().addClass(KSTATIC_PANE);\n            }\n        },\n\n        _initResizable: function() {\n            const that = this;\n            const orientation = that.options.orientation;\n            const markerAttribute = kendo.attr(\"marker\");\n\n            that._resizable = new kendo.ui.Resizable(that.element, {\n                orientation: orientation,\n                handle: `[${markerAttribute}=${that._marker}].${KSPLITBAR_DRAGGABLE}-${orientation} `,\n                clickMoveClick: that.options.clickMoveClick,\n                invalidClass: \"k-restricted-size-\" + orientation,\n                resizeend: function() {\n                    that.element.find(\".k-splitter-overlay\").remove();\n                },\n                resize: function(e) {\n                    const axis = orientation === HORIZONTAL ? 'x' : 'y';\n                    let delta;\n                    const splitterBarIndex = that._getElementIndex(e.currentTarget, `.${KSPLITBAR}`);\n                    const splitterBar = e.currentTarget;\n\n                    if (orientation === HORIZONTAL) {\n                        const rtlModifier = kendo.support.isRtl(that.element) ? -1 : 1;\n                        delta = e.x.delta * rtlModifier;\n                    } else {\n                        delta = e.y.delta;\n                    }\n\n                    const { leftPane, rightPane } = that._dragSplitterBar(splitterBar, splitterBarIndex, delta);\n                    that.trigger(RESIZE, { leftPane: leftPane, rightPane: rightPane });\n                },\n                start: that._onResizeStart.bind(that)\n            });\n\n        },\n\n        _dragSplitterBar: function(splitterBar, splitterBarIndex, delta) {\n            const that = this;\n            const { leftPane, rightPane } = that._getAdjacentPanes(splitterBar, splitterBarIndex);\n\n            const leftPaneNewSize = leftPane.computedSize + delta;\n            const isLeftPaneSizeInBounds = leftPaneNewSize > leftPane.min && leftPaneNewSize < leftPane.max;\n\n            const panesWithoutSize = that._getPaneElements().filter(x => !x.style[PANE_SIZING_PROP]);\n            const canResizeBothPanes = (leftPane.size || rightPane.size) && panesWithoutSize.length > 1;\n\n            if ((leftPane.size && rightPane.size) || canResizeBothPanes) {\n                if (isLeftPaneSizeInBounds) {\n                    that._resizePane(leftPane, delta);\n                    that._resizePane(rightPane, -delta);\n                }\n            } else if (rightPane.size) {\n                that._resizePane(rightPane, -delta);\n            } else {\n                that._resizePane(leftPane, delta);\n            }\n            return { leftPane, rightPane };\n        },\n\n        _getAdjacentPanes: function(splitterBar, splitterBarIndex) {\n            const that = this;\n            const leftPaneIndex = splitterBarIndex;\n            const rightPaneIndex = splitterBarIndex + 1;\n\n            const leftPaneELement = that._getPaneElement(leftPaneIndex);\n            const rightPaneELement = that._getPaneElement(rightPaneIndex);\n\n            const leftPane = that._getPane(leftPaneIndex);\n            const rightPane = that._getPane(rightPaneIndex);\n\n            const leftPaneSize = that._getPaneOffsetSize(leftPaneIndex);\n            const rightPaneSize = that._getPaneOffsetSize(rightPaneIndex);\n\n            const totalPaneSize = leftPaneSize + rightPaneSize;\n            const splitterSize = that._getElementClientSize(that.element, that.options.orientation);\n            const getPixelSize = paneSize => that._calculatePixelSize(paneSize, splitterSize);\n\n            const { leftPaneMaxSize, rightPaneMaxSize } = that._getAdjacentPanesMaxSize(leftPaneIndex, rightPaneIndex);\n            const rightMaxPixelSize = getPixelSize(rightPane && rightPane.max);\n            const leftMaxPixelSize = getPixelSize(leftPane && leftPane.max);\n\n            return {\n                leftPane: {\n                    index: leftPaneIndex,\n                    computedSize: leftPaneSize,\n                    min: getPixelSize(leftPane && leftPane.min) || ( rightMaxPixelSize ? totalPaneSize - rightMaxPixelSize : 0 ) || 0,\n                    max: leftPaneMaxSize,\n                    size: leftPaneELement.style[PANE_SIZING_PROP],\n                    collapsible: leftPane && leftPane.collapsible,\n                    uid: leftPane.uid\n                },\n                rightPane: {\n                    index: rightPaneIndex,\n                    computedSize: rightPaneSize,\n                    min: getPixelSize(rightPane && rightPane.min) || (leftMaxPixelSize ? totalPaneSize - leftMaxPixelSize : 0) || 0,\n                    max: rightPaneMaxSize,\n                    size: rightPaneELement.style[PANE_SIZING_PROP],\n                    collapsible: rightPane && rightPane.collapsible,\n                    uid: rightPane.uid\n                }\n            };\n        },\n\n        _resizePane: function(pane, delta) {\n            const that = this;\n            const constrainedSize = clamp(pane.computedSize + delta, pane.min, pane.max);\n            let newSize = \"\";\n\n            if (isPercentageSize(pane.size)) {\n                const splitterSize = that._getElementClientSize(that.element, that.options.orientation);\n                newSize = toPercentages(100 * constrainedSize / splitterSize);\n            } else {\n                newSize = toPixel(constrainedSize);\n            }\n            pane.size = newSize;\n            that._setPaneSize(pane.index, newSize);\n        },\n\n        _allExpandedPanesHaveSize: function() {\n            const that = this;\n            const expandedPanes = that.options.panes.filter(x=> !x.collapsed);\n\n            if (expandedPanes.length) {\n                return expandedPanes.filter(x=> x.size).length;\n            }\n\n            return false;\n        },\n\n        _setPaneSize: function(paneIndex, size) {\n            const that = this;\n            const paneElement = that._getPaneElement(paneIndex);\n\n            if (!paneElement) {\n                return;\n            }\n\n            if (!that._allExpandedPanesHaveSize()) {\n                $(paneElement).addClass(KSTATIC_PANE);\n            }\n\n            paneElement.style[PANE_SIZING_PROP] = size;\n        },\n\n        _getPaneSizes: function(paneIndex) {\n            const that = this;\n            const splitterSize = that._getElementClientSize(that.element, that.options.orientation);\n            const pane = that._getPane(paneIndex);\n            const paneSize = that._getPaneOffsetSize(paneIndex);\n            const paneMinSize = pane && pane.min ? that._calculatePixelSize(pane.min, splitterSize) : 0;\n            const paneMaxSize = pane && pane.max ? that._calculatePixelSize(pane.max, splitterSize) : MAX_NUMBER_VALUE;\n\n            return {\n                size: paneSize,\n                min: paneMinSize,\n                max: paneMaxSize\n            };\n        },\n\n        _calculatePixelSize: function(size, containerSize) {\n            let numericSize = kendo.parseFloat(size);\n\n            if (isPercentageSize(size)) {\n                numericSize = (containerSize * numericSize / 100);\n            }\n\n            return numericSize;\n        },\n\n        _getPaneOffsetSize: function(paneIndex) {\n            const that = this;\n            const paneElement = that._getPaneElement(paneIndex);\n            const size = that._getElementOffsetSize(paneElement, that.options.orientation);\n            return size;\n        },\n\n\n        _getElementOffsetSize: function(element, orientation) {\n            if (!element) {\n                return 0;\n            }\n\n            const rect = element.getBoundingClientRect();\n\n            if (orientation === HORIZONTAL) {\n                return rect.width;\n            } else {\n                return rect.height;\n            }\n        },\n\n        _getElementClientSize: function(element, orientation) {\n            const that = this;\n\n            return that._getElementSize(element, orientation, \"client\");\n        },\n\n        _getElementSize: function(element, orientation, sizeType) {\n            if (!element) {\n                return 0;\n            }\n\n            element = element[0];\n\n            if (orientation === HORIZONTAL) {\n                return element[`${sizeType}Width`];\n            } else {\n                return element[`${sizeType}Height`];\n            }\n        },\n\n        _getPane: function(paneIndex) {\n            const that = this;\n\n            return (that.options.panes || [])[paneIndex];\n        },\n\n        _getPaneIndex: function(pane) {\n            const that = this;\n\n            return that.options.panes.indexOf(pane);\n        },\n\n        _getAdjacentPanesMaxSize: function(leftPaneIndex, rightPaneIndex) {\n            const that = this;\n            const {\n                size: leftPaneSize,\n                min: leftPaneMinSize,\n                max: leftPaneMaxPixelSize\n            } = that._getPaneSizes(leftPaneIndex);\n\n            const {\n                size: rightPaneSize,\n                min: rightPaneMinSize,\n                max: rightPaneMaxPixelSize\n            } = that._getPaneSizes(rightPaneIndex);\n\n            const totalPaneSize = leftPaneSize + rightPaneSize;\n\n            const leftPaneMaxSize = Math.min(leftPaneMaxPixelSize, totalPaneSize - rightPaneMinSize);\n            const rightPaneMaxSize = Math.min(rightPaneMaxPixelSize, totalPaneSize - leftPaneMinSize);\n\n            return {\n                leftPaneMaxSize,\n                rightPaneMaxSize\n            };\n        },\n\n        _onResizeStart: function(e) {\n            const that = this;\n\n            e.stopPropagation();\n\n            const splitterBarIndex = that._getElementIndex(e.currentTarget, `.${SPLITTER}`);\n\n            that._addResizeOverlays(splitterBarIndex);\n        },\n\n        _addResizeOverlays: function(splitterBarIndex) {\n            const that = this;\n\n            that._addResizeOverlay(splitterBarIndex);\n            that._addResizeOverlay(splitterBarIndex + 1);\n        },\n\n        _addResizeOverlay: function(paneIndex) {\n            const that = this;\n            const paneElement = that._getPaneElement(paneIndex);\n\n            if (!paneElement) {\n                return;\n            }\n\n            const overlay = $(`<div class=\"k-splitter-overlay k-overlay\"></div>`);\n\n            $(paneElement).append(overlay);\n        },\n\n\n        _getPaneElement: function(paneIndex) {\n            const that = this;\n            const panes = that._getPaneElements();\n            return panes[paneIndex];\n        },\n\n        _getPaneElements: function() {\n            const that = this;\n            const panes = Array.from(that.element.children() || []).filter(x => $(x).hasClass(\"k-pane\") || $(x).hasClass(\"k-splitter\"));\n            return panes;\n        },\n\n        _getElementIndex: function(element, childrenSelector) {\n            if (!element) {\n                return [].indexOf(element);\n            }\n\n            let children = Array.from(element.parent().children());\n\n            if (childrenSelector) {\n                children = children.filter(x => x.matches(childrenSelector));\n            }\n\n            return Array.from(children).indexOf(element[0]);\n        },\n\n        destroy: function() {\n            const that = this;\n\n            Widget.fn.destroy.call(that);\n\n            that.element.off(NS);\n            that.element.empty();\n\n            that._resizable.destroy();\n            kendo.destroy(that.element);\n        }\n    });\n\n    const DockManager = Widget.extend({\n        init: function(element, options) {\n            const that = this;\n\n            Widget.fn.init.call(that, element, options);\n            options = $.extend(true, {}, options);\n            that.element.addClass(DOCK_MANAGER);\n\n            that.panesContainer = $(`<div class=\"${KPANES_CONTAINER}\" />`).appendTo(that.element);\n            that._processPanes(that.options.rootPane);\n            that._refreshToolbar();\n            that._createPane(that.panesContainer, that.options.rootPane);\n            that._bindEvents();\n            that._initNavigator();\n            that._initUnpinnedResizable();\n\n            kendo.notify(that);\n        },\n\n        events: [\n            CLOSE,\n            PIN,\n            UNPIN,\n            DOCK,\n            INNER_DOCK,\n            RESIZE,\n            DRAG,\n            DRAGSTART,\n            DRAGEND\n        ],\n\n        options: {\n            name: 'DockManager',\n            rootPane: {\n                type: SPLIT,\n                orientation: HORIZONTAL,\n                panes: []\n            }\n        },\n\n        paneDefaults: {\n            visible: true,\n            closeable: true,\n            collapsed: false,\n            size: ''\n        },\n\n        actions: [\n            {\n                name: \"pin\",\n                icon: \"unpin\",\n                shouldAdd: pane => pane.unpinnable && pane.unpinnable.unpinned\n            },{\n                name: \"unpin\",\n                icon: \"pin\",\n                shouldAdd: pane => pane.unpinnable && !pane.unpinnable.unpinned\n            },{\n                name: \"minimize\",\n                icon: \"minimize\",\n                shouldAdd: pane => pane.minimizable\n            },{\n                name: \"maximize\",\n                icon: \"maximize\",\n                shouldAdd: pane => pane.maximizable\n            },{\n                name: \"close\",\n                icon: \"x\",\n                shouldAdd: pane => pane.closeable != false\n            },{\n                name: \"more\",\n                icon: \"more-vertical\",\n                shouldAdd: pane => false //not needed for v1 as currently only 2 actions are available\n            }\n        ],\n\n        indicators: [\n            {\n                name: TOP,\n                top: 0,\n                left: \"50%\",\n                transform: \"translate(-50%, 0)\",\n                previewTop: () => 0,\n                previewLeft: () => 0,\n                rotate: \"0deg\"\n            },{\n                name: BOTTOM,\n                top: \"100%\",\n                left: \"50%\",\n                transform: \"translate(-50%, -100%)\",\n                previewTop: (hoveredPaneHeight, draggedPaneHeight) => hoveredPaneHeight - draggedPaneHeight,\n                previewLeft: () => 0,\n                rotate: \"180deg\"\n            },{\n                name: LEFT,\n                top: \"50%\",\n                left: 0,\n                transform: \"translate(0, -50%)\",\n                previewTop: () => 0,\n                previewLeft: () => 0,\n                rotate: \"270deg\"\n            },{\n                name: RIGHT,\n                top: \"50%\",\n                left: \"100%\",\n                transform: \"translate(-100%, -50%)\",\n                previewTop: () => 0,\n                previewLeft: (hoveredPaneWidth, draggedPaneWidth) => hoveredPaneWidth - draggedPaneWidth,\n                rotate: \"90deg\"\n            },{\n                name: MIDDLE,\n                previewTop: () => 0,\n                previewLeft: () => 0,\n            }\n        ],\n\n        togglePane: function(id) {\n            const that = this,\n            pane = that._getPaneById(that.options.rootPane, \"id\", id);\n\n            if (pane != undefined$1) {\n                that._togglePane(pane);\n            }\n        },\n\n        removePane: function(id) {\n            const that = this;\n            const pane = that._getPaneById(that.options.rootPane, \"id\", id);\n\n            if (pane != undefined$1) {\n                that._removePane(pane);\n            }\n        },\n\n        getOptions: function() {\n            const that = this;\n            return that.options;\n        },\n\n        setOptions: function(options) {\n            const that = this;\n            let currentOptions = that.getOptions();\n            kendo.deepExtend(currentOptions, options);\n\n            that.destroy();\n            that.element.empty();\n\n            that.init(that.element, currentOptions);\n\n        },\n\n        _initUnpinnedResizable: function() {\n            const that = this;\n\n            that._unpinnedResizable = new kendo.ui.Resizable(that.unpinnedContainer, {\n                orientation: HORIZONTAL,\n                handle: \".k-splitbar-horizontal.k-splitbar-draggable-horizontal\",\n                resize: function(e) {\n                    const delta = e.x.delta;\n                    const containerWidth = that.unpinnedContainer.width();\n\n                    that.unpinnedContainer.width(containerWidth + delta);\n                }\n            });\n        },\n\n        _bindEvents: function() {\n            const that = this;\n\n            that.element.on(CLICK + NS, `.k-dock-manager-toolbar .${KBUTTON}`, that._toolbarButtonClick.bind(that));\n            that.element.on(CLICK + NS, `.${KPANES_CONTAINER}`, that._hideUnpinnedPanes.bind(that));\n            that.element.on(CLICK + NS, `.${KBUTTON}[${ACTION_ATTR}=\"pin\"], .${KBUTTON}[${ACTION_ATTR}=\"unpin\"]`, that._pinPaneClick.bind(that));\n            that.element.on(CLICK + NS, `.${KBUTTON}[${ACTION_ATTR}=\"close\"]`, that._closePane.bind(that));\n            that.element.on(\"mouseenter\" + NS, `.${KDOCK_INDICATOR}`, that._displayDockPreview.bind(that));\n            that.element.on(\"mouseleave\" + NS, `.${KDOCK_INDICATOR}`, that._hideDockPreview.bind(that));\n        },\n\n        _hideUnpinnedPanes: function(e) {\n            const that = this;\n            const unpinnedPanes = that.unpinnedContainer.find(`.${KPANE}`);\n            const currentlyOpened = unpinnedPanes.filter(\":visible\");\n            const unpinnedContainerVisible = that.unpinnedContainer.is(\":visible\");\n\n            if (currentlyOpened && unpinnedContainerVisible) {\n                that._toolbar.find(`.${KSELECTED}`).removeClass(KSELECTED);\n                that.unpinnedContainer.addClass(KHIDDEN);\n                return;\n            }\n        },\n\n        _toolbarButtonClick: function(e) {\n            const that = this;\n            const itemUid = $(e.currentTarget).attr(UID_ATTR);\n            const unpinnedPanes = that.unpinnedContainer.find(`.${KPANE}`);\n            const currentlyOpened = unpinnedPanes.filter(\":visible\");\n            const unpinnedContainerVisible = that.unpinnedContainer.is(\":visible\");\n\n            e.preventDefault();\n            that._toolbar.find(`.${KBUTTON}`).removeClass(KSELECTED);\n\n            if (currentlyOpened.attr(UID_ATTR) === itemUid && unpinnedContainerVisible) {\n                that.unpinnedContainer.addClass(KHIDDEN);\n                return;\n            }\n\n            that._showUnpinnedPane(itemUid);\n        },\n\n        _showUnpinnedPane: function(paneUid) {\n            const that = this;\n            const toolbarWidth = that._toolbar.outerWidth();\n            const pane = that._findPaneByUid(paneUid);\n            const hasUnpinnedSize = pane.unpinnable.unpinnedSize;\n\n            that.unpinnedContainer.removeClass(KHIDDEN).css({ left: `${toolbarWidth}px` });\n            that.unpinnedContainer.find(`.${KPANE}`).addClass(KHIDDEN);\n            that.unpinnedContainer.find(paneSelector(paneUid)).removeClass(KHIDDEN);\n\n            if (hasUnpinnedSize) {\n                that.unpinnedContainer.css({ width: `${pane.unpinnable.unpinnedSize}` });\n            }\n\n            that._toolbar.find(`.${KBUTTON}[${UID_ATTR}=\"${paneUid}\"]`).addClass(KSELECTED);\n        },\n\n        _pinPaneClick: function(e) {\n            const that = this;\n            const button = $(e.currentTarget);\n            const isTabbed = button.parent().is(\"li\");\n            const action = button.attr(ACTION_ATTR);\n            const paneElement = isTabbed ? button.parent() : $(e.currentTarget).closest(`.${KPANE}`);\n            const pane = that._findPaneByUid(paneElement.attr(UID_ATTR));\n            const isUnpinned = pane.unpinnable.unpinned;\n            const parentPane = that._findPaneByUid(pane.parentUid);\n            const parentPaneElement = that.panesContainer.find(`.${KPANE}[${UID_ATTR}=\"${parentPane.uid}\"], .${SPLITTER}[${UID_ATTR}=\"${parentPane.uid}\"]`);\n            const eventData = { pane: pane, paneElement: paneElement };\n\n            if (isUnpinned) {\n                kendo.destroy(paneElement);\n                paneElement.remove();\n            }\n\n            pane.unpinnable.unpinned = action === PIN ? false : true;\n            that._refreshRootPane();\n            that.unpinnedContainer.toggleClass(KHIDDEN, action === PIN);\n\n            if (action === \"pin\") {\n                that.trigger(PIN, eventData);\n                return;\n            }\n\n            that.trigger(UNPIN, eventData);\n            that._showUnpinnedPane(pane.uid);\n        },\n\n        _closePane: function(e) {\n            const that = this;\n            const button = $(e.currentTarget);\n            const isTabbed = button.parent().is(\"li\");\n            const paneElement = isTabbed ? button.parent() : $(e.currentTarget).closest(`.${KPANE}`);\n            const pane = that._findPaneByUid(paneElement.attr(UID_ATTR));\n            const parentPane = that._findPaneByUid(pane.parentUid);\n            const parentPaneElement = that.panesContainer.find(`.${KPANE}[${UID_ATTR}=\"${parentPane.uid}\"], .${SPLITTER}[${UID_ATTR}=\"${parentPane.uid}\"]`);\n            const paneIndex = parentPane.panes.indexOf(pane);\n            const eventData = { pane: pane, paneElement: paneElement, event: e };\n\n            if (that.trigger(CLOSE, eventData)) {\n                e.preventDefault();\n            }\n\n            if (pane.unpinnable && pane.unpinnable.unpinned) {\n                that.unpinnedContainer.addClass(KHIDDEN);\n            }\n\n            parentPane.panes.splice(paneIndex, 1);\n\n            if (that._shouldHideParent(parentPane)) {\n                parentPane.visible = false;\n            }\n\n            that._refreshRootPane();\n        },\n\n        _shouldHideParent: function(pane) {\n            const that = this,\n            parent = that._findPaneByUid(pane.parentUid);\n\n            if (pane.panes.length == 0) {\n                if (pane.type == TAB && parent.panes.length == 1) {\n                    parent.panes.splice(0,1);\n                    parent.visible = false;\n                }\n                return true;\n            }\n\n            if (pane.panes.length == 1 &&\n                pane.panes[0].type == TAB &&\n                !pane.panes.some(x => x.visible)) {\n                return true;\n            }\n\n            return false;\n        },\n\n        _refreshPane: function(paneElement, pane) {\n            const that = this;\n            const parentElement = paneElement.parent();\n            const isTabbed = paneElement.is(`.${KPANE_TABBED}`);\n\n            kendo.destroy(paneElement);\n            isTabbed ? paneElement.empty() : paneElement.remove();\n            that._refreshToolbar();\n            that._createPane(isTabbed ? paneElement : parentElement, pane);\n        },\n\n        _processPanes: function(pane) {\n            const that = this;\n            pane.uid = pane.uid || kendo.guid();\n            that._extendPane(pane);\n\n            if (pane.type === SPLIT && !pane.orientation) {\n                pane.orientation = HORIZONTAL;\n            }\n\n            pane.panes.forEach((childPane) => {\n                childPane.parentUid = pane.uid;\n\n                if (childPane.type == CONTENT) {\n                    if (childPane.unpinnable === undefined$1 || childPane.unpinnable === true) {\n                        childPane.unpinnable = {\n                            unpinned: false\n                        };\n                    }\n                    childPane.uid = childPane.uid || kendo.guid();\n                }\n\n                if (childPane.panes && childPane.panes.length) {\n                    that._processPanes(childPane);\n                }\n            });\n        },\n\n        _extendPane: function(pane) {\n            const that = this;\n\n            if (pane.panes) {\n                for (var j = 0; j < pane.panes.length; j++) {\n                    pane.panes.forEach(subItem => {\n                        that._extendPane(subItem);\n                    });\n                }\n            }\n\n            extend(pane, {\n                visible: pane.visible === undefined$1 ? that.paneDefaults.visible : pane.visible,\n                closeable: pane.closeable === undefined$1 ? that.paneDefaults.closeable : pane.closeable,\n                collapsed: pane.collapsed === undefined$1 ? that.paneDefaults.collapsed : pane.collapsed,\n                size: pane.size === undefined$1 ? that.paneDefaults.size : pane.size,\n            });\n        },\n\n        _togglePane: function(pane) {\n            const that = this;\n\n            pane.visible = !pane.visible;\n            that._refreshRootPane();\n        },\n\n        _removePane: function(pane) {\n            const that = this;\n            const parentPane = that._findPaneByUid(pane.parentUid);\n            const paneIndex = parentPane.panes.indexOf(pane);\n            const parentPaneElement = that.panesContainer.find(`[${UID_ATTR}=\"${pane.uid}\"]`).parent();\n\n            parentPane.panes.splice(paneIndex, 1);\n            that._refreshRootPane();\n        },\n\n        _refreshToolbar: function() {\n            const that = this;\n            const unpinnedPanes = that._unpinnedPanes();\n            const unpinnedPannesContainer = $(`<div class=\"${KHIDDEN}\"/>`).addClass(KUNPINNED_CONTAINER);\n\n            if (!that.unpinnedContainer) {\n                that.unpinnedContainer = unpinnedPannesContainer;\n                unpinnedPannesContainer.append(unpinnedResizeSplitbar);\n                unpinnedPannesContainer.insertBefore(that.panesContainer);\n            }\n\n            if (!unpinnedPanes.length) {\n                that._toolbar && that._toolbar.remove();\n                that._toolbar = null;\n                return;\n            }\n\n            if (!that._toolbar) {\n                that._toolbar = that.element.prepend(TOOLBAR_TEMPLATE).find(`.${DOCK_MANAGER_TOOLBAR}`);\n            }\n\n            that._toolbar.empty();\n\n            for (let i = 0; i < unpinnedPanes.length; i++) {\n                const pane = unpinnedPanes[i];\n                const button = $(kendo.html.renderButton({ fillMode: \"flat\", size: \"medium\" }))\n                                .addClass(TOOLBAR_BUTTON)\n                                .append(buttonTextTemplate(that._paneHeader(pane)));\n\n                button.attr(UID_ATTR, pane.uid);\n                that._toolbar.append(button);\n\n                if (i < unpinnedPanes.length - 1) {\n                    that._toolbar.append(SEPARATOR);\n                }\n            }\n        },\n\n        destroy: function() {\n            const that = this;\n\n            Widget.fn.destroy.call(that);\n\n            that.element.off(NS);\n            that.element.empty();\n\n            kendo.destroy(that.wrapper);\n        },\n\n        refresh: function() {\n            const that = this;\n            kendo.destroy(that.unpinnedContainer);\n            that.unpinnedContainer.empty();\n            that._refreshRootPane();\n        },\n\n        _refreshRootPane: function() {\n            const that = this;\n            const rootPaneElement = that.element.find(`[${UID_ATTR}=\"${that.options.rootPane.uid}\"]`);\n\n            that._refreshPane(rootPaneElement, that.options.rootPane);\n        },\n\n        _createSplitPane: function(parentElement, pane) {\n            const that = this;\n            const splitterElement = $(\"<div/>\").attr(UID_ATTR, pane.uid);\n            const splitterOptions = {\n                orientation: pane.orientation || HORIZONTAL,\n                panes: []\n            };\n\n            if (!pane.panes.some(x=>x.visible)) {\n                return;\n            }\n\n            parentElement.append(splitterElement);\n\n            pane.panes.forEach((childPane) => {\n                const paneOptions = {\n                    uid: childPane.uid\n                };\n                const paneElement = $(PANE).removeClass(KSTATIC_PANE);\n\n                if (childPane.unpinnable && childPane.unpinnable.unpinned) {\n                    that._createUnpinnedPane(childPane);\n                    return;\n                }\n\n                if (childPane.size) {\n                    paneOptions.size = childPane.size;\n                }\n\n                if (childPane.visible != undefined$1) {\n                    paneOptions.visible = childPane.visible;\n                }\n\n                if (childPane.visible) {\n                    splitterElement.append(paneElement);\n                    that._createPane(paneElement, childPane);\n                    splitterOptions.panes.push(paneOptions);\n                }\n            });\n\n           pane.splitter = new DockSplitter(splitterElement, splitterOptions); // eslint-disable-line no-new\n           pane.splitter.bind(RESIZE, that._updatePaneSize.bind(that));\n        },\n\n        _updatePaneSize: function(e) {\n            const that = this;\n            const leftPane = that._findPaneByUid(e.leftPane.uid),\n            rightPane = that._findPaneByUid(e.rightPane.uid);\n\n            leftPane.size = e.leftPane.size;\n            rightPane.size = e.rightPane.size;\n            that.trigger(RESIZE, { ev: e, leftPane: leftPane, rightPane: rightPane });\n        },\n\n        _createTabPane: function(parentElement, pane) {\n            const that = this;\n            const tabStripElement = $(\"<div class='k-header'/>\");\n            const tabContainer = $(\"<ul/>\");\n            const tabStripOptions = {\n                animation: false\n            };\n            const selectedPane = (pane.selected === undefined$1 || pane.panes.indexOf(pane.panes[pane.selected]) == -1 || pane.panes[pane.selected].unpinnable.unpinned) ? 0 : pane.selected;\n\n            if (!pane.panes.some(x=>x.visible)) {\n                return;\n            }\n\n            tabStripElement.append(tabContainer);\n            parentElement.append(tabStripElement);\n            parentElement.attr(UID_ATTR, pane.uid);\n            parentElement.addClass(KPANE_TABBED);\n\n            pane.panes.forEach((childPane) => {\n                const tab = $(tabTemplate(that._paneHeader(childPane))).attr(UID_ATTR, childPane.uid);\n                const contentElement = $(\"<div/>\");\n\n                if (childPane.unpinnable && childPane.unpinnable.unpinned) {\n                    that._createUnpinnedPane(childPane);\n                    return;\n                }\n\n                if (childPane.visible) {\n                    that._addActions(tab, childPane);\n                    tabContainer.append(tab);\n                    tabStripElement.append(contentElement);\n                    that._createPane(contentElement, childPane);\n                }\n            });\n\n            $(tabContainer.children()[selectedPane]).addClass(KACTIVE);\n            tabStripElement.kendoTabStrip(tabStripOptions);\n        },\n\n        _createContentPane: function(parentElement, pane) {\n            const that = this;\n            const content = typeof pane.content === \"function\" ? kendo.template(pane.content)({}) : pane.content;\n            const element = $(contentPaneTemplate(extend({}, pane, { title: that._paneHeader(pane), content: content })));\n            const parentPane = that._findPaneByUid(pane.parentUid);\n            const isUnnpinned = pane.unpinnable && pane.unpinnable.unpinned;\n\n\n            if (parentPane && parentPane.type === TAB && !isUnnpinned) {\n                parentElement.append(content);\n                return;\n            }\n\n            parentElement.addClass(KKPINNED_PANE)\n                         .removeClass(KSTATIC_PANE)\n                         .attr(UID_ATTR, pane.uid);\n            that._addActions(element.find(`.${KPANE_ACTIONS}`), pane);\n            parentElement.append(element);\n        },\n\n        _createUnpinnedPane: function(pane) {\n            const that = this;\n            const paneElement = $(PANE).removeClass(KSTATIC_PANE);\n\n            if (that.unpinnedContainer.find(paneSelector(pane.uid)).length) {\n                return;\n            }\n\n            that.unpinnedContainer.prepend(paneElement);\n            that._createContentPane(paneElement, pane);\n        },\n\n        _addActions: function(actionsContainer, pane) {\n            const that = this;\n\n            that.actions.forEach((action) => {\n                if (action.shouldAdd(pane)) {\n                    actionsContainer.append($(kendo.html.renderButton({ fillMode: \"flat\", icon: action.icon })).attr(ACTION_ATTR, action.name));\n                }\n            });\n\n        },\n\n        _createPane: function(parentElement, pane) {\n            const that = this;\n\n            if (pane.id) {\n                parentElement.attr(\"id\", pane.id);\n            }\n\n            return that[\"_create\" + capitalizeFirstLetter(pane.type) + \"Pane\"](parentElement, pane);\n        },\n\n        _unpinnedPanes: function(panes) {\n            const that = this;\n            const options = that.options;\n            let result = [];\n\n            if (!panes) {\n                panes = options.rootPane.panes;\n            }\n\n            panes.forEach((pane) => {\n                if (pane.unpinnable && pane.unpinnable.unpinned) {\n                    result.push(pane);\n                }\n\n                if (pane.panes && pane.panes.length) {\n                    result = result.concat(that._unpinnedPanes(pane.panes));\n                }\n            });\n\n            return result;\n        },\n\n        _paneHeader: function(pane) {\n            const that = this;\n            const parentPane = that._findPaneByUid(pane.parentUid);\n            const isTabbed = parentPane && parentPane.type === \"tab\";\n            let header = pane.header;\n\n            if (isTabbed && pane.tabHeader) {\n                header = pane.tabHeader;\n            }\n\n            if (!header) {\n                return pane.title || \"\";\n            }\n\n            return kendo.template(header)(pane);\n        },\n\n        _findPaneByUid: function(uid, parent) {\n            const that = this;\n            let found;\n\n            parent = parent || that.options.rootPane;\n\n            if (parent.uid === uid) {\n                return parent;\n            }\n\n            parent.panes.forEach((pane) => {\n                if (pane.uid === uid) {\n                    found = pane;\n                    return;\n                }\n\n                if (pane.panes && pane.panes.length) {\n                    const result = that._findPaneByUid(uid, pane);\n\n                    if (result) {\n                        found = result;\n                        return;\n                    }\n                }\n            });\n            return found;\n        },\n\n        _getPaneById: function(pane, prop, value) {\n            const that = this;\n            let found;\n\n            if (pane[prop] == value) {\n                return pane;\n            }\n\n            if (pane.panes) {\n                pane.panes.forEach((childPane) => {\n                    let result = that._getPaneById(childPane, prop, value);\n                    if (result) {\n                        found = result;\n                    }\n                });\n            }\n            return found;\n        },\n\n        _initNavigator: function(params) {\n            const that = this;\n\n            that.navigatorDraggable = new kendo.ui.Draggable(that.element, {\n                autoScroll: true,\n                filter: \".k-pane-header, .k-pane-tabbed .k-tabstrip-item\",\n                hint: function(element) {\n                    const isTabbed = element.is(\"li\");\n                    const paneElement = element.closest(`.${KPANE}`);\n                    const pane = that._findPaneByUid((isTabbed ? element : paneElement).attr(UID_ATTR));\n                    const actionsHtml = isTabbed ? that._getActionButtons(element) : paneElement.find(`.${KPANE_ACTIONS}`).html();\n\n                    return hintTemplate({\n                        width: paneElement.width(),\n                        height: paneElement.height(),\n                        content: pane.content,\n                        title: that._paneHeader(pane),\n                        actions: actionsHtml\n                    });\n                },\n                dragstart: that._dragStart.bind(that),\n                dragend: that._dragEnd.bind(that),\n                drag: that._drag.bind(that)\n            });\n        },\n\n        _dragStart: function(e) {\n            const that = this;\n            const target = $(e.currentTarget);\n            const pane = target.closest(`.${KPANE}`);\n\n            that.draggedPane = {\n                width: pane.width(),\n                height: pane.height(),\n                pane,\n                target\n            };\n\n            that._displayGlobalIndicators();\n\n            that.trigger(DRAGSTART, { pane: that.draggedPane.pane, draggableEvent: e });\n        },\n\n        _dragEnd: function(e) {\n            const that = this;\n            const hoveredIndicator = that.element.find(`.${KDOCK_INDICATOR}:hover`);\n            const eventData = { pane: that.draggedPane.pane, draggableEvent: e };\n\n            if (hoveredIndicator.length) {\n                that.navigatorDraggable.hint.hide();\n                that._updateLayout(hoveredIndicator);\n            }\n\n            that.element.find(`.${KDOCK_INDICATOR}`).remove();\n            that.element.find(`.${KDOCK_PREVIEW}`).remove();\n\n            if (!hoveredIndicator.length) {\n                that._showHiddenPanes();\n            }\n            that.trigger(DRAGEND, eventData);\n            that.hoveredPane = null;\n            that.draggedPane = null;\n        },\n\n        _drag: function(e) {\n            const that = this;\n            const currentPane = $(e.elementUnderCursor).closest(`.${KPANE}[${UID_ATTR}]`);\n            const pane = that._findPaneByUid(currentPane.attr(UID_ATTR));\n            const navigator = $(NAVIGATOR_TEMPLATE);\n            const currentPaneUid = currentPane.attr(UID_ATTR);\n            const prevPaneUid = that.hoveredPane && that.hoveredPane.attr(UID_ATTR);\n            var eventData = { pane: that.draggedPane.pane, draggableEvent: e };\n\n            if (that.trigger(DRAG, eventData)) {\n                e.preventDefault();\n                return;\n            }\n\n            if (currentPaneUid === prevPaneUid) {\n                return;\n            }\n\n            that.hoveredPane = currentPane;\n            that.element.find(`.${KDOCK_NAVIGATOR}`).remove();\n            navigator.css({\n                position: \"absolute\",\n                top: \"50%\",\n                left: \"50%\",\n                transform: \"translate(-50%,-50%)\",\n                \"z-index\": 100008\n            });\n\n            if (pane && pane.dockable && !pane.dockable.innerDock) {\n                navigator.css(\"display\", \"none\");\n            }\n\n            currentPane.append(navigator);\n        },\n\n        _showHiddenPanes: function() {\n            const that = this;\n            const isTabbed = that.draggedPane.pane.is(`.${KPANE_TABBED}`);\n\n            if (isTabbed) {\n                return that._showTab();\n            }\n\n            that._showPane(that.draggedPane.pane);\n        },\n\n        _showTab: function(tab) {\n            if (tab === undefined$1) {\n                return;\n            }\n\n            const that = this;\n            const tabstrip = tab.closest(`.${KTABSTRIP}`).data(\"kendoTabStrip\");\n\n            tab.show();\n            tabstrip.activateTab(tab);\n        },\n\n        _showPane: function(paneElement) {\n            const that = this;\n            const splitbar = paneElement.siblings(`.${KSPLITBAR}:hidden`);\n            paneElement.show();\n            splitbar.show();\n        },\n\n        _hideDraggedPane: function(draggedElement) {\n            const that = this;\n            const isTabbed = draggedElement.is(\"li\");\n\n            if (isTabbed) {\n                return that._hideTab(draggedElement);\n            }\n\n            that._hidePane(draggedElement);\n        },\n\n        _hidePane: function(draggedElement) {\n            const that = this;\n            const paneElement = draggedElement.closest(`.${KPANE}`);\n            const prevElement = paneElement.prev();\n            const nextElement = paneElement.next();\n\n            paneElement.hide();\n\n            if (prevElement.is(`.${KSPLITBAR}`)) {\n                return prevElement.hide();\n            }\n\n            nextElement.hide();\n        },\n\n        _hideTab: function(tab) {\n            const that = this;\n            const isActive = tab.is(`.${KACTIVE}`);\n            const tabstrip = tab.closest(`.${KTABSTRIP}`).data(\"kendoTabStrip\");\n\n            tab.hide();\n\n            if (isActive) {\n                tabstrip.activateTab(\"li:visible:first\");\n            }\n        },\n\n        _getActionButtons: function(paneElement) {\n            const buttons = paneElement.find(\"button\");\n            const container = $(\"<div/>\");\n\n            buttons.each((_, button) => container.append($(button).clone()));\n\n            return container.html();\n        },\n\n        _displayGlobalIndicators: function() {\n            const that = this;\n\n            that.indicators.forEach((indicator) => {\n                const element = $(INDICATOR_TEMPLATE);\n\n                if (indicator.name === \"middle\") {\n                    return;\n                }\n\n                that.element.append(element);\n                element.css({\n                    position: \"absolute\",\n                    \"z-index\": \"100002\",\n                    top: indicator.top,\n                    left: indicator.left,\n                    transform: `${indicator.transform} rotate(${indicator.rotate})`\n                });\n                element.attr(INDICATOR_ATTR, indicator.name);\n            });\n        },\n\n        _displayDockPreview: function(e) {\n            const that = this;\n            const indicator = $(e.currentTarget);\n            const isGlobalIndicator = !indicator.parent().is(`.${KDOCK_NAVIGATOR}`);\n            const indicatorName = indicator.attr(INDICATOR_ATTR);\n            const indicatorUid = indicator.attr(UID_ATTR);\n            const indicatorData = that.indicators.filter(i => i.name === indicatorName)[0];\n            const previewElement = $(`<div class=\"${KDOCK_PREVIEW}\"/>`);\n            const container = isGlobalIndicator ? that.panesContainer : that.hoveredPane;\n            const toolbarWidth = that._toolbar ? that._toolbar.outerWidth() : 0;\n            const containerWidth = container.outerWidth();\n            const containerHeight = container.outerHeight();\n            const existingPreview = indicatorUid && container.find(`.${KDOCK_PREVIEW}[${UID_ATTR}=\"${indicatorUid}\"]`);\n            const uid = kendo.guid();\n            let width = that.draggedPane.width;\n            let height = that.draggedPane.height;\n\n            if (existingPreview && existingPreview.length) {\n                return existingPreview.show();\n            }\n\n            if (indicatorName === MIDDLE) {\n                width = containerWidth;\n                height = containerHeight;\n            }\n\n            if (indicatorName === TOP || indicatorName === BOTTOM) {\n                if (height > containerHeight / 2) {\n                    height = containerHeight / 2;\n                }\n\n                width = containerWidth;\n            }\n\n            if (indicatorName === LEFT || indicatorName === RIGHT) {\n                if (width > containerWidth / 2) {\n                    width = containerWidth / 2;\n                }\n\n                height = containerHeight;\n            }\n\n            const css = {\n                position: \"absolute\",\n                \"z-index\": 100000,\n                top: indicatorData.previewTop(containerHeight, height),\n                left: indicatorData.previewLeft(containerWidth, width) + (isGlobalIndicator ? toolbarWidth : 0),\n                width: width,\n                height\n            };\n\n            previewElement.css(css);\n            previewElement.attr(INDICATOR_ATTR, indicatorData.name)\n                          .attr(UID_ATTR, uid);\n            indicator.attr(UID_ATTR, uid);\n            container.append(previewElement);\n            that.draggedPane.preview = {\n                width,\n                height\n            };\n            that.draggedPane.container = {\n                width: containerWidth,\n                height: containerHeight\n            };\n        },\n\n        _hideDockPreview: function() {\n            const that = this;\n\n            that.element.find(`.${KDOCK_PREVIEW}`).hide();\n        },\n\n        _updateLayout: function(indicator) {\n            const that = this;\n            const isTabbed = that.draggedPane.target.is(\"li\");\n            const isGlobalIndicator = !indicator.parent().is(`.${KDOCK_NAVIGATOR}`);\n            const paneElement = isTabbed ? that.draggedPane.target : that.draggedPane.pane;\n            const hoveredPane = that._findPaneByUid(that.hoveredPane.attr(UID_ATTR));\n            const draggedPane = that._findPaneByUid(paneElement.attr(UID_ATTR));\n            const location = indicator.attr(INDICATOR_ATTR);\n            const draggedPaneParent = that._findPaneByUid(draggedPane.parentUid);\n            const draggedPaneIndex = draggedPaneParent.panes.indexOf(draggedPane);\n            const rootPaneElement = that.element.find(`[${UID_ATTR}=\"${that.options.rootPane.uid}\"]`);\n\n            draggedPaneParent.panes.splice(draggedPaneIndex, 1);\n            location == MIDDLE ? that._tabDock(hoveredPane, draggedPane) : that._splitDock(hoveredPane, draggedPane, location, isGlobalIndicator);\n            that._processPanes(that.options.rootPane);\n            that._adjustSiblingSizes(draggedPane, location, isGlobalIndicator);\n            that._refreshPane(rootPaneElement, that.options.rootPane);\n            location == MIDDLE ?\n                that.trigger(INNER_DOCK, { pane: draggedPane, paneElement: paneElement }) :\n                that.trigger(DOCK, { pane: draggedPane, paneElement: paneElement });\n        },\n\n        _splitDock: function(targetPane, pane, location, isGlobalDock) {\n            const that = this;\n            const targetPaneParent = isGlobalDock ? that.options.rootPane : that._findPaneByUid(targetPane.parentUid);\n            const targetPaneIndex = targetPaneParent.panes.indexOf(targetPane);\n            const action = location === TOP || location === LEFT ? UNSHIFT : PUSH;\n            const paneIndex = targetPaneIndex + (action === UNSHIFT ? 0 : 1);\n            const orientation = location === TOP || location === BOTTOM ? VERTICAL : HORIZONTAL;\n            const dimension = location === TOP || location === BOTTOM ? HEIGHT : WIDTH;\n            const newParentPane = {\n                type: SPLIT,\n                orientation,\n                panes: [],\n            };\n            const previewSize = that.draggedPane.preview[dimension];\n            const size = `${previewSize}px`;\n\n            pane.size = size;\n\n            if (isGlobalDock) {\n                newParentPane.panes.push(targetPaneParent);\n                (location === TOP || location === LEFT) ? newParentPane.panes.unshift(pane) : newParentPane.panes.push(pane);\n                that.options.rootPane = newParentPane;\n                return;\n            }\n\n            if (((location === TOP || location === BOTTOM) && targetPaneParent.orientation === VERTICAL) ||\n                ((location === LEFT || location === RIGHT) && targetPaneParent.orientation === HORIZONTAL)) {\n                return targetPaneParent.panes.splice(paneIndex, 0, pane);\n            }\n\n            if (targetPane) {\n                newParentPane.size = targetPane.size;\n                targetPane.size = null;\n            }\n\n            targetPaneParent.panes.splice(targetPaneIndex, 1);\n            newParentPane.panes.push(targetPane);\n            newParentPane.panes[action](pane);\n            targetPaneParent.panes.splice(targetPaneIndex, 0, newParentPane);\n        },\n\n        _tabDock: function name(targetPane, pane) {\n            const that = this;\n            const targetPaneParent = that._findPaneByUid(targetPane.parentUid);\n            const targetPaneIndex = targetPaneParent.panes.indexOf(targetPane);\n            const newParentPane = {\n                type: TAB,\n                panes: [\n                    targetPane,\n                    pane\n                ]\n            };\n\n            if (targetPane.type === TAB) {\n                targetPane.panes.push(pane);\n                return;\n            }\n\n            targetPaneParent.panes.splice(targetPaneIndex, 1);\n            targetPaneParent.panes.splice(targetPaneIndex, 0, newParentPane);\n\n        },\n\n        _adjustSiblingSizes: function(pane, location, isGlobalDock) {\n            const that = this;\n            const siblings = that._getSiblings(pane);\n            const dimension = location === TOP || location === BOTTOM ? HEIGHT : WIDTH;\n            const parentSize = that.draggedPane.container[dimension];\n            const draggedPaneSize = that.draggedPane[dimension];\n            const newParentSize = parentSize - draggedPaneSize;\n            const noSizePanes = [];\n            let freeSpace = newParentSize;\n\n            if (location === MIDDLE) {\n                return;\n            }\n\n            if (siblings.length === 2) {\n                siblings[0].size = null;\n                return;\n            }\n\n            siblings.forEach((childPane) => {\n                if (childPane.uid === pane.uid) {\n                    return;\n                }\n\n                if (!childPane.size) {\n                    noSizePanes.push(childPane);\n                    return;\n                }\n\n                childPane.size = that._calculateNewSize(parentSize, newParentSize, childPane.size);\n                freeSpace -= childPane.size;\n            });\n\n            noSizePanes.forEach((noSizePane) => {\n                const newSize = freeSpace / noSizePanes.length;\n\n                noSizePane.size = newSize;\n            });\n\n        },\n\n        _calculateNewSize: function(parentSize, newParentSize, paneSize) {\n            const proportion = newParentSize / parentSize;\n            let unit = \"px\";\n            let noUnitSize;\n\n            if (isPercentageSize(paneSize)) {\n                unit = \"%\";\n            }\n\n            noUnitSize = +paneSize.replace(unit, \"\");\n\n            return `${noUnitSize * proportion}${unit}`;\n        },\n\n        _getSiblings: function(pane) {\n            const that = this;\n            const parent = that._findPaneByUid(pane.parentUid);\n\n            return parent.panes.filter(p => p.visible !== false &&\n                                            p.uid !== pane.uid &&\n                                            (p.unpinnable && p.unpinnable.unpinned !== true));\n        }\n    });\n\n    ui.plugin(DockManager);\n})(window.kendo.jQuery);\nvar kendo$1 = kendo;\n\nexport { kendo$1 as default };\n"]}