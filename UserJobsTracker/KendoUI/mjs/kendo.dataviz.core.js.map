{"version":3,"sources":["raw-mjs/kendo.dataviz.core.js"],"names":["$","window","kendo","dataviz","drawing","util","Path","Group","Class","support","geometry","Rect","Circle","geometryTransform","transform","Segment","deepExtend","isFunction","__common_getter_js","getter","ARC","AXIS_LABEL_CLICK","BLACK","BOTTOM","CENTER","CIRCLE","CROSS","DATE","DEFAULT_FONT","DEFAULT_PRECISION","FORMAT_REGEX","HEIGHT","INSIDE","LEFT","MAX_VALUE","Number","MIN_VALUE","NONE","NOTE_CLICK","NOTE_HOVER","NOTE_LEAVE","OBJECT","OUTSIDE","RIGHT","ROUNDED_RECT","STRING","TOP","TRIANGLE","WHITE","WIDTH","X","Y","constants","ARROW_UP","ARROW_DOWN","ARROW_LEFT","ARROW_RIGHT","TAB","ARIA_ACTIVE_DESCENDANT","COORD_PRECISION","DEFAULT_HEIGHT","DEFAULT_WIDTH","END","ENTER","ESCAPE","HIGHLIGHT_ZINDEX","INHERIT","START","SQUARE","RECT","VALUE","DEFAULT_SERIES_OPACITY","POINTER","HORIZONTAL","VERTICAL","isArray","value","Array","addClass","element","classes","classArray","idx","length","className","indexOf","SPACE_REGEX","removeClass","replace","alignPathToPixel","path","offset","options","stroke","defined","width","i","segments","anchor","round","translate","clockwise","angle1","angle2","x","y","isNumber","isNaN","isString","isObject","styleValue","SIZE_STYLES_REGEX","isSizeField","field","test","getSpacing","defaultSpacing","spacing","top","right","bottom","left","current","compile","template","TemplateService","extend","getTemplate","content","grep","array","callback","result","push","register","userImplementation","HashMap","this","_map","Map","inArray","prototype","get","key","set","TRIGGER","InstanceObserver","init","observer","handlers","handlerMap","trigger","name","args","isDefaultPrevented","callObserver","fnName","len","arguments","apply","requiresHandlers","names","isPlainObject","Object","toString","call","map","browser","ref","append","bindEvents","deg","elementOffset","elementSize","eventCoordinates","eventElement","hashKey","last","limitValue","objectKey","rad","unbindEvents","valueOrDefault","FontLoader","setDefaultOptions","type","proto","fetchFonts","fonts","state","depth","document","keys","forEach","loadFonts","promises","font","load","e","logToConsole","Promise","all","then","preloadFonts","KI_PREFFIX","KSVG_PREFFIX","HTMLBaseIcon","wrapper","addClasses","html","outerHTML","size","themeColor","flip","iconClass","stylingOptions","HTMLFontIcon","fn","currentIconClass","split","find","startsWith","icon","_className","HTMLSvgIcon","innerHTML","iconNameMatch","match","toUpperCase","svgIcons","setAttribute","svgElement","createElementNS","viewBox","appendChild","ICON_TYPES","svg","sparseArrayLimits","arr","min","max","isFinite","Math","undefined","Matrix","matrixRegexp","transformMatrix","getComputedStyle","unit","matrixString","members","parseFloat","Function","bind","concat","parseMatrix","autoTextColor","color","Color","isDark","DELETED","LegacySet","values","_index","_values","slice","filter","item","has","add","delete","index","clear","defineProperties","SetWrapper","_set","Set","from","Matrix$1","height","data","clone","m","row","col","line","each","f","includeEmpty","val","el","transpose","n","a","j","multiply","b","s","va","vb","inverse","augment","loop","k","imax","start","end","pos","v","argmax","tmp","returned","i$1","j$1","k$1","i$2","j$2","ret","STRING$1","FUNCTION","preventDefault","_defaultPrevented","Observable$$1","Class$$1","_events","__proto__","create","constructor","destroy","unbind","event","one","original","handler","that","eventNames","handlersIsFunction","eventName","first","eventName$1","unshift","eventArgs","events","sender","splice","_setEvents","this$1$1","autoMajorUnit","diff","abs","scale","pow","floor","log","relativeValue","Point","equals","point","rotate","center","degrees","theta","cosT","cos","sinT","sin","cx","cy","distanceTo","dx","dy","sqrt","onCircle","angle","radius","radians","Box","x1","y1","x2","y2","box","move","wrap","targetBox","wrapPoint","arrayPoint","snapTo","axis","alignTo","targetCenter","shrink","dw","dh","expand","pad","padding","unpad","containsPoint","points","getHash","join","overlaps","rotation","r1","rotatePoint","r2","r3","r4","toRect","hasSize","align","alignment","c1","c2","sizeFunc","Ring","innerRadius","startAngle","middle","setRadius","newRadius","radianAngle","ax","ay","adjacentBox","distance","sector","midAndle","midPoint","hw","hh","sa","ca","p","endAngle","vector","startPoint","startVector","endPoint","endVector","dist","getBBox","angles","allAngles","sort","numericComparer","startAngleIndex","endAngleIndex","Sector","ShapeBuilder","createRing","arc","Arc","radiusX","radiusY","fromArc","close","innerEnd","pointAt","lineTo","ChartElement","children","initUserOptions","reflow","currentChild","animation","getRoot","parent","getSender","service","getService","chartService","translateChildren","childrenCount","arguments$1","renderVisual","visible","createVisual","addVisual","renderChildren","createAnimation","renderComplete","visual","chartElement","appendVisual","zIndex","Animation","childVisual","noclip","clipRoot","stackRoot","stackVisual","isStackRoot","visuals","sibling","insert","traverse","child","closest","matched","hasHighlight","highlight","createHighlight","toggleHighlight","show","opacity","customVisual","_highlight","highlightOptions","fill","highlightVisualArgs","series","dataItem","category","percentage","runningTotal","total","toggleFocusHighlight","accessibility","focusHighlight","_focusHighlight","highlightColor","background","focusHighlightOptions","border","createFocusHighlight","createGradientOverlay","gradientOptions","overlay","createGradient","closed","elements","supportsPointInactiveOpacity","BoxElement","margin","shrinkToFit","hasSetSize","borderWidth","reflowPaddingBox","vAlign","paddingBox","contentBox","hasBox","fromRect","visualStyle","dashType","cursor","ShapeElement","pointData","getElement","halfWidth","halfHeight","style","fromPoints","MultiPath","moveTo","rect","borderRadius","setCornerRadius","createElement","visualOptions","accessibilityOptions","role","ariaLabel","ariaRoleDescription","ariaChecked","RADIAL","GRADIENTS","glass","stops","sharpBevel","roundedBevel","roundedGlass","supportVML","sharpGlass","bubbleShadow","boxDiff","r","c","d","g","h","boxes","RootElement","rootOptions","parseInt","gradients","currentBox","createBackground","drawingGradient","hashCode","gradient","LinearGradient","usedSpace","currentStops","currentStop","innerRadialStops","RadialGradient","cleanGradients","_observers","FloatElement","_initDirection","vertical","groupAxis","elementAxis","groupSizeField","elementSizeField","groupSpacing","elementSpacing","vSpacing","reflowChildren","ref$1","groupOptions","groups","groupsSize","maxGroupElementsSize","groupsCount","groupsStart","alignStart","groupStart","groupIdx","group","groupElements","elementStart","groupElementsCount","elementSize$$1","groupElementStart","groupSize","elementBox","maxSize","groupElementsSize","DrawingText","Text","measureText","baseline","paintOrder","topLeft","rectToBox","origin","bottomRight","ROWS_SPLIT_REGEX","TextBox","_initContainer","_autoReflow","rows","String","floatElement","textOptions","container","rowIdx","text","trim","visualFn","_boxReflow","visualBox","visualContext","clippedBBox","normalBox","rotatedBox","rotationTransform","context","getDefaultVisual","boxCenter","Title","_textBox","position","collapseVerticalMargins","items","prevBox","buildTitle","defaultOptions","title","titleOptions","orderTitles","titles","reverse","AxisLabel","format","culture","click","widget","alignRotation","bbox","matrix","rotationMatrix","rotationOrigin","alignAxis","distanceAxis","axisAnchor","transformCopy","topRight","bottomLeft","alignEnd","distanceLeft","distanceRight","alignCenter","Note","fields","render","hide","label","childAlias","noteTemplate","auto","aliasFor","marker","wrapperBox","lineStart","linePoints","createLine","defaultVisual","over","out","current$1","parseDate","Date","firstDay","IntlService","implementation","FORMAT_REPLACE_REGEX","FormatService","intlService","_intlService","formatString","intl","localeAuto","locale","placeholderFormat","substring","current$2","ChartService","chart","rtl","Boolean","notify","isPannable","pannable","lock","DomEventsBuilder","services","createAxisTick","tickOptions","tickX","tickY","tick","createAxisGridLine","gridLine","lineEnd","Axis","labels","majorTickSize","minorTickSize","minorTicks","minorTickType","majorTicks","majorTickType","initFields","_deferLabels","createLabels","createTitle","createNotes","labelsRange","skip","labelsCount","normalizeLabelRotation","labelOptions","step","clearLabels","autoRotateLabels","range","labelContext","count","createAxisLabel","clearTitle","lineBox","mirror","axisX","axisY","lineWidth","visualSize","notes","parseNoteValue","note","createPlotBands","gridLinesVisual","gridLines","_gridLines","createTicks","lineGroup","majorUnit","tickLineOptions","tickPositions","skipUnit","getMajorTickPositions","getMinorTickPositions","minorUnit","_alignLines","_lineGroup","getActualTickSize","tickSize","_backgroundPath","plotBands","plotArea","_plotbandGroup","altAxis","pane","axes","slotX","slotY","getSlot","to","createPlotBandLabel","bandRect","textbox","labelTemplate","createGridLines","minorGridLines","majorGridLines","axisLineVisible","linePos","lineOptions","sizeFn","titleSize","space","boxSize","maxLabelSize","labelSize","arrangeTitle","arrangeLabels","arrangeNotes","getLabelsTickPositions","labelTickIndex","labelsBetweenTicks","tickIx","firstTickPosition","nextTickPosition","positionStart","positionEnd","positionLabel","labelBox","labelOffset","labelX","labelY","autoRotateLabelAngle","slotWidth","limit","labelAngle","idx$1","slot","shouldRenderNote","noteSlot","secondAxis","axisLabelText","tmpl","defaultText","maxLabelOffset","lastLabel","offsetField","startPosition","endPosition","maxStartOffset","maxEndOffset","startTick","endTick","limitRange","rangeSize","minValue","maxValue","valueRange","seriesMin","seriesMax","lineDir","lineInfo","lineSize","axisDir","axisOrigin","pointOffset","scaleToDelta","rawScale","justified","prepareUserOptions","axisCrossingValue","MILLISECONDS","SECONDS","MINUTES","HOURS","DAYS","WEEKS","MONTHS","YEARS","TIME_PER_SECOND","TIME_PER_MINUTE","TIME_PER_HOUR","TIME_PER_DAY","TIME_PER_WEEK","TIME_PER_MONTH","TIME_PER_YEAR","TIME_PER_UNIT","years","months","weeks","days","hours","minutes","seconds","milliseconds","absoluteDateDiff","getTime","getTimezoneOffset","addTicks","date","ticks","toDate","startOfWeek","weekStartDay","daysToSubtract","day","getDay","adjustDST","getHours","setHours","addDuration","dateValue","getFullYear","getMonth","getDate","roundedDate","setMinutes","tzDiff","addHours","getSeconds","setSeconds","getMilliseconds","setMilliseconds","floorDate","ceilDate","dateComparer","dateDiff","toTime","dateEquals","timeIndex","baseUnit","dateIndex","baseUnitStep","startDate","duration","parseDates","dates","CategoryAxis","_ticks","categoriesHash","copy","categories","srcCategories","definedMin","definedMax","ceil","rangeIndices","totalRange","roundedRange","_seriesMax","scaleOptions","hideOutOfRangeLabels","valueAxis","firstLabel","getTicks","labelTicks","tickIndices","stepSize","indices","getTickPositions","positions","cache","hash","_hash","hasMinor","filterOutOfRangePositions","inRange","startIndex","endIndex","slotBox","singleSlot","p1","p2","limitSlot","limittedSlot","categoryIndex","pointCategoryIndex","startValue","getCategory","totalIndex","categoryAt","categoriesCount","translateRange","delta","scaleRange","limitedRangeIndices","minDelta","maxDelta","zoomRange","totalMin","totalMax","dataItems","hideOutOfRangeNotes","pan","pointsRange","diffStart","diffEnd","rangeMin","rangeMax","_categoriesMap","currentRangeIndices","totalCount","totalLimit","totalRangeIndices","indexCategories","map$$1","COORDINATE_LIMIT","DateLabelFormats","ZERO_THRESHOLD","BASE_UNITS","FIT","categoryRange","clearCache","_range","EmptyDateRange","displayIndices","displayRange","valueIndex","valuesCount","dateAt","DateRange","roundToBaseUnit","lowerEnd","roundToTotalStep","expandEnd","justifyEnd","valueStart","displayStart","next","valueEnd","displayEnd","_indices","minIdx","maxIdx","upper","roundedStep","autoBaseUnit","startUnit","startStep","unitSteps","nextStep","categoryLimits","span","autoBaseUnitSteps","maxDateGroups","autoUnit","autoUnitIx","units","totalUnits","shift","initUnit","toLowerCase","lastCategory","minDiff","categoryIx","defaultBaseUnit","DateCategoryAxis","dataRange","_parsed","panning","userSetBaseUnit","userSetBaseUnitStep","maxDivisions","safeOptions","forecast","_forecast","before","after","divisionOptions","dataRangeOptions","divisionRange","rangeLabels","last$$1","isEmpty","totalLimits","panRange","datesRange","indicesRange","fit","autoBaseUnitStep","maxDiff","rangeDiff","baseUnitIndex","stepIndex","createRangeLabels","arrangeRangeLabels","position$1","autoRotateRangeLabels","hideOverlappingLabels","firstRangeLabel","clip","lastRangeLabel","rangeLabel","unitFormat","dateFormats","createLabel","rotateLabel","dateRange","limitCoordinate","MIN_VALUE_RANGE$1","NumericAxis","autoOptions","narrowRange","autoMin","narrow","axisMin","autoAxisMin","autoMax","axisMax","autoAxisMax","roundToMajorUnit","remainderClose","autoAxisOptions","totalOptions","totalAxisOptions","userOptions","userSetMin","userSetMax","clearNullValues","userSetLimits","axisOptions","totalMajorUnit","getDivisions","stepValue","divisions","skipStep","getValue","endValue","isValidRange","divisor","ratio","remainder","DateValueAxis","timeUnits","baseUnitTime","userMajorUnit","actualUnits","unitsToAdd","head","tail","applyDefaults","axisCrossingValues","dir","limittedRange","MIN_VALUE_RANGE$2","LogarithmicAxis","base","logMaxRemainder","autoAxisMax$1","autoAxisMin$1","throwNegativeValuesError","initRange","logMin","logMax","floorMax","traverseMajorTicksPositions","tickPosition","traverseMinorTicksPositions","power","minorOptions","_minorIntervalOptions","minorStep","info","Error","GridLinesMixin","majorAngles","minorAngles","skipMajor","majorGridLineAngles","renderMajorGridLines","minorGridLineAngles","renderMinorGridLines","renderGridLines","radiusCallback","circle","gridLineAngles","skipAngles","divs","intervals","altAxisVisible","alpha","intervalAngle","RadarCategoryAxis","reflowLabels","measureBox","skipOption","stepOption","divCount","divAngle","majorIntervals","minorIntervals","interval","minorAngle","minorRadius","band","plotBandSlot","ring","totalDivs","slotAngle","fromValue","slotStart","PolarAxis","instanceOptions","atan2","PI","RadarNumericAxisMixin","polarAxis","bandStyle","shape","plotBandPoints","innerPoints","outerPoints","innerCircle","outerCircle","radarMajorGridLinePositions","radarMinorGridLinePositions","tickRadius","angleIx","angularDistance","gamma","beta","axisType","RadarNumericAxis","minorSkipStep","RadarLogarithmicAxis","CurveProcessor","process","dataPoints","removeDuplicates","initialControlPoint","lastControlPoint","p0","pop","tangent","controlOut","firstControlPoint","secondControlPoint","controlPoints","tangent$1","cp0","controlPoints$1","cp1","controlPoints$2","tangent$2","invertAxis","lineFunction","calculateFunction","isLine","xField","yField","restrict","switchOrientation","monotonic","isMonotonicByField","numberSign","oldXField","restrictControlPoint","cp","p3","t1","t2","xValue","yValue","controlPoint","Gradients","convertableToNumber","cycleUp","cycleDown","cycleIndex","elementStyles","styles","stylesArray","field$1","getAriaTemplate","ariaTemplate","ariaContent","hasClasses","classNames","interpolateValue","progress","mousewheelDelta","wheelDelta","webkit","devicePixelRatio","detail","renderIcon","iconElement","iconOptions","HTMLElement","predicate","elementScale","parentElement","parentMatrix","multiplyCopy","createHashSet","supported","defaultErrorHandler","error","INSERT","DELETE","BACKSPACE","ESC","UP","DOWN","HOME","SPACEBAR","PAGEUP","PAGEDOWN","F2","F10","F12","NUMPAD_PLUS","NUMPAD_MINUS","NUMPAD_DOT","hasOwnProperty","obj","property","Observable","lteDateIndex","sortedDates","low","high","currentDate","jQuery","draw","SASS_THEMES","ExportMixin","skipLegacy","exportVisual","exportSVG","exportImage","exportPDF","imageDataURL","Surface","exportGroup","canvas","css","display","appendTo","body","surface","image","_rootElement","toDataURL","remove","calendars","standard","Point2D","Box2D","mwDelta","originalEvent","__meta__","id","description","depends","hidden","kendo$1"],"mappings":"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","file":"kendo.dataviz.core.js","sourcesContent":["import './kendo.core.js';\nimport './kendo.drawing.js';\n\n/***********************************************************************\n * WARNING: this file is auto-generated.  If you change it directly,\n * your modifications will eventually be lost.  The source code is in\n * `kendo-charts` repository, you should make your changes there and\n * run `src-modules/sync.sh` in this repository.\n */\n\n(function($) {\n/* eslint-disable space-before-blocks, space-before-function-paren, curly, object-curly-spacing */\n\nwindow.kendo.dataviz = window.kendo.dataviz || {};\nvar drawing = kendo.drawing;\nvar util = drawing.util;\nvar Path = drawing.Path;\nvar Group = drawing.Group;\nvar Class = kendo.Class;\nvar support = kendo.support;\nvar geometry = kendo.geometry;\nvar Rect = geometry.Rect;\nvar Circle = geometry.Circle;\nvar geometryTransform = geometry.transform;\nvar Segment = geometry.Segment;\nvar dataviz = kendo.dataviz;\n\nvar deepExtend = kendo.deepExtend;\nvar isFunction = kendo.isFunction;\nvar __common_getter_js = kendo.getter;\n\nvar ARC = \"arc\";\nvar ARROW_UP = \"ArrowUp\";\nvar ARROW_DOWN = \"ArrowDown\";\nvar ARROW_LEFT = \"ArrowLeft\";\nvar ARROW_RIGHT = \"ArrowRight\";\nvar TAB = \"Tab\";\nvar ARIA_ACTIVE_DESCENDANT = \"aria-activedescendant\";\nvar AXIS_LABEL_CLICK = \"axisLabelClick\";\nvar BLACK = \"#000\";\nvar BOTTOM = \"bottom\";\nvar CENTER = \"center\";\nvar CIRCLE = \"circle\";\nvar COORD_PRECISION = 3;\nvar CROSS = \"cross\";\nvar DATE = \"date\";\nvar DEFAULT_FONT = \"12px sans-serif\";\nvar DEFAULT_HEIGHT = 400;\nvar DEFAULT_PRECISION = 10;\nvar DEFAULT_WIDTH = 600;\nvar END = \"end\";\nvar ENTER = \"Enter\";\nvar ESCAPE = \"Escape\";\nvar FORMAT_REGEX = /\\{\\d+:?/;\nvar HEIGHT = \"height\";\nvar HIGHLIGHT_ZINDEX = 100;\nvar INSIDE = \"inside\";\nvar INHERIT = \"inherit\";\nvar LEFT = \"left\";\nvar MAX_VALUE = Number.MAX_VALUE;\nvar MIN_VALUE = -Number.MAX_VALUE;\nvar NONE = \"none\";\nvar NOTE_CLICK = \"noteClick\";\nvar NOTE_HOVER = \"noteHover\";\nvar NOTE_LEAVE = \"noteLeave\";\nvar OBJECT = \"object\";\nvar OUTSIDE = \"outside\";\nvar RIGHT = \"right\";\nvar ROUNDED_RECT = \"roundedRect\";\nvar START = \"start\";\nvar STRING = \"string\";\nvar TOP = \"top\";\nvar TRIANGLE = \"triangle\";\nvar SQUARE = \"square\";\nvar RECT = \"rect\";\nvar VALUE = \"value\";\nvar WHITE = \"#fff\";\nvar WIDTH = \"width\";\nvar X = \"x\";\nvar Y = \"y\";\nvar DEFAULT_SERIES_OPACITY = 1;\nvar POINTER = \"pointer\";\nvar HORIZONTAL = \"horizontal\";\nvar VERTICAL = \"vertical\";\n\nvar constants = {\n\tARC: ARC,\n\tARROW_UP: ARROW_UP,\n\tARROW_DOWN: ARROW_DOWN,\n\tARROW_LEFT: ARROW_LEFT,\n\tARROW_RIGHT: ARROW_RIGHT,\n\tTAB: TAB,\n\tARIA_ACTIVE_DESCENDANT: ARIA_ACTIVE_DESCENDANT,\n\tAXIS_LABEL_CLICK: AXIS_LABEL_CLICK,\n\tBLACK: BLACK,\n\tBOTTOM: BOTTOM,\n\tCENTER: CENTER,\n\tCIRCLE: CIRCLE,\n\tCOORD_PRECISION: COORD_PRECISION,\n\tCROSS: CROSS,\n\tDATE: DATE,\n\tDEFAULT_FONT: DEFAULT_FONT,\n\tDEFAULT_HEIGHT: DEFAULT_HEIGHT,\n\tDEFAULT_PRECISION: DEFAULT_PRECISION,\n\tDEFAULT_WIDTH: DEFAULT_WIDTH,\n\tEND: END,\n\tENTER: ENTER,\n\tESCAPE: ESCAPE,\n\tFORMAT_REGEX: FORMAT_REGEX,\n\tHEIGHT: HEIGHT,\n\tHIGHLIGHT_ZINDEX: HIGHLIGHT_ZINDEX,\n\tINSIDE: INSIDE,\n\tINHERIT: INHERIT,\n\tLEFT: LEFT,\n\tMAX_VALUE: MAX_VALUE,\n\tMIN_VALUE: MIN_VALUE,\n\tNONE: NONE,\n\tNOTE_CLICK: NOTE_CLICK,\n\tNOTE_HOVER: NOTE_HOVER,\n\tNOTE_LEAVE: NOTE_LEAVE,\n\tOBJECT: OBJECT,\n\tOUTSIDE: OUTSIDE,\n\tRIGHT: RIGHT,\n\tROUNDED_RECT: ROUNDED_RECT,\n\tSTART: START,\n\tSTRING: STRING,\n\tTOP: TOP,\n\tTRIANGLE: TRIANGLE,\n\tSQUARE: SQUARE,\n\tRECT: RECT,\n\tVALUE: VALUE,\n\tWHITE: WHITE,\n\tWIDTH: WIDTH,\n\tX: X,\n\tY: Y,\n\tDEFAULT_SERIES_OPACITY: DEFAULT_SERIES_OPACITY,\n\tPOINTER: POINTER,\n\tHORIZONTAL: HORIZONTAL,\n\tVERTICAL: VERTICAL\n};\n\nfunction isArray(value) {\n    return Array.isArray(value);\n}\n\nfunction addClass(element, classes) {\n    var classArray = isArray(classes) ? classes : [ classes ];\n\n    for (var idx = 0; idx < classArray.length; idx++) {\n        var className = classArray[idx];\n        if (element.className.indexOf(className) === -1) {\n            element.className += \" \" + className;\n        }\n    }\n}\n\nvar SPACE_REGEX = /\\s+/g;\n\nfunction removeClass(element, className) {\n    if (element && element.className) {\n        element.className = element.className.replace(className, \"\").replace(SPACE_REGEX, \" \");\n    }\n}\n\nfunction alignPathToPixel(path) {\n    var offset = 0.5;\n    if (path.options.stroke && kendo.drawing.util.defined(path.options.stroke.width)) {\n        if (path.options.stroke.width % 2 === 0) {\n            offset = 0;\n        }\n    }\n\n    for (var i = 0; i < path.segments.length; i++) {\n        path.segments[i].anchor().round(0).translate(offset, offset);\n    }\n\n    return path;\n}\n\nfunction clockwise(angle1, angle2) {\n    // True if angle2 is clockwise of angle1\n    // assuming angles grow in clock-wise direction\n    // (as in the pie and radar charts)\n    return -angle1.x * angle2.y + angle1.y * angle2.x < 0;\n}\n\nfunction isNumber(value) {\n    return typeof value === \"number\" && !isNaN(value);\n}\n\nfunction isString(value) {\n    return typeof value === STRING;\n}\n\nfunction convertableToNumber(value) {\n    return isNumber(value) || (isString(value) && isFinite(value));\n}\n\nfunction cycleUp(index, count) {\n    return (index + 1) % count;\n}\n\nfunction cycleDown(index, count) {\n    var result = index - 1;\n\n    return result < 0 ? count - 1 : result;\n}\n\nfunction cycleIndex(index, length) {\n    if (length === 1 || (index % length) === 0) {\n        return 0;\n    }\n\n    if (index < 0) {\n        return length + (index % length);\n    } else if (index >= length) {\n        return index % length;\n    }\n\n    return index;\n}\n\nfunction isObject(value) {\n    return typeof value === \"object\";\n}\n\nfunction styleValue(value) {\n    if (isNumber(value)) {\n        return value + \"px\";\n    }\n    return value;\n}\n\nvar SIZE_STYLES_REGEX = /width|height|top|left|bottom|right/i;\n\nfunction isSizeField(field) {\n    return SIZE_STYLES_REGEX.test(field);\n}\n\nfunction elementStyles(element, styles) {\n    var stylesArray = isString(styles) ? [ styles ] : styles;\n\n    if (isArray(stylesArray)) {\n        var result = {};\n        var style = window.getComputedStyle(element);\n\n        for (var idx = 0; idx < stylesArray.length; idx++) {\n            var field = stylesArray[idx];\n            result[field] = isSizeField(field) ? parseFloat(style[field]) : style[field];\n        }\n\n        return result;\n    } else if (isObject(styles)) {\n        for (var field$1 in styles) {\n            element.style[field$1] = styleValue(styles[field$1]);\n        }\n    }\n}\n\nfunction getSpacing(value, defaultSpacing) {\n    if (defaultSpacing === void 0) { defaultSpacing = 0; }\n\n    var spacing = { top: 0, right: 0, bottom: 0, left: 0 };\n\n    if (typeof(value) === \"number\") {\n        spacing[TOP] = spacing[RIGHT] = spacing[BOTTOM] = spacing[LEFT] = value;\n    } else {\n        spacing[TOP] = value[TOP] || defaultSpacing;\n        spacing[RIGHT] = value[RIGHT] || defaultSpacing;\n        spacing[BOTTOM] = value[BOTTOM] || defaultSpacing;\n        spacing[LEFT] = value[LEFT] || defaultSpacing;\n    }\n\n    return spacing;\n}\n\nvar current = {\n    compile: function(template) {\n        return template;\n    }\n};\n\nvar TemplateService = Class.extend({\n\n});\n\nTemplateService.register = function(userImplementation) {\n    current = userImplementation;\n};\n\nTemplateService.compile = function(template, options) {\n    return current.compile(template, options);\n};\n\nfunction getTemplate(options) {\n    if (options === void 0) { options = {}; }\n\n    var template;\n    if (options.template) {\n        options.template = template = TemplateService.compile(options.template);\n    } else if (isFunction(options.content)) {\n        template = options.content;\n    }\n\n    return template;\n}\n\nfunction getTemplate$1(options) {\n    if (options === void 0) { options = {}; }\n\n    var ariaTemplate;\n    if (options.ariaTemplate) {\n        options.ariaTemplate = ariaTemplate = TemplateService.compile(options.ariaTemplate);\n    } else if (isFunction(options.ariaContent)) {\n        ariaTemplate = options.ariaContent;\n    }\n\n    return ariaTemplate;\n}\n\nfunction grep(array, callback) {\n    var length = array.length;\n    var result = [];\n    for (var idx = 0; idx < length; idx++) {\n        if (callback(array[idx])) {\n            result .push(array[idx]);\n        }\n    }\n\n    return result;\n}\n\nfunction hasClasses(element, classNames) {\n    if (element.className) {\n        var names = classNames.split(\" \");\n        for (var idx = 0; idx < names.length; idx++) {\n            if (element.className.indexOf && element.className.indexOf(names[idx]) !== -1) {\n                return true;\n            }\n        }\n    }\n}\n\n// TODO: Remove and replace with Map/WeakMap.\nvar HashMap = function HashMap() {\n    this._map = new Map();\n};\n\nHashMap.prototype.get = function get (key) {\n    return this._map.get(key);\n};\n\nHashMap.prototype.set = function set (key, value) {\n    this._map.set(key, value);\n};\n\nfunction inArray(value, array) {\n    if (array) {\n        return array.indexOf(value) !== -1;\n    }\n}\n\nfunction interpolateValue(start, end, progress) {\n    return kendo.drawing.util.round(start + (end - start) * progress, COORD_PRECISION);\n}\n\nvar TRIGGER = 'trigger';\n\nvar InstanceObserver = Class.extend({\n    init: function(observer, handlers) {\n        this.observer = observer;\n        this.handlerMap = deepExtend({}, this.handlerMap, handlers);\n    },\n\n    trigger: function(name, args) {\n        var ref = this;\n        var observer = ref.observer;\n        var handlerMap = ref.handlerMap;\n        var isDefaultPrevented;\n        if (handlerMap[name]) {\n            isDefaultPrevented = this.callObserver(handlerMap[name], args);\n        } else if (observer[TRIGGER]) {\n            isDefaultPrevented = this.callObserver(TRIGGER, name, args);\n        }\n\n        return isDefaultPrevented;\n    },\n\n    callObserver: function(fnName) {\n        var args = [], len = arguments.length - 1;\n        while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n        return this.observer[fnName].apply(this.observer, args);\n    },\n\n    requiresHandlers: function(names) {\n        var this$1$1 = this;\n\n        if (this.observer.requiresHandlers) {\n            return this.observer.requiresHandlers(names);\n        }\n\n        for (var idx = 0; idx < names.length; idx++) {\n            if (this$1$1.handlerMap[names[idx]]) {\n                return true;\n            }\n        }\n    }\n});\n\nfunction isPlainObject(value) {\n    return Object.prototype.toString.call(value) === \"[object Object]\";\n}\n\nfunction map(array, callback) {\n    var length = array.length;\n    var result = [];\n    for (var idx = 0; idx < length; idx++) {\n        var value = callback(array[idx]);\n        if (kendo.drawing.util.defined(value)) {\n            result.push(value);\n        }\n    }\n    return result;\n}\n\nvar browser = support.browser || {};\n\nfunction mousewheelDelta(e) {\n    var delta = 0;\n\n    if (e.wheelDelta) {\n        delta = -e.wheelDelta / 120;\n\n        if (browser.webkit) {\n            // Webkit browsers scale the delta by twice the device resolution.\n            // Possibly related to https://bugs.webkit.org/show_bug.cgi?id=196339\n            //\n            // Low device resolutions (e.g. zoom-out to 30%) also behave strangely.\n            delta = delta / (2 * Math.max(window.devicePixelRatio, 0.625));\n        }\n    } else if (e.detail) {\n        delta = e.detail / 3;\n    }\n\n    delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);\n\n    return delta;\n}\n\nvar ref = kendo.drawing.util;\nvar append = ref.append;\nvar bindEvents = ref.bindEvents;\nvar defined = ref.defined;\nvar deg = ref.deg;\nvar elementOffset = ref.elementOffset;\nvar elementSize = ref.elementSize;\nvar eventCoordinates = ref.eventCoordinates;\nvar eventElement = ref.eventElement;\nvar hashKey = ref.hashKey;\nvar last = ref.last;\nvar limitValue = ref.limitValue;\nvar objectKey = ref.objectKey;\nvar rad = ref.rad;\nvar round = ref.round;\nvar unbindEvents = ref.unbindEvents;\nvar valueOrDefault = ref.valueOrDefault;\n\nvar FontLoader = Class.extend({\n\n});\n\nFontLoader.fetchFonts = function(options, fonts, state) {\n    if (state === void 0) { state = { depth: 0 }; }\n\n    var MAX_DEPTH = 5;\n\n    if (!options || state.depth > MAX_DEPTH || !document.fonts) {\n        return;\n    }\n\n    Object.keys(options).forEach(function(key) {\n        var value = options[key];\n        if (key === \"dataSource\" || key[0] === \"$\" || !value) {\n            return;\n        }\n\n        if (key === \"font\") {\n            fonts.push(value);\n        } else if (typeof value === \"object\") {\n            state.depth++;\n            FontLoader.fetchFonts(value, fonts, state);\n            state.depth--;\n        }\n    });\n};\n\nFontLoader.loadFonts = function(fonts, callback) {\n    var promises = [];\n\n    if (fonts.length > 0 && document.fonts) {\n        try {\n            promises = fonts.map(function(font) {\n                return document.fonts.load(font);\n            });\n        } catch (e) {\n            // Silence font-loading errors\n            kendo.logToConsole(e);\n        }\n\n        Promise.all(promises).then(callback, callback);\n    } else {\n        callback();\n    }\n};\n\nFontLoader.preloadFonts = function(options, callback) {\n    var fonts = [];\n    FontLoader.fetchFonts(options, fonts);\n\n    FontLoader.loadFonts(fonts, callback);\n};\n\nfunction setDefaultOptions(type, options) {\n    var proto = type.prototype;\n    if (proto.options) {\n        proto.options = deepExtend({}, proto.options, options);\n    } else {\n        proto.options = options;\n    }\n}\n\nvar KICON = 'k-icon';\nvar KI_PREFFIX = 'k-i-';\nvar KFONTICON = 'k-font-icon';\nvar KSVGICON = 'k-svg-icon';\nvar KSVG_PREFFIX = 'k-svg-i-';\n\nvar HTMLBaseIcon = Class.extend({\n    init: function(element, options) {\n        this.element = element;\n        this.options = deepExtend({}, this.options, options);\n\n        this.wrapper();\n    },\n\n    wrapper: function() {\n        this.addClasses();\n    },\n\n    addClasses: function() {\n    },\n\n    html: function() {\n        return this.element.outerHTML;\n    }\n});\n\nsetDefaultOptions(HTMLBaseIcon, {\n    name: '',\n    size: 'none',\n    themeColor: 'none',\n    flip: 'default',\n    iconClass: '',\n    stylingOptions: [ 'size', 'themeColor', 'fill' ]\n});\n\nvar HTMLFontIcon = HTMLBaseIcon.extend({\n    init: function(element, options) {\n        HTMLBaseIcon.fn.init.call(this, element, options);\n    },\n\n    wrapper: function() {\n        // Find if there is an existing k-i- class appended to the element.\n        var currentIconClass = this.element.className.split(\" \").find(function (x) { return x.startsWith(KI_PREFFIX); });\n        var className = this.options.icon ? (\"\" + (this.options.icon.startsWith(KI_PREFFIX) ? \"\" : KI_PREFFIX) + (this.options.icon)) : \"\";\n\n        this._className = className;\n\n        addClass(this.element, KICON);\n        addClass(this.element, KFONTICON);\n        removeClass(this.element, currentIconClass); // Remove any existing icons.\n        addClass(this.element, className);\n        addClass(this.element, this.options.iconClass || '');\n\n        HTMLBaseIcon.fn.wrapper.call(this);\n    }\n});\n\nsetDefaultOptions(HTMLFontIcon, {\n    name: 'HTMLFontIcon',\n    icon: null\n});\n\nvar HTMLSvgIcon = HTMLBaseIcon.extend({\n    init: function(element, options) {\n        // Ensure that the inner contents of the wrapping span element are always removed for re-rendering purposes.\n        element.innerHTML = \"\";\n\n        HTMLBaseIcon.fn.init.call(this, element, options);\n    },\n\n    wrapper: function() {\n        var icon = this.options.icon;\n        var iconClass = this.options.iconClass;\n        var currentIconClass = this.element.className.split(\" \").find(function (x) { return x.startsWith(KSVG_PREFFIX); });\n\n        if (!icon && iconClass) {\n            // match k-i-(some-icon-name)\n            var regex = /k-i-(\\w+(?:-\\w+)*)/;\n            var iconNameMatch = iconClass.match(regex);\n            if (iconNameMatch) {\n                icon = iconNameMatch[1];\n                iconClass = iconClass.replace(iconNameMatch[0], \"\");\n            }\n        }\n\n        if (isString(icon)) {\n            icon = icon.replace(\"k-i-\", \"\").replace(/-./g, function (x) { return x[1].toUpperCase(); });\n            icon = this.options.svgIcons[icon] || this.options.svgIcons[(icon + \"Icon\")];\n        }\n\n        var className = icon && icon.name ? (\"\" + KSVG_PREFFIX + (icon.name)) : \"\";\n        this._className = className;\n\n        addClass(this.element, KSVGICON);\n        removeClass(this.element, currentIconClass);\n        addClass(this.element, className);\n        addClass(this.element, iconClass || \"\");\n        this.element.setAttribute(\"aria-hidden\", \"true\");\n\n        if (icon && isPlainObject(icon)) {\n            var svgElement = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n            svgElement.setAttribute(\"viewBox\", icon.viewBox || \"\");\n            svgElement.setAttribute(\"focusable\", \"false\");\n            svgElement.innerHTML = icon.content || \"\";\n\n            this.element.appendChild(svgElement);\n        }\n\n        HTMLBaseIcon.fn.wrapper.call(this);\n    }\n});\n\nsetDefaultOptions(HTMLSvgIcon, {\n    name: 'HTMLSvgIcon',\n    icon: null,\n    svgIcons: {}\n});\n\nvar ICON_TYPES = {\n    'svg': HTMLSvgIcon,\n    'font': HTMLFontIcon\n};\n\nfunction renderIcon(iconElement, iconOptions) {\n    var element = iconElement;\n    var options = iconOptions;\n\n    if (!element\n        || (isObject(element) && !(element instanceof HTMLElement))\n        || isString(element)) {\n        options = element;\n        element = document.createElement(\"span\");\n    }\n\n    if (isString(options)) {\n        options = {\n            icon: options\n        };\n    }\n\n    if (!options.type) {\n        options.type = 'svg';\n    }\n\n    if (!ICON_TYPES[options.type]) {\n        return null;\n    }\n\n    return (new ICON_TYPES[options.type](element, options).html());\n}\n\nfunction sparseArrayLimits(arr) {\n    var min = MAX_VALUE;\n    var max = MIN_VALUE;\n\n    for (var idx = 0, length = arr.length; idx < length; idx++) {\n        var value = arr[idx];\n        if (value !== null && isFinite(value)) {\n            min = Math.min(min, value);\n            max = Math.max(max, value);\n        }\n    }\n\n    return {\n        min: min === MAX_VALUE ? undefined : min,\n        max: max === MIN_VALUE ? undefined : max\n    };\n}\n\nfunction find(array, predicate) {\n    for (var i = 0; i < array.length; i++) {\n        var item = array[i];\n        if (predicate(item, i, array)) {\n            return item;\n        }\n    }\n}\n\nvar Matrix = geometry.Matrix;\nvar matrixRegexp = /matrix\\((.*)\\)/;\n\nfunction parseMatrix(matrixString) {\n    var match = matrixString.match(matrixRegexp);\n    if (match === null || match.length !== 2) {\n        return Matrix.unit();\n    }\n\n    var members = match[1].split(',').map(function (x) { return parseFloat(x); });\n    return new (Function.prototype.bind.apply( Matrix, [ null ].concat( members) ));\n}\n\nfunction transformMatrix(element) {\n    var transform = getComputedStyle(element).transform;\n\n    if (transform === 'none') {\n        return Matrix.unit();\n    }\n\n    return parseMatrix(transform);\n}\n\nfunction elementScale(element) {\n    if (!element) {\n        return Matrix.unit();\n    }\n\n    var matrix = transformMatrix(element);\n    var parent = element.parentElement;\n    while (parent) {\n        var parentMatrix = transformMatrix(parent);\n        matrix = matrix.multiplyCopy(parentMatrix);\n        parent = parent.parentElement;\n    }\n\n    matrix.b = matrix.c = matrix.e = matrix.f = 0;\n    return matrix;\n}\n\nfunction autoTextColor(color) {\n    var isDark = new kendo.Color(color).isDark();\n    if (isDark) {\n        return WHITE;\n    }\n\n    return BLACK;\n}\n\nvar DELETED = {};\n\nvar LegacySet = Class.extend({\n    init: function(values) {\n        var this$1$1 = this;\n\n        this._index = {};\n        this._values = values ? values.slice(0) : [];\n\n        for (var i = 0; i < this._values.length; i++) {\n            this$1$1._index[this$1$1._values[i]] = i;\n        }\n    },\n\n    values: function() {\n        return this._values.filter(function (item) { return item !== DELETED; });\n    },\n\n    has: function(value) {\n        return this._index[value] !== undefined;\n    },\n\n    add: function(value) {\n        if (!this.has(value)) {\n            this._index[value] = this._values.length;\n            this._values.push(value);\n        }\n    },\n\n    delete: function(value) {\n        var index = this._index[value];\n        if (index !== undefined) {\n            this._values[index] = DELETED;\n            delete this._index[value];\n        }\n    },\n\n    clear: function() {\n        this._index = {};\n        this._values = [];\n    }\n});\n\nif (Object.defineProperties) {\n    Object.defineProperties(LegacySet.fn, {\n        size: {\n            get: function() {\n                return this._values.length;\n            }\n        }\n    });\n}\n\nvar SetWrapper = Class.extend({\n    init: function(values) {\n        this._set = new Set(values);\n    },\n\n    values: function() {\n        return Array.from(this._set);\n    },\n\n    has: function(value) {\n        return this._set.has(value);\n    },\n\n    add: function(value) {\n        this._set.add(value);\n    },\n\n    delete: function(value) {\n        this._set.delete(value);\n    },\n\n    clear: function() {\n        this._set.clear();\n    }\n});\n\nif (Object.defineProperties) {\n    Object.defineProperties(SetWrapper.fn, {\n        size: {\n            get: function() {\n                return this._set.size;\n            }\n        }\n    });\n}\n\n// TODO: Drop LegacySet when removing support for IE10\nvar supportsSet = function () {\n    var supported = false;\n\n    if (typeof Set === 'function') {\n        var set = new Set([1]);\n        supported = set.has(1);\n    }\n\n    return supported;\n};\n\nfunction createHashSet(values) {\n    if (supportsSet()) {\n        return new SetWrapper(values);\n    }\n\n    return new LegacySet(values);\n}\n\nfunction defaultErrorHandler(error) {\n    throw error;\n}\n\nvar keys = {\n    INSERT: 45,\n    DELETE: 46,\n    BACKSPACE: 8,\n    TAB: 9,\n    ENTER: 13,\n    ESC: 27,\n    LEFT: 37,\n    UP: 38,\n    RIGHT: 39,\n    DOWN: 40,\n    END: 35,\n    HOME: 36,\n    SPACEBAR: 32,\n    PAGEUP: 33,\n    PAGEDOWN: 34,\n    F2: 113,\n    F10: 121,\n    F12: 123,\n    NUMPAD_PLUS: 107,\n    NUMPAD_MINUS: 109,\n    NUMPAD_DOT: 110\n};\n\nfunction hasOwnProperty(obj, property) {\n    return Object.prototype.hasOwnProperty.call(obj, property);\n}\n\n// Based on the implementation from kendo-spreadsheet-common/src/calc.js\nvar Matrix$1 = Class.extend({\n    init: function() {\n        this.height = 0;\n        this.width = 0;\n        this.data = [];\n    },\n\n    clone: function() {\n        var m = new Matrix$1();\n        m.height = this.height;\n        m.width = this.width;\n        m.data = this.data.map(function (row) { return row.slice(); });\n        return m;\n    },\n\n    get: function(row, col) {\n        var line = this.data[row];\n        var val = line ? line[col] : null;\n        return val;\n    },\n\n    set: function(row, col, data) {\n        var line = this.data[row];\n        if (line == null) {\n            line = this.data[row] = [];\n        }\n        line[col] = data;\n        if (row >= this.height) {\n            this.height = row + 1;\n        }\n        if (col >= this.width) {\n            this.width = col + 1;\n        }\n    },\n\n    each: function(f, includeEmpty) {\n        var this$1$1 = this;\n\n        for (var row = 0; row < this.height; ++row) {\n            for (var col = 0; col < this.width; ++col) {\n                var val = this$1$1.get(row, col);\n                if (includeEmpty || val != null) {\n                    val = f(val, row, col);\n                    if (val !== undefined) {\n                        return val;\n                    }\n                }\n            }\n        }\n    },\n\n    map: function(f, includeEmpty) {\n        var m = new Matrix$1();\n        this.each(function(el, row, col) {\n            m.set(row, col, f(el, row, col));\n        }, includeEmpty);\n        return m;\n    },\n\n    transpose: function() {\n        var m = new Matrix$1();\n        this.each(function(el, row, col) {\n            m.set(col, row, el);\n        });\n        return m;\n    },\n\n    unit: function(n) {\n        this.width = this.height = n;\n        var a = this.data = new Array(n);\n        for (var i = n; --i >= 0;) {\n            var row = a[i] = new Array(n);\n            for (var j = n; --j >= 0;) {\n                row[j] = i === j ? 1 : 0;\n            }\n        }\n        return this;\n    },\n\n    multiply: function(b) {\n        var a = this;\n        var m = new Matrix$1();\n        for (var row = 0; row < a.height; ++row) {\n            for (var col = 0; col < b.width; ++col) {\n                var s = 0;\n                for (var i = 0; i < a.width; ++i) {\n                    var va = a.get(row, i);\n                    var vb = b.get(i, col);\n                    if (typeof va === \"number\" && typeof vb === \"number\") {\n                        s += va * vb;\n                    }\n                }\n                m.set(row, col, s);\n            }\n        }\n        return m;\n    },\n\n    inverse: function() {\n        var n = this.width;\n        var m = this.augment(new Matrix$1().unit(n));\n        var a = m.data;\n\n        // Gaussian elimination\n        // https://en.wikipedia.org/wiki/Gaussian_elimination#Finding_the_inverse_of_a_matrix\n\n        // 1. Get zeros below main diagonal\n        var loop = function ( k ) {\n            var imax = argmax(k, n, function(i) { return a[i][k]; });\n            if (!a[imax][k]) {\n                return { v: null }; // singular matrix\n            }\n            if (k !== imax) {\n                var tmp = a[k];\n                a[k] = a[imax];\n                a[imax] = tmp;\n            }\n            for (var i = k + 1; i < n; ++i) {\n                for (var j = k + 1; j < 2 * n; ++j) {\n                    a[i][j] -= a[k][j] * a[i][k] / a[k][k];\n                }\n                a[i][k] = 0;\n            }\n        };\n\n        for (var k = 0; k < n; ++k) {\n            var returned = loop( k );\n\n            if ( returned ) return returned.v;\n        }\n\n        // 2. Get 1-s on main diagonal, dividing by pivot\n        for (var i$1 = 0; i$1 < n; ++i$1) {\n            for (var f = a[i$1][i$1], j$1 = 0; j$1 < 2 * n; ++j$1) {\n                a[i$1][j$1] /= f;\n            }\n        }\n\n        // 3. Get zeros above main diagonal.  Actually, we only care to compute the right side\n        // here (that will be the inverse), so in the inner loop below we go while j >= n,\n        // instead of j >= k.\n        for (var k$1 = n; --k$1 >= 0;) {\n            for (var i$2 = k$1; --i$2 >= 0;) {\n                if (a[i$2][k$1]) {\n                    for (var j$2 = 2 * n; --j$2 >= n;) {\n                        a[i$2][j$2] -= a[k$1][j$2] * a[i$2][k$1];\n                    }\n                }\n            }\n        }\n\n        return m.slice(0, n, n, n);\n    },\n\n    augment: function(m) {\n        var ret = this.clone();\n        var n = ret.width;\n        m.each(function(val, row, col) {\n            ret.set(row, col + n, val);\n        });\n        return ret;\n    },\n\n    slice: function(row, col, height, width) {\n        var this$1$1 = this;\n\n        var m = new Matrix$1();\n        for (var i = 0; i < height; ++i) {\n            for (var j = 0; j < width; ++j) {\n                m.set(i, j, this$1$1.get(row + i, col + j));\n            }\n        }\n        return m;\n    }\n});\n\nfunction argmax(start, end, f) {\n    var max = f(start), pos = start;\n    for (var i = start + 1; i < end; i++) {\n        var v = f(start);\n        if (v > max) {\n            max = v;\n            pos = start;\n        }\n    }\n    return pos;\n}\n\nvar STRING$1 = \"string\";\nvar FUNCTION = \"function\";\n\nvar preventDefault = function() {\n    this._defaultPrevented = true;\n};\n\nvar isDefaultPrevented = function() {\n    return this._defaultPrevented === true;\n};\n\nvar Observable$$1 = (function (Class$$1) {\n    function Observable$$1() {\n        Class$$1.call(this);\n        this._events = {};\n    }\n\n    if ( Class$$1 ) Observable$$1.__proto__ = Class$$1;\n    Observable$$1.prototype = Object.create( Class$$1 && Class$$1.prototype );\n    Observable$$1.prototype.constructor = Observable$$1;\n\n    Observable$$1.prototype.destroy = function destroy () {\n        this.unbind();\n    };\n\n    Observable$$1.prototype.bind = function bind (event, handlers, one) {\n        var that = this,\n            idx,\n            eventNames = typeof event === STRING$1 ? [event] : event || [],\n            length,\n            original,\n            handler,\n            handlersIsFunction = typeof handlers === FUNCTION,\n            events;\n\n        if (handlers === undefined) {\n            for (idx in event) {\n                that.bind(idx, event[idx]);\n            }\n\n            return that;\n        }\n\n        /* eslint-disable no-loop-func */\n        var loop = function ( ) {\n            var eventName = eventNames[idx];\n\n            handler = handlersIsFunction ? handlers : handlers[eventName];\n\n            if (handler) {\n                if (one) {\n                    original = handler;\n                    handler = function() {\n                        that.unbind(eventName, handler);\n                        original.apply(that, arguments);\n                    };\n\n                    handler.original = original;\n                }\n\n                events = that._events[eventName] = that._events[eventName] || [];\n                events.push(handler);\n            }\n        };\n\n        for (idx = 0, length = eventNames.length; idx < length; idx++) loop( );\n        /* eslint-enable no-loop-func */\n\n        return that;\n    };\n\n    Observable$$1.prototype.one = function one (eventNames, handlers) {\n        return this.bind(eventNames, handlers, true);\n    };\n\n    Observable$$1.prototype.first = function first (eventName, handlers) {\n        var that = this,\n            idx,\n            eventNames = typeof eventName === STRING$1 ? [eventName] : eventName,\n            length,\n            handler,\n            handlersIsFunction = typeof handlers === FUNCTION,\n            events;\n\n        for (idx = 0, length = eventNames.length; idx < length; idx++) {\n            var eventName$1 = eventNames[idx];\n\n            handler = handlersIsFunction ? handlers : handlers[eventName$1];\n\n            if (handler) {\n                events = that._events[eventName$1] = that._events[eventName$1] || [];\n                events.unshift(handler);\n            }\n        }\n\n        return that;\n    };\n\n    Observable$$1.prototype.trigger = function trigger (eventName, eventArgs) {\n        var that = this,\n            events = that._events[eventName],\n            idx,\n            length;\n\n        if (events) {\n            var e = eventArgs || {};\n\n            e.sender = that;\n\n            e._defaultPrevented = false;\n\n            e.preventDefault = preventDefault;\n\n            e.isDefaultPrevented = isDefaultPrevented;\n\n            events = events.slice();\n\n            for (idx = 0, length = events.length; idx < length; idx++) {\n                events[idx].call(that, e);\n            }\n\n            return e._defaultPrevented === true;\n        }\n\n        return false;\n    };\n\n    Observable$$1.prototype.unbind = function unbind (eventName, handler) {\n        var that = this,\n            events = that._events[eventName],\n            idx;\n\n        if (eventName === undefined) {\n            that._events = {};\n        } else if (events) {\n            if (handler) {\n                for (idx = events.length - 1; idx >= 0; idx--) {\n                    if (events[idx] === handler || events[idx].original === handler) {\n                        events.splice(idx, 1);\n                    }\n                }\n            } else {\n                that._events[eventName] = [];\n            }\n        }\n\n        return that;\n    };\n\n    Observable$$1.prototype._setEvents = function _setEvents (options) {\n        var this$1$1 = this;\n\n        var length = (this.events || []).length;\n\n        for (var idx = 0; idx < length; idx ++) {\n            var e = this$1$1.events[idx];\n\n            if (this$1$1.options[e] && options[e]) {\n                this$1$1.unbind(e, this$1$1.options[e]);\n\n                if (this$1$1._events && this$1$1._events[e]) {\n                    delete this$1$1._events[e];\n                }\n            }\n        }\n\n        this.bind(this.events, options);\n    };\n\n    return Observable$$1;\n}(Class));\n\nfunction autoMajorUnit(min, max) {\n    var diff = round(max - min, DEFAULT_PRECISION - 1);\n\n    if (diff === 0) {\n        if (max === 0) {\n            return 0.1;\n        }\n\n        diff = Math.abs(max);\n    }\n\n    var scale = Math.pow(10, Math.floor(Math.log(diff) / Math.log(10)));\n    var relativeValue = round((diff / scale), DEFAULT_PRECISION);\n    var scaleMultiplier = 1;\n\n    if (relativeValue < 1.904762) {\n        scaleMultiplier = 0.2;\n    } else if (relativeValue < 4.761904) {\n        scaleMultiplier = 0.5;\n    } else if (relativeValue < 9.523809) {\n        scaleMultiplier = 1;\n    } else {\n        scaleMultiplier = 2;\n    }\n\n    return round(scale * scaleMultiplier, DEFAULT_PRECISION);\n}\n\nvar Point = Class.extend({\n    init: function(x, y) {\n\n        this.x = x || 0;\n        this.y = y || 0;\n    },\n\n    clone: function() {\n        return new Point(this.x, this.y);\n    },\n\n    equals: function(point) {\n        return point && this.x === point.x && this.y === point.y;\n    },\n\n    rotate: function(center, degrees) {\n        var theta = rad(degrees);\n        var cosT = Math.cos(theta);\n        var sinT = Math.sin(theta);\n        var cx = center.x;\n        var cy = center.y;\n        var ref = this;\n        var x = ref.x;\n        var y = ref.y;\n\n        this.x = round(\n            cx + (x - cx) * cosT + (y - cy) * sinT,\n            COORD_PRECISION\n        );\n\n        this.y = round(\n            cy + (y - cy) * cosT - (x - cx) * sinT,\n            COORD_PRECISION\n        );\n\n        return this;\n    },\n\n    multiply: function(a) {\n\n        this.x *= a;\n        this.y *= a;\n\n        return this;\n    },\n\n    distanceTo: function(point) {\n        var dx = this.x - point.x;\n        var dy = this.y - point.y;\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n});\n\nPoint.onCircle = function(center, angle, radius) {\n    var radians = rad(angle);\n\n    return new Point(\n        center.x - radius * Math.cos(radians),\n        center.y - radius * Math.sin(radians)\n    );\n};\n\nvar Box = Class.extend({\n    init: function(x1, y1, x2, y2) {\n\n        this.x1 = x1 || 0;\n        this.y1 = y1 || 0;\n        this.x2 = x2 || 0;\n        this.y2 = y2 || 0;\n    },\n\n    equals: function(box) {\n        return this.x1 === box.x1 && this.x2 === box.x2 &&\n            this.y1 === box.y1 && this.y2 === box.y2;\n    },\n\n    width: function() {\n        return this.x2 - this.x1;\n    },\n\n    height: function() {\n        return this.y2 - this.y1;\n    },\n\n    translate: function(dx, dy) {\n        this.x1 += dx;\n        this.x2 += dx;\n        this.y1 += dy;\n        this.y2 += dy;\n\n        return this;\n    },\n\n    move: function(x, y) {\n        var height = this.height();\n        var width = this.width();\n\n        if (defined(x)) {\n            this.x1 = x;\n            this.x2 = this.x1 + width;\n        }\n\n        if (defined(y)) {\n            this.y1 = y;\n            this.y2 = this.y1 + height;\n        }\n\n        return this;\n    },\n\n    wrap: function(targetBox) {\n        this.x1 = Math.min(this.x1, targetBox.x1);\n        this.y1 = Math.min(this.y1, targetBox.y1);\n        this.x2 = Math.max(this.x2, targetBox.x2);\n        this.y2 = Math.max(this.y2, targetBox.y2);\n\n        return this;\n    },\n\n    wrapPoint: function(point) {\n        var arrayPoint = isArray(point);\n        var x = arrayPoint ? point[0] : point.x;\n        var y = arrayPoint ? point[1] : point.y;\n        this.wrap(new Box(x, y, x, y));\n\n        return this;\n    },\n\n    snapTo: function(targetBox, axis) {\n\n        if (axis === X || !axis) {\n            this.x1 = targetBox.x1;\n            this.x2 = targetBox.x2;\n        }\n\n        if (axis === Y || !axis) {\n            this.y1 = targetBox.y1;\n            this.y2 = targetBox.y2;\n        }\n\n        return this;\n    },\n\n    alignTo: function(targetBox, anchor) {\n        var height = this.height();\n        var width = this.width();\n        var axis = anchor === TOP || anchor === BOTTOM ? Y : X;\n        var offset = axis === Y ? height : width;\n\n        if (anchor === CENTER) {\n            var targetCenter = targetBox.center();\n            var center = this.center();\n\n            this.x1 += targetCenter.x - center.x;\n            this.y1 += targetCenter.y - center.y;\n        } else if (anchor === TOP || anchor === LEFT) {\n            this[axis + 1] = targetBox[axis + 1] - offset;\n        } else {\n            this[axis + 1] = targetBox[axis + 2];\n        }\n\n        this.x2 = this.x1 + width;\n        this.y2 = this.y1 + height;\n\n        return this;\n    },\n\n    shrink: function(dw, dh) {\n\n        this.x2 -= dw;\n        this.y2 -= dh;\n\n        return this;\n    },\n\n    expand: function(dw, dh) {\n        this.shrink(-dw, -dh);\n        return this;\n    },\n\n    pad: function(padding) {\n        var spacing = getSpacing(padding);\n\n        this.x1 -= spacing.left;\n        this.x2 += spacing.right;\n        this.y1 -= spacing.top;\n        this.y2 += spacing.bottom;\n\n        return this;\n    },\n\n    unpad: function(padding) {\n        var spacing = getSpacing(padding);\n\n        spacing.left = -spacing.left;\n        spacing.top = -spacing.top;\n        spacing.right = -spacing.right;\n        spacing.bottom = -spacing.bottom;\n\n        return this.pad(spacing);\n    },\n\n    clone: function() {\n        return new Box(this.x1, this.y1, this.x2, this.y2);\n    },\n\n    center: function() {\n        return new Point(\n            this.x1 + this.width() / 2,\n            this.y1 + this.height() / 2\n        );\n    },\n\n    containsPoint: function(point) {\n\n        return point.x >= this.x1 && point.x <= this.x2 &&\n               point.y >= this.y1 && point.y <= this.y2;\n    },\n\n    points: function() {\n        return [\n            new Point(this.x1, this.y1),\n            new Point(this.x2, this.y1),\n            new Point(this.x2, this.y2),\n            new Point(this.x1, this.y2)\n        ];\n    },\n\n    getHash: function() {\n        return [ this.x1, this.y1, this.x2, this.y2 ].join(\",\");\n    },\n\n    overlaps: function(box) {\n        return !(box.y2 < this.y1 || this.y2 < box.y1 || box.x2 < this.x1 || this.x2 < box.x1);\n    },\n\n    rotate: function(rotation) {\n        var width = this.width();\n        var height = this.height();\n        var ref = this.center();\n        var cx = ref.x;\n        var cy = ref.y;\n\n        var r1 = rotatePoint(0, 0, cx, cy, rotation);\n        var r2 = rotatePoint(width, 0, cx, cy, rotation);\n        var r3 = rotatePoint(width, height, cx, cy, rotation);\n        var r4 = rotatePoint(0, height, cx, cy, rotation);\n\n        width = Math.max(r1.x, r2.x, r3.x, r4.x) - Math.min(r1.x, r2.x, r3.x, r4.x);\n        height = Math.max(r1.y, r2.y, r3.y, r4.y) - Math.min(r1.y, r2.y, r3.y, r4.y);\n\n        this.x2 = this.x1 + width;\n        this.y2 = this.y1 + height;\n\n        return this;\n    },\n\n    toRect: function() {\n        return new Rect([ this.x1, this.y1 ], [ this.width(), this.height() ]);\n    },\n\n    hasSize: function() {\n        return this.width() !== 0 && this.height() !== 0;\n    },\n\n    align: function(targetBox, axis, alignment) {\n        var c1 = axis + 1;\n        var c2 = axis + 2;\n        var sizeFunc = axis === X ? WIDTH : HEIGHT;\n        var size = this[sizeFunc]();\n\n        if (inArray(alignment, [ LEFT, TOP ])) {\n            this[c1] = targetBox[c1];\n            this[c2] = this[c1] + size;\n        } else if (inArray(alignment, [ RIGHT, BOTTOM ])) {\n            this[c2] = targetBox[c2];\n            this[c1] = this[c2] - size;\n        } else if (alignment === CENTER) {\n            this[c1] = targetBox[c1] + (targetBox[sizeFunc]() - size) / 2;\n            this[c2] = this[c1] + size;\n        }\n    }\n});\n\nfunction rotatePoint(x, y, cx, cy, angle) {\n    var theta = rad(angle);\n\n    return new Point(\n        cx + (x - cx) * Math.cos(theta) + (y - cy) * Math.sin(theta),\n        cy - (x - cx) * Math.sin(theta) + (y - cy) * Math.cos(theta)\n    );\n}\n\nvar Ring = Class.extend({\n    init: function(center, innerRadius, radius, startAngle, angle) {\n\n        this.center = center;\n        this.innerRadius = innerRadius;\n        this.radius = radius;\n        this.startAngle = startAngle;\n        this.angle = angle;\n    },\n\n    clone: function() {\n        return new Ring(this.center, this.innerRadius, this.radius, this.startAngle, this.angle);\n    },\n\n    middle: function() {\n        return this.startAngle + this.angle / 2;\n    },\n\n    setRadius: function(newRadius, innerRadius) {\n        if (innerRadius) {\n            this.innerRadius = newRadius;\n        } else {\n            this.radius = newRadius;\n        }\n\n        return this;\n    },\n\n    point: function(angle, innerRadius) {\n        var radianAngle = rad(angle);\n        var ax = Math.cos(radianAngle);\n        var ay = Math.sin(radianAngle);\n        var radius = innerRadius ? this.innerRadius : this.radius;\n        var x = round(this.center.x - (ax * radius), COORD_PRECISION);\n        var y = round(this.center.y - (ay * radius), COORD_PRECISION);\n\n        return new Point(x, y);\n    },\n\n    adjacentBox: function(distance, width, height) {\n        var sector = this.clone().expand(distance);\n        var midAndle = sector.middle();\n        var midPoint = sector.point(midAndle);\n        var hw = width / 2;\n        var hh = height / 2;\n        var sa = Math.sin(rad(midAndle));\n        var ca = Math.cos(rad(midAndle));\n        var x = midPoint.x - hw;\n        var y = midPoint.y - hh;\n\n        if (Math.abs(sa) < 0.9) {\n            x += hw * -ca / Math.abs(ca);\n        }\n\n        if (Math.abs(ca) < 0.9) {\n            y += hh * -sa / Math.abs(sa);\n        }\n\n        return new Box(x, y, x + width, y + height);\n    },\n\n    containsPoint: function(p) {\n        var center = this.center;\n        var innerRadius = this.innerRadius;\n        var radius = this.radius;\n        var startAngle = this.startAngle;\n        var endAngle = this.startAngle + this.angle;\n        var dx = p.x - center.x;\n        var dy = p.y - center.y;\n        var vector = new Point(dx, dy);\n        var startPoint = this.point(startAngle);\n        var startVector = new Point(startPoint.x - center.x, startPoint.y - center.y);\n        var endPoint = this.point(endAngle);\n        var endVector = new Point(endPoint.x - center.x, endPoint.y - center.y);\n        var dist = round(dx * dx + dy * dy, COORD_PRECISION);\n\n        return (startVector.equals(vector) || clockwise(startVector, vector)) &&\n               !clockwise(endVector, vector) &&\n               dist >= innerRadius * innerRadius && dist <= radius * radius;\n    },\n\n    getBBox: function() {\n        var this$1$1 = this;\n\n        var box = new Box(MAX_VALUE, MAX_VALUE, MIN_VALUE, MIN_VALUE);\n        var startAngle = round(this.startAngle % 360);\n        var endAngle = round((startAngle + this.angle) % 360);\n        var innerRadius = this.innerRadius;\n        var allAngles = [ 0, 90, 180, 270, startAngle, endAngle ].sort(numericComparer);\n        var startAngleIndex = allAngles.indexOf(startAngle);\n        var endAngleIndex = allAngles.indexOf(endAngle);\n        var angles;\n\n        if (startAngle === endAngle) {\n            angles = allAngles;\n        } else {\n            if (startAngleIndex < endAngleIndex) {\n                angles = allAngles.slice(startAngleIndex, endAngleIndex + 1);\n            } else {\n                angles = [].concat(\n                    allAngles.slice(0, endAngleIndex + 1),\n                    allAngles.slice(startAngleIndex, allAngles.length)\n                );\n            }\n        }\n\n        for (var i = 0; i < angles.length; i++) {\n            var point = this$1$1.point(angles[i]);\n            box.wrapPoint(point);\n            box.wrapPoint(point, innerRadius);\n        }\n\n        if (!innerRadius) {\n            box.wrapPoint(this.center);\n        }\n\n        return box;\n    },\n\n    expand: function(value) {\n        this.radius += value;\n        return this;\n    }\n});\n\nfunction numericComparer(a, b) {\n    return a - b;\n}\n\nvar Sector = Ring.extend({\n    init: function(center, radius, startAngle, angle) {\n        Ring.fn.init.call(this, center, 0, radius, startAngle, angle);\n    },\n\n    expand: function(value) {\n        return Ring.fn.expand.call(this, value);\n    },\n\n    clone: function() {\n        return new Sector(this.center, this.radius, this.startAngle, this.angle);\n    },\n\n    setRadius: function(newRadius) {\n        this.radius = newRadius;\n\n        return this;\n    }\n});\n\nvar DIRECTION_ANGLE = 0.001; //any value that will make the endAngle bigger than the start angle will work here.\n\nvar ShapeBuilder = Class.extend({\n    createRing: function(sector, options) {\n        var startAngle = sector.startAngle + 180;\n        var endAngle = sector.angle + startAngle;\n\n        //required in order to avoid reversing the arc direction in cases like 0.000000000000001 + 100 === 100\n        if (sector.angle === 0 || sector.angle > 0 && startAngle === endAngle) {\n            endAngle += DIRECTION_ANGLE;\n        }\n\n        var center = new geometry.Point(sector.center.x, sector.center.y);\n        var radius = Math.max(sector.radius, 0);\n        var innerRadius = Math.max(sector.innerRadius, 0);\n        var arc = new geometry.Arc(center, {\n            startAngle: startAngle,\n            endAngle: endAngle,\n            radiusX: radius,\n            radiusY: radius\n        });\n        var path = Path.fromArc(arc, options).close();\n\n        if (innerRadius) {\n            arc.radiusX = arc.radiusY = innerRadius;\n            var innerEnd = arc.pointAt(endAngle);\n            path.lineTo(innerEnd.x, innerEnd.y);\n            path.arc(endAngle, startAngle, innerRadius, innerRadius, true);\n        } else {\n            path.lineTo(center.x, center.y);\n        }\n\n        return path;\n    }\n});\n\nShapeBuilder.current = new ShapeBuilder();\n\nvar ChartElement = Class.extend({\n    init: function(options) {\n\n        this.children = [];\n\n        this.options = deepExtend({}, this.options, this.initUserOptions(options));\n    },\n\n    initUserOptions: function(options) {\n        return options;\n    },\n\n    reflow: function(targetBox) {\n        var children = this.children;\n        var box;\n\n        for (var i = 0; i < children.length; i++) {\n            var currentChild = children[i];\n            currentChild.reflow(targetBox);\n\n            box = box ? box.wrap(currentChild.box) : currentChild.box.clone();\n        }\n\n        this.box = box || targetBox;\n    },\n\n    destroy: function() {\n        var children = this.children;\n\n        if (this.animation) {\n            this.animation.destroy();\n        }\n\n        for (var i = 0; i < children.length; i++) {\n            children[i].destroy();\n        }\n    },\n\n    getRoot: function() {\n        var parent = this.parent;\n\n        return parent ? parent.getRoot() : null;\n    },\n\n    getSender: function() {\n        var service = this.getService();\n        if (service) {\n            return service.sender;\n        }\n    },\n\n    getService: function() {\n        var element = this;\n        while (element) {\n            if (element.chartService) {\n                return element.chartService;\n            }\n            element = element.parent;\n        }\n    },\n\n    translateChildren: function(dx, dy) {\n        var children = this.children;\n        var childrenCount = children.length;\n\n        for (var i = 0; i < childrenCount; i++) {\n            children[i].box.translate(dx, dy);\n        }\n    },\n\n    append: function() {\n        var arguments$1 = arguments;\n        var this$1$1 = this;\n\n        for (var i = 0; i < arguments.length; i++) {\n            var item = arguments$1[i];\n            this$1$1.children.push(item);\n            item.parent = this$1$1;\n        }\n    },\n\n    renderVisual: function() {\n        if (this.options.visible === false) {\n            return;\n        }\n\n        this.createVisual();\n\n        this.addVisual();\n\n        this.renderChildren();\n\n        this.createAnimation();\n        this.renderComplete();\n    },\n\n    addVisual: function() {\n        if (this.visual) {\n            this.visual.chartElement = this;\n\n            if (this.parent) {\n                this.parent.appendVisual(this.visual);\n            }\n        }\n    },\n\n    renderChildren: function() {\n        var children = this.children;\n        var length = children.length;\n        for (var i = 0; i < length; i++) {\n            children[i].renderVisual();\n        }\n    },\n\n    createVisual: function() {\n        this.visual = new Group({\n            zIndex: this.options.zIndex,\n            visible: valueOrDefault(this.options.visible, true)\n        });\n    },\n\n    createAnimation: function() {\n        if (this.visual && this.options.animation) {\n            this.animation = drawing.Animation.create(\n                this.visual, this.options.animation\n            );\n        }\n    },\n\n    appendVisual: function(childVisual) {\n        if (!childVisual.chartElement) {\n            childVisual.chartElement = this;\n        }\n\n        if (childVisual.options.noclip) {\n            this.clipRoot().visual.append(childVisual);\n        } else if (defined(childVisual.options.zIndex)) {\n            this.stackRoot().stackVisual(childVisual);\n        } else if (this.isStackRoot) {\n            this.stackVisual(childVisual);\n        } else if (this.visual) {\n            this.visual.append(childVisual);\n        } else {\n            // Allow chart elements without visuals to\n            // pass through child visuals\n            this.parent.appendVisual(childVisual);\n        }\n    },\n\n    clipRoot: function() {\n        if (this.parent) {\n            return this.parent.clipRoot();\n        }\n\n        return this;\n    },\n\n    stackRoot: function() {\n        if (this.parent) {\n            return this.parent.stackRoot();\n        }\n\n        return this;\n    },\n\n    stackVisual: function(childVisual) {\n        var zIndex = childVisual.options.zIndex || 0;\n        var visuals = this.visual.children;\n        var length = visuals.length;\n        var pos;\n\n        for (pos = 0; pos < length; pos++) {\n            var sibling = visuals[pos];\n            var here = valueOrDefault(sibling.options.zIndex, 0);\n            if (here > zIndex) {\n                break;\n            }\n        }\n\n        this.visual.insert(pos, childVisual);\n    },\n\n    traverse: function(callback) {\n        var children = this.children;\n        var length = children.length;\n\n        for (var i = 0; i < length; i++) {\n            var child = children[i];\n\n            callback(child);\n            if (child.traverse) {\n                child.traverse(callback);\n            }\n        }\n    },\n\n    closest: function(match) {\n        var element = this;\n        var matched = false;\n\n        while (element && !matched) {\n            matched = match(element);\n\n            if (!matched) {\n                element = element.parent;\n            }\n        }\n\n        if (matched) {\n            return element;\n        }\n    },\n\n    renderComplete: function() {},\n\n    hasHighlight: function() {\n        var options = (this.options || {}).highlight;\n        return !(!this.createHighlight || (options && options.visible === false) || this.visible === false);\n    },\n\n    toggleHighlight: function(show, opacity) {\n        var this$1$1 = this;\n\n        var options = (this.options || {}).highlight || {};\n        var customVisual = options.visual;\n        var highlight = this._highlight;\n\n        if (!highlight) {\n            var highlightOptions = {\n                fill: {\n                    color: WHITE,\n                    opacity: opacity || 0.2\n                },\n                stroke: {\n                    color: WHITE,\n                    width: 1,\n                    opacity: opacity || 0.2\n                }\n            };\n\n            if (customVisual) {\n                highlight = this._highlight = customVisual(\n                    $.extend(this.highlightVisualArgs(), {\n                        createVisual: function () { return this$1$1.createHighlight(highlightOptions); },\n                        sender: this.getSender(),\n                        series: this.series,\n                        dataItem: this.dataItem,\n                        category: this.category,\n                        value: this.value,\n                        percentage: this.percentage,\n                        runningTotal: this.runningTotal,\n                        total: this.total\n                    })\n                );\n\n                if (!highlight) {\n                    return;\n                }\n            } else {\n                highlight = this._highlight = this.createHighlight(highlightOptions);\n            }\n\n            if (!defined(highlight.options.zIndex)) {\n                highlight.options.zIndex = valueOrDefault(options.zIndex, this.options.zIndex);\n            }\n\n            this.appendVisual(highlight);\n        }\n\n        highlight.visible(show);\n    },\n\n    toggleFocusHighlight: function(show) {\n        var options = ((this.options || {}).accessibility || {}).highlight || {};\n        var focusHighlight = this._focusHighlight;\n\n        if (!show && !focusHighlight) {\n            return;\n        }\n\n        if (!focusHighlight) {\n            var rootBackground = this.getRoot().options.background;\n            var highlightColor = autoTextColor(rootBackground);\n            var focusHighlightOptions = {\n                fill: {\n                    opacity: options.opacity,\n                    color: options.color\n                },\n                stroke: $.extend({}, {color: highlightColor}, options.border),\n                zIndex: options.zIndex\n            };\n\n            focusHighlight = this._focusHighlight = this.createFocusHighlight(focusHighlightOptions);\n\n            this.appendVisual(focusHighlight);\n        }\n\n        focusHighlight.visible(show);\n    },\n\n    createGradientOverlay: function(element, options, gradientOptions) {\n        var overlay = new Path($.extend({\n            stroke: {\n                color: \"none\"\n            },\n            fill: this.createGradient(gradientOptions),\n            closed: element.options.closed\n        }, options));\n\n        overlay.segments.elements(element.segments.elements());\n\n        return overlay;\n    },\n\n    createGradient: function(options) {\n        if (this.parent) {\n            return this.parent.createGradient(options);\n        }\n    },\n\n    supportsPointInactiveOpacity: function() {\n        return true;\n    }\n});\n\nChartElement.prototype.options = { };\n\nvar BoxElement = ChartElement.extend({\n    init: function(options) {\n        ChartElement.fn.init.call(this, options);\n\n        this.options.margin = getSpacing(this.options.margin);\n        this.options.padding = getSpacing(this.options.padding);\n    },\n\n    reflow: function(targetBox) {\n        var this$1$1 = this;\n\n        var options = this.options;\n        var width = options.width;\n        var height = options.height;\n        var shrinkToFit = options.shrinkToFit;\n        var hasSetSize = width && height;\n        var margin = options.margin;\n        var padding = options.padding;\n        var borderWidth = options.border.width;\n        var box;\n\n        var reflowPaddingBox = function () {\n            this$1$1.align(targetBox, X, options.align);\n            this$1$1.align(targetBox, Y, options.vAlign);\n            this$1$1.paddingBox = box.clone().unpad(margin).unpad(borderWidth);\n        };\n\n        var contentBox = targetBox.clone();\n        if (hasSetSize) {\n            contentBox.x2 = contentBox.x1 + width;\n            contentBox.y2 = contentBox.y1 + height;\n        }\n\n        if (shrinkToFit) {\n            contentBox.unpad(margin).unpad(borderWidth).unpad(padding);\n        }\n\n        ChartElement.fn.reflow.call(this, contentBox);\n\n        if (hasSetSize) {\n            box = this.box = new Box(0, 0, width, height);\n        } else {\n            box = this.box;\n        }\n\n        if (shrinkToFit && hasSetSize) {\n            reflowPaddingBox();\n            contentBox = this.contentBox = this.paddingBox.clone().unpad(padding);\n        } else {\n            contentBox = this.contentBox = box.clone();\n            box.pad(padding).pad(borderWidth).pad(margin);\n            reflowPaddingBox();\n        }\n\n        this.translateChildren(\n            box.x1 - contentBox.x1 + margin.left + borderWidth + padding.left,\n            box.y1 - contentBox.y1 + margin.top + borderWidth + padding.top\n        );\n\n        var children = this.children;\n        for (var i = 0; i < children.length; i++) {\n            var item = children[i];\n            item.reflow(item.box);\n        }\n    },\n\n    align: function(targetBox, axis, alignment) {\n        this.box.align(targetBox, axis, alignment);\n    },\n\n    hasBox: function() {\n        var options = this.options;\n        return options.border.width || options.background;\n    },\n\n    createVisual: function() {\n        ChartElement.fn.createVisual.call(this);\n\n        var options = this.options;\n        if (options.visible && this.hasBox()) {\n            this.visual.append(Path.fromRect(\n                this.paddingBox.toRect(),\n                this.visualStyle()\n            ));\n        }\n    },\n\n    visualStyle: function() {\n        var options = this.options;\n        var border = options.border || {};\n\n        return {\n            stroke: {\n                width: border.width,\n                color: border.color,\n                opacity: valueOrDefault(border.opacity, options.opacity),\n                dashType: border.dashType\n            },\n            fill: {\n                color: options.background,\n                opacity: options.opacity\n            },\n            cursor: options.cursor\n        };\n    }\n});\n\nsetDefaultOptions(BoxElement, {\n    align: LEFT,\n    vAlign: TOP,\n    margin: {},\n    padding: {},\n    border: {\n        color: BLACK,\n        width: 0\n    },\n    background: \"\",\n    shrinkToFit: false,\n    width: 0,\n    height: 0,\n    visible: true\n});\n\nfunction addAccessibilityAttributesToVisual(visual, accessibilityOptions) {\n    if (accessibilityOptions) {\n        visual.options.className = accessibilityOptions.className;\n        visual.options.role = accessibilityOptions.role;\n        visual.options.ariaLabel = accessibilityOptions.ariaLabel;\n        visual.options.ariaRoleDescription = accessibilityOptions.ariaRoleDescription;\n        visual.options.ariaChecked = accessibilityOptions.ariaChecked;\n    }\n}\n\nvar ShapeElement = BoxElement.extend({\n    init: function(options, pointData) {\n        BoxElement.fn.init.call(this, options);\n\n        this.pointData = pointData;\n    },\n\n    getElement: function() {\n        var ref = this;\n        var options = ref.options;\n        var box = ref.paddingBox;\n        var type = options.type;\n        var rotation = options.rotation;\n        var center = box.center();\n        var halfWidth = box.width() / 2;\n        var halfHeight = box.height() / 2;\n\n        if (!options.visible || !this.hasBox()) {\n            return null;\n        }\n\n        var style = this.visualStyle();\n        var element;\n\n        if (type === CIRCLE) {\n            element = new drawing.Circle(\n                new Circle([\n                    round(box.x1 + halfWidth, COORD_PRECISION),\n                    round(box.y1 + halfHeight, COORD_PRECISION)\n                ], Math.min(halfWidth, halfHeight)),\n                style\n            );\n        } else if (type === TRIANGLE) {\n            element = Path.fromPoints([\n                [ box.x1 + halfWidth, box.y1 ],\n                [ box.x1, box.y2 ],\n                [ box.x2, box.y2 ]\n            ], style).close();\n        } else if (type === CROSS) {\n            element = new drawing.MultiPath(style);\n\n            element.moveTo(box.x1, box.y1).lineTo(box.x2, box.y2);\n            element.moveTo(box.x1, box.y2).lineTo(box.x2, box.y1);\n        } else {\n            var rect = box.toRect();\n            if (type === ROUNDED_RECT) {\n                var borderRadius = valueOrDefault(options.borderRadius, rect.width() / 5);\n                rect.setCornerRadius(borderRadius);\n            }\n\n            element = Path.fromRect(rect, style);\n        }\n\n        if (rotation) {\n            element.transform(geometryTransform()\n                .rotate(-rotation, [ center.x, center.y ])\n            );\n        }\n\n        element.options.zIndex = options.zIndex;\n\n        return element;\n    },\n\n    createElement: function() {\n        var this$1$1 = this;\n\n        var customVisual = this.options.visual;\n        var pointData = this.pointData || {};\n        var visual;\n\n        if (customVisual) {\n            visual = customVisual({\n                value: pointData.value,\n                dataItem: pointData.dataItem,\n                sender: this.getSender(),\n                series: pointData.series,\n                category: pointData.category,\n                rect: this.paddingBox.toRect(),\n                options: this.visualOptions(),\n                createVisual: function () { return this$1$1.getElement(); }\n            });\n        } else {\n            visual = this.getElement();\n        }\n\n        return visual;\n    },\n\n    visualOptions: function() {\n        var options = this.options;\n        return {\n            background: options.background,\n            border: options.border,\n            margin: options.margin,\n            padding: options.padding,\n            type: options.type,\n            size: options.width,\n            visible: options.visible\n        };\n    },\n\n    createVisual: function() {\n        this.visual = this.createElement();\n\n        addAccessibilityAttributesToVisual(this.visual, this.options.accessibilityOptions);\n    }\n});\n\nsetDefaultOptions(ShapeElement, {\n    type: CIRCLE,\n    align: CENTER,\n    vAlign: CENTER\n});\n\nvar LINEAR = \"linear\";\nvar RADIAL = \"radial\";\n\nvar GRADIENTS = {\n    glass: {\n        type: LINEAR,\n        rotation: 0,\n        stops: [ {\n            offset: 0,\n            color: WHITE,\n            opacity: 0\n        }, {\n            offset: 0.25,\n            color: WHITE,\n            opacity: 0.3\n        }, {\n            offset: 1,\n            color: WHITE,\n            opacity: 0\n        } ]\n    },\n    sharpBevel: {\n        type: RADIAL,\n        stops: [ {\n            offset: 0,\n            color: WHITE,\n            opacity: 0.55\n        }, {\n            offset: 0.65,\n            color: WHITE,\n            opacity: 0\n        }, {\n            offset: 0.95,\n            color: WHITE,\n            opacity: 0.25\n        } ]\n    },\n    roundedBevel: {\n        type: RADIAL,\n        stops: [ {\n            offset: 0.33,\n            color: WHITE,\n            opacity: 0.06\n        }, {\n            offset: 0.83,\n            color: WHITE,\n            opacity: 0.2\n        }, {\n            offset: 0.95,\n            color: WHITE,\n            opacity: 0\n        } ]\n    },\n    roundedGlass: {\n        type: RADIAL,\n        supportVML: false,\n        stops: [ {\n            offset: 0,\n            color: WHITE,\n            opacity: 0\n        }, {\n            offset: 0.5,\n            color: WHITE,\n            opacity: 0.3\n        }, {\n            offset: 0.99,\n            color: WHITE,\n            opacity: 0\n        } ]\n    },\n    sharpGlass: {\n        type: RADIAL,\n        supportVML: false,\n        stops: [ {\n            offset: 0,\n            color: WHITE,\n            opacity: 0.2\n        }, {\n            offset: 0.15,\n            color: WHITE,\n            opacity: 0.15\n        }, {\n            offset: 0.17,\n            color: WHITE,\n            opacity: 0.35\n        }, {\n            offset: 0.85,\n            color: WHITE,\n            opacity: 0.05\n        }, {\n            offset: 0.87,\n            color: WHITE,\n            opacity: 0.15\n        }, {\n            offset: 0.99,\n            color: WHITE,\n            opacity: 0\n        } ]\n    },\n    bubbleShadow: {\n        type: RADIAL,\n        center: [ 0.5, 0.5 ],\n        radius: 0.5\n    }\n};\n\nfunction boxDiff(r, s) {\n    if (r.x1 === s.x1 && r.y1 === s.y1 && r.x2 === s.x2 && r.y2 === s.y2) {\n        return s;\n    }\n\n    var a = Math.min(r.x1, s.x1);\n    var b = Math.max(r.x1, s.x1);\n    var c = Math.min(r.x2, s.x2);\n    var d = Math.max(r.x2, s.x2);\n    var e = Math.min(r.y1, s.y1);\n    var f = Math.max(r.y1, s.y1);\n    var g = Math.min(r.y2, s.y2);\n    var h = Math.max(r.y2, s.y2);\n    var boxes = [];\n\n    // X = intersection, 0-7 = possible difference areas\n    // h +-+-+-+\n    // . |5|6|7|\n    // g +-+-+-+\n    // . |3|X|4|\n    // f +-+-+-+\n    // . |0|1|2|\n    // e +-+-+-+\n    // . a b c d\n\n    // we'll always have rectangles 1, 3, 4 and 6\n    boxes[0] = new Box(b, e, c, f);\n    boxes[1] = new Box(a, f, b, g);\n    boxes[2] = new Box(c, f, d, g);\n    boxes[3] = new Box(b, g, c, h);\n\n    // decide which corners\n    if (r.x1 === a && r.y1 === e || s.x1 === a && s.y1 === e) { // corners 0 and 7\n        boxes[4] = new Box(a, e, b, f);\n        boxes[5] = new Box(c, g, d, h);\n    } else { // corners 2 and 5\n        boxes[4] = new Box(c, e, d, f);\n        boxes[5] = new Box(a, g, b, h);\n    }\n\n    return grep(boxes, function(box) {\n        return box.height() > 0 && box.width() > 0;\n    })[0];\n}\n\nvar RootElement = ChartElement.extend({\n    init: function(options) {\n        ChartElement.fn.init.call(this, options);\n\n        var rootOptions = this.options;\n        rootOptions.width = parseInt(rootOptions.width, 10);\n        rootOptions.height = parseInt(rootOptions.height, 10);\n\n        this.gradients = {};\n    },\n\n    reflow: function() {\n        var ref = this;\n        var options = ref.options;\n        var children = ref.children;\n        var currentBox = new Box(0, 0, options.width, options.height);\n\n        this.box = currentBox.unpad(options.margin);\n\n        for (var i = 0; i < children.length; i++) {\n            children[i].reflow(currentBox);\n            currentBox = boxDiff(currentBox, children[i].box) || new Box();\n        }\n    },\n\n    createVisual: function() {\n        this.visual = new Group();\n        this.createBackground();\n    },\n\n    createBackground: function() {\n        var options = this.options;\n        var border = options.border || {};\n        var box = this.box.clone().pad(options.margin).unpad(border.width);\n\n        var background = Path.fromRect(box.toRect(), {\n            stroke: {\n                color: border.width ? border.color : \"\",\n                width: border.width,\n                dashType: border.dashType\n            },\n            fill: {\n                color: options.background,\n                opacity: options.opacity\n            },\n            zIndex: -10\n        });\n\n        this.visual.append(background);\n    },\n\n    getRoot: function() {\n        return this;\n    },\n\n    createGradient: function(options) {\n        var gradients = this.gradients;\n        var hashCode = objectKey(options);\n        var gradient = GRADIENTS[options.gradient];\n        var drawingGradient;\n\n        if (gradients[hashCode]) {\n            drawingGradient = gradients[hashCode];\n        } else {\n            var gradientOptions = $.extend({}, gradient, options);\n            if (gradient.type === \"linear\") {\n                drawingGradient = new drawing.LinearGradient(gradientOptions);\n            } else {\n                if (options.innerRadius) {\n                    gradientOptions.stops = innerRadialStops(gradientOptions);\n                }\n                drawingGradient = new drawing.RadialGradient(gradientOptions);\n                drawingGradient.supportVML = gradient.supportVML !== false;\n            }\n            gradients[hashCode] = drawingGradient;\n        }\n\n        return drawingGradient;\n    },\n\n    cleanGradients: function() {\n        var gradients = this.gradients;\n        for (var hashCode in gradients) {\n            gradients[hashCode]._observers = [];//add clear observers method in drawing ObserversMixin\n        }\n    },\n\n    size: function() {\n        var options = this.options;\n        return new Box(0, 0, options.width, options.height);\n    }\n});\n\nsetDefaultOptions(RootElement, {\n    width: DEFAULT_WIDTH,\n    height: DEFAULT_HEIGHT,\n    background: WHITE,\n    border: {\n        color: BLACK,\n        width: 0\n    },\n    margin: getSpacing(5),\n    zIndex: -2\n});\n\nfunction innerRadialStops(options) {\n    var stops = options.stops;\n    var usedSpace = ((options.innerRadius / options.radius) * 100);\n    var length = stops.length;\n    var currentStops = [];\n\n    for (var i = 0; i < length; i++) {\n        var currentStop = $.extend({}, stops[i]);\n        currentStop.offset = (currentStop.offset * (100 - usedSpace) + usedSpace) / 100;\n        currentStops.push(currentStop);\n    }\n\n    return currentStops;\n}\n\nvar FloatElement = ChartElement.extend({\n    init: function(options) {\n        ChartElement.fn.init.call(this, options);\n        this._initDirection();\n    },\n\n    _initDirection: function() {\n        var options = this.options;\n        if (options.vertical) {\n            this.groupAxis = X;\n            this.elementAxis = Y;\n            this.groupSizeField = WIDTH;\n            this.elementSizeField = HEIGHT;\n            this.groupSpacing = options.spacing;\n            this.elementSpacing = options.vSpacing;\n        } else {\n            this.groupAxis = Y;\n            this.elementAxis = X;\n            this.groupSizeField = HEIGHT;\n            this.elementSizeField = WIDTH;\n            this.groupSpacing = options.vSpacing;\n            this.elementSpacing = options.spacing;\n        }\n    },\n\n    reflow: function(targetBox) {\n        this.box = targetBox.clone();\n        this.reflowChildren();\n    },\n\n    reflowChildren: function() {\n        var this$1$1 = this;\n\n        var ref = this;\n        var box = ref.box;\n        var elementAxis = ref.elementAxis;\n        var groupAxis = ref.groupAxis;\n        var elementSizeField = ref.elementSizeField;\n        var groupSizeField = ref.groupSizeField;\n        var ref$1 = this.groupOptions();\n        var groups = ref$1.groups;\n        var groupsSize = ref$1.groupsSize;\n        var maxGroupElementsSize = ref$1.maxGroupElementsSize;\n        var groupsCount = groups.length;\n        var groupsStart = box[groupAxis + 1] + this.alignStart(groupsSize, box[groupSizeField]());\n\n        if (groupsCount) {\n            var groupStart = groupsStart;\n\n            for (var groupIdx = 0; groupIdx < groupsCount; groupIdx++) {\n                var group = groups[groupIdx];\n                var groupElements = group.groupElements;\n                var elementStart = box[elementAxis + 1];\n                var groupElementsCount = groupElements.length;\n\n                for (var idx = 0; idx < groupElementsCount; idx++) {\n                    var element = groupElements[idx];\n                    var elementSize$$1 = this$1$1.elementSize(element);\n                    var groupElementStart = groupStart + this$1$1.alignStart(elementSize$$1[groupSizeField], group.groupSize);\n\n                    var elementBox = new Box();\n                    elementBox[groupAxis + 1] = groupElementStart;\n                    elementBox[groupAxis + 2] = groupElementStart + elementSize$$1[groupSizeField];\n                    elementBox[elementAxis + 1] = elementStart;\n                    elementBox[elementAxis + 2] = elementStart + elementSize$$1[elementSizeField];\n\n                    element.reflow(elementBox);\n\n                    elementStart += elementSize$$1[elementSizeField] + this$1$1.elementSpacing;\n                }\n                groupStart += group.groupSize + this$1$1.groupSpacing;\n            }\n            box[groupAxis + 1] = groupsStart;\n            box[groupAxis + 2] = groupsStart + groupsSize;\n            box[elementAxis + 2] = box[elementAxis + 1] + maxGroupElementsSize;\n        }\n    },\n\n    alignStart: function(size, maxSize) {\n        var start = 0;\n        var align = this.options.align;\n        if (align === RIGHT || align === BOTTOM) {\n            start = maxSize - size;\n        } else if (align === CENTER) {\n            start = (maxSize - size) / 2;\n        }\n        return start;\n    },\n\n    groupOptions: function() {\n        var this$1$1 = this;\n\n        var ref = this;\n        var box = ref.box;\n        var children = ref.children;\n        var elementSizeField = ref.elementSizeField;\n        var groupSizeField = ref.groupSizeField;\n        var elementSpacing = ref.elementSpacing;\n        var groupSpacing = ref.groupSpacing;\n        var maxSize = round(box[elementSizeField]());\n        var childrenCount = children.length;\n        var groups = [];\n\n        var groupSize = 0;\n        var groupElementsSize = 0;\n        var groupsSize = 0;\n        var maxGroupElementsSize = 0;\n        var groupElements = [];\n\n        for (var idx = 0; idx < childrenCount; idx++) {\n            var element = children[idx];\n            if (!element.box) {\n                element.reflow(box);\n            }\n\n            var elementSize$$1 = this$1$1.elementSize(element);\n            if (this$1$1.options.wrap && round(groupElementsSize + elementSpacing + elementSize$$1[elementSizeField]) > maxSize) {\n                groups.push({\n                    groupElements: groupElements,\n                    groupSize: groupSize,\n                    groupElementsSize: groupElementsSize\n                });\n                maxGroupElementsSize = Math.max(maxGroupElementsSize, groupElementsSize);\n                groupsSize += groupSpacing + groupSize;\n                groupSize = 0;\n                groupElementsSize = 0;\n                groupElements = [];\n            }\n            groupSize = Math.max(groupSize, elementSize$$1[groupSizeField]);\n            if (groupElementsSize > 0) {\n                groupElementsSize += elementSpacing;\n            }\n            groupElementsSize += elementSize$$1[elementSizeField];\n            groupElements.push(element);\n        }\n\n        groups.push({\n            groupElements: groupElements,\n            groupSize: groupSize,\n            groupElementsSize: groupElementsSize\n        });\n        maxGroupElementsSize = Math.max(maxGroupElementsSize, groupElementsSize);\n        groupsSize += groupSize;\n\n        return {\n            groups: groups,\n            groupsSize: groupsSize,\n            maxGroupElementsSize: maxGroupElementsSize\n        };\n    },\n\n    elementSize: function(element) {\n        return {\n            width: element.box.width(),\n            height: element.box.height()\n        };\n    },\n\n    createVisual: function() {}\n});\n\nsetDefaultOptions(FloatElement, {\n    vertical: true,\n    wrap: true,\n    vSpacing: 0,\n    spacing: 0\n});\n\nvar DrawingText = drawing.Text;\n\nvar Text = ChartElement.extend({\n    init: function(content, options) {\n        ChartElement.fn.init.call(this, options);\n\n        this.content = content;\n\n        // Calculate size\n        this.reflow(new Box());\n    },\n\n    reflow: function(targetBox) {\n        var options = this.options;\n        var size = options.size = util.measureText(this.content, { font: options.font });\n\n        this.baseline = size.baseline;\n\n        this.box = new Box(targetBox.x1, targetBox.y1,\n            targetBox.x1 + size.width, targetBox.y1 + size.height);\n    },\n\n    createVisual: function() {\n        var ref = this.options;\n        var font = ref.font;\n        var color = ref.color;\n        var opacity = ref.opacity;\n        var cursor = ref.cursor;\n        var stroke = ref.stroke;\n        var paintOrder = ref.paintOrder;\n\n        this.visual = new DrawingText(this.content, this.box.toRect().topLeft(), {\n            font: font,\n            fill: { color: color, opacity: opacity },\n            cursor: cursor,\n            stroke: stroke,\n            paintOrder: paintOrder\n        });\n    }\n});\n\nsetDefaultOptions(Text, {\n    font: DEFAULT_FONT,\n    color: BLACK\n});\n\nfunction rectToBox(rect) {\n    var origin = rect.origin;\n    var bottomRight = rect.bottomRight();\n\n    return new Box(origin.x, origin.y, bottomRight.x, bottomRight.y);\n}\n\nvar ROWS_SPLIT_REGEX = /\\n/m;\n\nvar TextBox = BoxElement.extend({\n    init: function(content, options, data) {\n        BoxElement.fn.init.call(this, options);\n        this.content = content;\n        this.data = data;\n\n        this._initContainer();\n        if (this.options._autoReflow !== false) {\n            this.reflow(new Box());\n        }\n    },\n\n    _initContainer: function() {\n        var options = this.options;\n        var rows = String(this.content).split(ROWS_SPLIT_REGEX);\n        var floatElement = new FloatElement({ vertical: true, align: options.align, wrap: false });\n        var textOptions = deepExtend({ }, options, { opacity: 1, animation: null });\n\n        this.container = floatElement;\n        this.append(floatElement);\n\n        for (var rowIdx = 0; rowIdx < rows.length; rowIdx++) {\n            var text = new Text(rows[rowIdx].trim(), textOptions);\n            floatElement.append(text);\n        }\n    },\n\n    reflow: function(targetBox) {\n        var options = this.options;\n        var visualFn = options.visual;\n        this.container.options.align = options.align;\n\n        if (visualFn && !this._boxReflow) {\n            var visualBox = targetBox;\n            if (!visualBox.hasSize()) {\n                this._boxReflow = true;\n                this.reflow(visualBox);\n                this._boxReflow = false;\n                visualBox = this.box;\n            }\n            var visual = this.visual = visualFn(this.visualContext(visualBox));\n\n            if (visual) {\n                visualBox = rectToBox(visual.clippedBBox() || new Rect());\n\n                visual.options.zIndex = options.zIndex;\n            }\n\n            this.box = this.contentBox = this.paddingBox = visualBox;\n        } else {\n            BoxElement.fn.reflow.call(this, targetBox);\n\n            if (options.rotation) {\n                var margin = getSpacing(options.margin);\n                var box = this.box.unpad(margin);\n\n                this.targetBox = targetBox;\n                this.normalBox = box.clone();\n\n                box = this.rotate();\n                box.translate(margin.left - margin.right, margin.top - margin.bottom);\n\n                this.rotatedBox = box.clone();\n\n                box.pad(margin);\n            }\n        }\n    },\n\n    createVisual: function() {\n        var options = this.options;\n\n        this.visual = new Group({\n            transform: this.rotationTransform(),\n            zIndex: options.zIndex,\n            noclip: options.noclip\n        });\n\n        if (this.hasBox()) {\n            var box = Path.fromRect(this.paddingBox.toRect(), this.visualStyle());\n            this.visual.append(box);\n        }\n    },\n\n    renderVisual: function() {\n        if (!this.options.visible) {\n            return;\n        }\n\n        if (this.options.visual) {\n            var visual = this.visual;\n            if (visual && !defined(visual.options.noclip)) {\n                visual.options.noclip = this.options.noclip;\n            }\n            this.addVisual();\n            this.createAnimation();\n        } else {\n            BoxElement.fn.renderVisual.call(this);\n        }\n    },\n\n    visualContext: function(targetBox) {\n        var this$1$1 = this;\n\n        var context = {\n            text: this.content,\n            rect: targetBox.toRect(),\n            sender: this.getSender(),\n            options: this.options,\n            createVisual: function () {\n                this$1$1._boxReflow = true;\n                this$1$1.reflow(targetBox);\n                this$1$1._boxReflow = false;\n                return this$1$1.getDefaultVisual();\n            }\n        };\n        if (this.data) {\n            $.extend(context, this.data);\n        }\n\n        return context;\n    },\n\n    getDefaultVisual: function() {\n        this.createVisual();\n        this.renderChildren();\n        var visual = this.visual;\n        delete this.visual;\n        return visual;\n    },\n\n    rotate: function() {\n        var options = this.options;\n        this.box.rotate(options.rotation);\n        this.align(this.targetBox, X, options.align);\n        this.align(this.targetBox, Y, options.vAlign);\n        return this.box;\n    },\n\n    rotationTransform: function() {\n        var rotation = this.options.rotation;\n        if (!rotation) {\n            return null;\n        }\n\n        var ref = this.normalBox.center();\n        var cx = ref.x;\n        var cy = ref.y;\n        var boxCenter = this.rotatedBox.center();\n\n        return geometryTransform()\n            .translate(boxCenter.x - cx, boxCenter.y - cy)\n            .rotate(rotation, [ cx, cy ]);\n    }\n});\n\nvar Title = ChartElement.extend({\n    init: function(options) {\n        ChartElement.fn.init.call(this, options);\n\n        this._textBox = new TextBox(this.options.text, $.extend({}, this.options, {\n            vAlign: this.options.position\n        }));\n\n        this.append(this._textBox);\n    },\n\n    reflow: function(targetBox) {\n        ChartElement.fn.reflow.call(this, targetBox);\n        this.box.snapTo(targetBox, X);\n    }\n});\n\nTitle.buildTitle = function(options, defaultOptions) {\n    var titleOptions = options;\n\n    if (typeof options === \"string\") {\n        titleOptions = { text: options };\n    }\n\n    titleOptions = $.extend({ visible: true }, defaultOptions, titleOptions);\n\n    var title;\n    if (titleOptions && titleOptions.visible && titleOptions.text) {\n        title = new Title(titleOptions);\n    }\n\n    return title;\n};\n\nTitle.orderTitles = function(titles) {\n    var items = [].concat(titles);\n    var top = items.filter(function (item) { return item && item.options.position !== BOTTOM; });\n    var bottom = items.filter(function (item) { return item && item.options.position === BOTTOM; });\n\n    collapseVerticalMargins(top);\n    collapseVerticalMargins(bottom);\n\n    bottom.reverse();\n    return top.concat(bottom);\n};\n\nfunction collapseVerticalMargins(items) {\n    for (var i = 1; i < items.length; i++) {\n        var box = items[i]._textBox;\n        var prevBox = items[i - 1]._textBox;\n        prevBox.options.margin = $.extend(getSpacing(prevBox.options.margin), { bottom: 0 });\n        box.options.margin = $.extend(getSpacing(box.options.margin), { top: 0 });\n    }\n}\n\nsetDefaultOptions(Title, {\n    color: BLACK,\n    position: TOP,\n    align: CENTER,\n    margin: getSpacing(5),\n    padding: getSpacing(5)\n});\n\nvar AxisLabel = TextBox.extend({\n    init: function(value, text, index, dataItem, options) {\n        TextBox.fn.init.call(this, text, options);\n\n        this.text = text;\n        this.value = value;\n        this.index = index;\n        this.dataItem = dataItem;\n        this.reflow(new Box());\n    },\n\n    visualContext: function(targetBox) {\n        var context = TextBox.fn.visualContext.call(this, targetBox);\n\n        context.value = this.value;\n        context.dataItem = this.dataItem;\n        context.format = this.options.format;\n        context.culture = this.options.culture;\n\n        return context;\n    },\n\n    click: function(widget, e) {\n\n        widget.trigger(AXIS_LABEL_CLICK, {\n            element: eventElement(e),\n            value: this.value,\n            text: this.text,\n            index: this.index,\n            dataItem: this.dataItem,\n            axis: this.parent.options\n        });\n    },\n\n    rotate: function() {\n        if (this.options.alignRotation !== CENTER) {\n            var box = this.normalBox.toRect();\n            var transform = this.rotationTransform();\n\n            this.box = rectToBox(box.bbox(transform.matrix()));\n        } else {\n            TextBox.fn.rotate.call(this);\n        }\n\n        return this.box;\n    },\n\n    rotationTransform: function() {\n        var options = this.options;\n        var rotation = options.rotation;\n        if (!rotation) {\n            return null;\n        }\n\n        if (options.alignRotation === CENTER) {\n            return TextBox.fn.rotationTransform.call(this);\n        }\n\n        var rotationMatrix = geometryTransform().rotate(rotation).matrix();\n        var box = this.normalBox.toRect();\n        var rect = this.targetBox.toRect();\n\n        var rotationOrigin = options.rotationOrigin || TOP;\n        var alignAxis = rotationOrigin === TOP || rotationOrigin === BOTTOM ? X : Y;\n        var distanceAxis = rotationOrigin === TOP || rotationOrigin === BOTTOM ? Y : X;\n        var axisAnchor = rotationOrigin === TOP || rotationOrigin === LEFT ? rect.origin : rect.bottomRight();\n\n        var topLeft = box.topLeft().transformCopy(rotationMatrix);\n        var topRight = box.topRight().transformCopy(rotationMatrix);\n        var bottomRight = box.bottomRight().transformCopy(rotationMatrix);\n        var bottomLeft = box.bottomLeft().transformCopy(rotationMatrix);\n        var rotatedBox = Rect.fromPoints(topLeft, topRight, bottomRight, bottomLeft);\n\n        var translate = {};\n        translate[distanceAxis] = rect.origin[distanceAxis] - rotatedBox.origin[distanceAxis];\n\n        var distanceLeft = Math.abs(topLeft[distanceAxis] + translate[distanceAxis] - axisAnchor[distanceAxis]);\n        var distanceRight = Math.abs(topRight[distanceAxis] + translate[distanceAxis] - axisAnchor[distanceAxis]);\n\n        var alignStart, alignEnd;\n\n        if (round(distanceLeft, DEFAULT_PRECISION) === round(distanceRight, DEFAULT_PRECISION)) {\n            alignStart = topLeft;\n            alignEnd = topRight;\n        } else if (distanceRight < distanceLeft) {\n            alignStart = topRight;\n            alignEnd = bottomRight;\n        } else {\n            alignStart = topLeft;\n            alignEnd = bottomLeft;\n        }\n\n        var alignCenter = alignStart[alignAxis] + (alignEnd[alignAxis] - alignStart[alignAxis]) / 2;\n        translate[alignAxis] = rect.center()[alignAxis] - alignCenter;\n\n        return geometryTransform()\n            .translate(translate.x, translate.y)\n            .rotate(rotation);\n    }\n});\n\nsetDefaultOptions(AxisLabel, {\n    _autoReflow: false\n});\n\nvar DEFAULT_ICON_SIZE = 7;\nvar DEFAULT_LABEL_COLOR = \"#fff\";\n\nvar Note = BoxElement.extend({\n    init: function(fields, options, chartService) {\n        BoxElement.fn.init.call(this, options);\n\n        this.fields = fields;\n        this.chartService = chartService;\n\n        this.render();\n    },\n\n    hide: function() {\n        this.options.visible = false;\n    },\n\n    show: function() {\n        this.options.visible = true;\n    },\n\n    render: function() {\n        var this$1$1 = this;\n\n        var options = this.options;\n\n        if (options.visible) {\n            var label = options.label;\n            var icon = options.icon;\n            var box = new Box();\n            var childAlias = function () { return this$1$1; };\n            var size = icon.size;\n            var text = this.fields.text;\n            var width, height;\n\n            if (defined(label) && label.visible) {\n                var noteTemplate = getTemplate(label);\n                if (noteTemplate) {\n                    text = noteTemplate(this.fields);\n                } else if (label.format) {\n                    text = this.chartService.format.auto(label.format, text);\n                }\n\n                if (!label.color) {\n                    label.color = label.position === INSIDE ? DEFAULT_LABEL_COLOR : icon.background;\n                }\n\n                this.label = new TextBox(text, deepExtend({}, label));\n                this.label.aliasFor = childAlias;\n\n                if (label.position === INSIDE && !defined(size)) {\n                    if (icon.type === CIRCLE) {\n                        size = Math.max(this.label.box.width(), this.label.box.height());\n                    } else {\n                        width = this.label.box.width();\n                        height = this.label.box.height();\n                    }\n                    box.wrap(this.label.box);\n                }\n            }\n\n            icon.width = width || size || DEFAULT_ICON_SIZE;\n            icon.height = height || size || DEFAULT_ICON_SIZE;\n\n            var marker = new ShapeElement(deepExtend({}, icon));\n            marker.aliasFor = childAlias;\n\n            this.marker = marker;\n            this.append(marker);\n\n            if (this.label) {\n                this.append(this.label);\n            }\n\n            marker.reflow(new Box());\n            this.wrapperBox = box.wrap(marker.box);\n        }\n    },\n\n    reflow: function(targetBox) {\n        var ref = this;\n        var options = ref.options;\n        var label = ref.label;\n        var marker = ref.marker;\n        var wrapperBox = ref.wrapperBox;\n        var center = targetBox.center();\n        var length = options.line.length;\n        var position = options.position;\n\n        // TODO: Review\n        if (options.visible) {\n            var lineStart, box, contentBox;\n\n            if (inArray(position, [ LEFT, RIGHT ])) {\n                if (position === LEFT) {\n                    contentBox = wrapperBox.alignTo(targetBox, position).translate(-length, targetBox.center().y - wrapperBox.center().y);\n\n                    if (options.line.visible) {\n                        lineStart = [ targetBox.x1, center.y ];\n                        this.linePoints = [\n                            lineStart,\n                            [ contentBox.x2, center.y ]\n                        ];\n                        box = contentBox.clone().wrapPoint(lineStart);\n                    }\n                } else {\n                    contentBox = wrapperBox.alignTo(targetBox, position).translate(length, targetBox.center().y - wrapperBox.center().y);\n\n                    if (options.line.visible) {\n                        lineStart = [ targetBox.x2, center.y ];\n                        this.linePoints = [\n                            lineStart,\n                            [ contentBox.x1, center.y ]\n                        ];\n                        box = contentBox.clone().wrapPoint(lineStart);\n                    }\n                }\n            } else {\n                if (position === BOTTOM) {\n                    contentBox = wrapperBox.alignTo(targetBox, position).translate(targetBox.center().x - wrapperBox.center().x, length);\n\n                    if (options.line.visible) {\n                        lineStart = [ center.x, targetBox.y2 ];\n                        this.linePoints = [\n                            lineStart,\n                            [ center.x, contentBox.y1 ]\n                        ];\n                        box = contentBox.clone().wrapPoint(lineStart);\n                    }\n                } else {\n                    contentBox = wrapperBox.alignTo(targetBox, position).translate(targetBox.center().x - wrapperBox.center().x, -length);\n\n                    if (options.line.visible) {\n                        lineStart = [ center.x, targetBox.y1 ];\n                        this.linePoints = [\n                            lineStart,\n                            [ center.x, contentBox.y2 ]\n                        ];\n                        box = contentBox.clone().wrapPoint(lineStart);\n                    }\n                }\n            }\n\n            if (marker) {\n                marker.reflow(contentBox);\n            }\n\n            if (label) {\n                label.reflow(contentBox);\n                if (marker) {\n                    if (options.label.position === OUTSIDE) {\n                        label.box.alignTo(marker.box, position);\n                    }\n                    label.reflow(label.box);\n                }\n            }\n\n            this.contentBox = contentBox;\n            this.targetBox = targetBox;\n            this.box = box || contentBox;\n        }\n    },\n\n    createVisual: function() {\n        BoxElement.fn.createVisual.call(this);\n        this.visual.options.noclip = this.options.noclip;\n\n        if (this.options.visible) {\n            this.createLine();\n        }\n    },\n\n    renderVisual: function() {\n        var this$1$1 = this;\n\n        var options = this.options;\n        var customVisual = options.visual;\n        if (options.visible && customVisual) {\n            this.visual = customVisual($.extend(this.fields, {\n                sender: this.getSender(),\n                rect: this.targetBox.toRect(),\n                options: {\n                    background: options.background,\n                    border: options.background,\n                    icon: options.icon,\n                    label: options.label,\n                    line: options.line,\n                    position: options.position,\n                    visible: options.visible\n                },\n                createVisual: function () {\n                    this$1$1.createVisual();\n                    this$1$1.renderChildren();\n                    var defaultVisual = this$1$1.visual;\n                    delete this$1$1.visual;\n                    return defaultVisual;\n                }\n            }));\n            this.addVisual();\n        } else {\n            BoxElement.fn.renderVisual.call(this);\n        }\n    },\n\n    createLine: function() {\n        var options = this.options.line;\n\n        if (this.linePoints) {\n            var path = Path.fromPoints(this.linePoints, {\n                stroke: {\n                    color: options.color,\n                    width: options.width,\n                    dashType: options.dashType\n                }\n            });\n\n            alignPathToPixel(path);\n            this.visual.append(path);\n        }\n    },\n\n    click: function(widget, e) {\n        var args = this.eventArgs(e);\n\n        if (!widget.trigger(NOTE_CLICK, args)) {\n            e.preventDefault();\n        }\n    },\n\n    over: function(widget, e) {\n        var args = this.eventArgs(e);\n\n        if (!widget.trigger(NOTE_HOVER, args)) {\n            e.preventDefault();\n        }\n    },\n\n    out: function(widget, e) {\n        var args = this.eventArgs(e);\n\n        widget.trigger(NOTE_LEAVE, args);\n    },\n\n    eventArgs: function(e) {\n        var options = this.options;\n\n        return $.extend(this.fields, {\n            element: eventElement(e),\n            text: defined(options.label) ? options.label.text : \"\",\n            visual: this.visual\n        });\n    }\n});\n\nsetDefaultOptions(Note, {\n    icon: {\n        visible: true,\n        type: CIRCLE\n    },\n    label: {\n        position: INSIDE,\n        visible: true,\n        align: CENTER,\n        vAlign: CENTER\n    },\n    line: {\n        visible: true\n    },\n    visible: true,\n    position: TOP,\n    zIndex: 2\n});\n\nvar defaultImplementation = {\n    format: function (format, value) { return value; },\n\n    toString: function (value) { return value; },\n\n    parseDate: function (value) { return new Date(value); },\n\n    firstDay: function () { return 0; }\n};\n\nvar current$1 = defaultImplementation;\n\nvar IntlService = Class.extend({\n\n});\n\nIntlService.register = function(userImplementation) {\n    current$1 = userImplementation;\n};\n\nif (Object.defineProperties) {\n    Object.defineProperties(IntlService, {\n        implementation: {\n            get: function() {\n                return current$1;\n            }\n        }\n    });\n}\n\n// eslint-disable-next-line no-useless-escape\nvar FORMAT_REPLACE_REGEX = /\\{(\\d+)(:[^\\}]+)?\\}/g;\n\nvar FormatService = Class.extend({\n    init: function(intlService) {\n        this._intlService = intlService;\n    },\n\n    auto: function(formatString) {\n        var values = [], len = arguments.length - 1;\n        while ( len-- > 0 ) values[ len ] = arguments[ len + 1 ];\n\n        var intl = this.intl;\n\n        if (isString(formatString) && formatString.match(FORMAT_REGEX)) {\n            return intl.format.apply(intl, [ formatString ].concat( values ));\n        }\n\n        return intl.toString(values[0], formatString);\n    },\n\n    localeAuto: function(formatString, values, locale) {\n        var intl = this.intl;\n        var result;\n\n        if (isString(formatString) && formatString.match(FORMAT_REGEX)) {\n            result = formatString.replace(FORMAT_REPLACE_REGEX, function(match, index, placeholderFormat) {\n                var value = values[parseInt(index, 10)];\n\n                return intl.toString(value, placeholderFormat ? placeholderFormat.substring(1) : \"\", locale);\n            });\n        } else {\n            result = intl.toString(values[0], formatString, locale);\n        }\n\n        return result;\n    }\n});\n\nif (Object.defineProperties) {\n    Object.defineProperties(FormatService.fn, {\n        intl: {\n            get: function() {\n                return this._intlService || IntlService.implementation;\n            },\n            set: function(value) {\n                this._intlService = value;\n            }\n        }\n    });\n}\n\nvar ChartService = Class.extend({\n    init: function(chart, context) {\n        if (context === void 0) { context = {}; }\n\n        this._intlService = context.intlService;\n        this.sender = context.sender || chart;\n        this.format = new FormatService(context.intlService);\n        this.chart = chart;\n        this.rtl = Boolean(context.rtl);\n    },\n\n    notify: function(name, args) {\n        if (this.chart) {\n            this.chart.trigger(name, args);\n        }\n    },\n\n    isPannable: function(axis) {\n        var pannable = ((this.chart || {}).options || {}).pannable;\n        return pannable && pannable.lock !== axis;\n    }\n});\n\nif (Object.defineProperties) {\n    Object.defineProperties(ChartService.fn, {\n        intl: {\n            get: function() {\n                return this._intlService || IntlService.implementation;\n            },\n            set: function(value) {\n                this._intlService = value;\n                this.format.intl = value;\n            }\n        }\n    });\n}\n\nvar current$2;\n\nvar DomEventsBuilder = Class.extend({\n\n});\n\nDomEventsBuilder.register = function(userImplementation) {\n    current$2 = userImplementation;\n};\n\nDomEventsBuilder.create = function(element, events) {\n    if (current$2) {\n        return current$2.create(element, events);\n    }\n};\n\nvar services = {\n\tChartService: ChartService,\n\tDomEventsBuilder: DomEventsBuilder,\n\tFormatService: FormatService,\n\tIntlService: IntlService,\n\tTemplateService: TemplateService\n};\n\nfunction createAxisTick(options, tickOptions) {\n    var tickX = options.tickX;\n    var tickY = options.tickY;\n    var position = options.position;\n\n    var tick = new Path({\n        stroke: {\n            width: tickOptions.width,\n            color: tickOptions.color\n        }\n    });\n\n    if (options.vertical) {\n        tick.moveTo(tickX, position)\n            .lineTo(tickX + tickOptions.size, position);\n    } else {\n        tick.moveTo(position, tickY)\n            .lineTo(position, tickY + tickOptions.size);\n    }\n\n    alignPathToPixel(tick);\n\n    return tick;\n}\n\nfunction createAxisGridLine(options, gridLine) {\n    var lineStart = options.lineStart;\n    var lineEnd = options.lineEnd;\n    var position = options.position;\n\n    var line = new Path({\n        stroke: {\n            width: gridLine.width,\n            color: gridLine.color,\n            dashType: gridLine.dashType\n        }\n    });\n\n    if (options.vertical) {\n        line.moveTo(lineStart, position)\n            .lineTo(lineEnd, position);\n    } else {\n        line.moveTo(position, lineStart)\n            .lineTo(position, lineEnd);\n    }\n\n    alignPathToPixel(line);\n\n    return line;\n}\n\nvar Axis = ChartElement.extend({\n    init: function(options, chartService) {\n        if (chartService === void 0) { chartService = new ChartService(); }\n\n        ChartElement.fn.init.call(this, options);\n\n        this.chartService = chartService;\n\n        if (!this.options.visible) {\n            this.options = deepExtend({}, this.options, {\n                labels: {\n                    visible: false\n                },\n                line: {\n                    visible: false\n                },\n                margin: 0,\n                majorTickSize: 0,\n                minorTickSize: 0\n            });\n        }\n\n        this.options.minorTicks = deepExtend({}, {\n            color: this.options.line.color,\n            width: this.options.line.width,\n            visible: this.options.minorTickType !== NONE\n        }, this.options.minorTicks, {\n            size: this.options.minorTickSize,\n            align: this.options.minorTickType\n        });\n\n        this.options.majorTicks = deepExtend({}, {\n            color: this.options.line.color,\n            width: this.options.line.width,\n            visible: this.options.majorTickType !== NONE\n        }, this.options.majorTicks, {\n            size: this.options.majorTickSize,\n            align: this.options.majorTickType\n        });\n\n        this.initFields();\n\n        if (!this.options._deferLabels) {\n            this.createLabels();\n        }\n\n        this.createTitle();\n        this.createNotes();\n    },\n\n    initFields: function() {\n    },\n\n    labelsRange: function() {\n        return {\n            min: this.options.labels.skip,\n            max: this.labelsCount()\n        };\n    },\n\n    normalizeLabelRotation: function(labelOptions) {\n        var rotation = labelOptions.rotation;\n\n        if (isObject(rotation)) {\n            labelOptions.alignRotation = rotation.align;\n            labelOptions.rotation = rotation.angle;\n        }\n    },\n\n    createLabels: function() {\n        var this$1$1 = this;\n\n        var options = this.options;\n        var align = options.vertical ? RIGHT : CENTER;\n        var labelOptions = deepExtend({ }, options.labels, {\n            align: align,\n            zIndex: options.zIndex\n        });\n        var step = Math.max(1, labelOptions.step);\n\n        this.clearLabels();\n\n        if (labelOptions.visible) {\n            this.normalizeLabelRotation(labelOptions);\n            if (labelOptions.rotation === \"auto\") {\n                labelOptions.rotation = 0;\n                options.autoRotateLabels = true;\n            }\n\n            var range = this.labelsRange();\n            for (var idx = range.min; idx < range.max; idx += step) {\n                var labelContext = { index: idx, count: range.max };\n                var label = this$1$1.createAxisLabel(idx, labelOptions, labelContext);\n                if (label) {\n                    this$1$1.append(label);\n                    this$1$1.labels.push(label);\n                }\n            }\n        }\n    },\n\n    clearLabels: function() {\n        this.children = grep(this.children, function (child) { return !(child instanceof AxisLabel); });\n        this.labels = [];\n    },\n\n    clearTitle: function() {\n        var this$1$1 = this;\n\n        if (this.title) {\n            this.children = grep(this.children, function (child) { return child !== this$1$1.title; });\n            this.title = undefined;\n        }\n    },\n\n    clear: function() {\n        this.clearLabels();\n        this.clearTitle();\n    },\n\n    lineBox: function() {\n        var ref = this;\n        var options = ref.options;\n        var box = ref.box;\n        var vertical = options.vertical;\n        var mirror = options.labels.mirror;\n        var axisX = mirror ? box.x1 : box.x2;\n        var axisY = mirror ? box.y2 : box.y1;\n        var lineWidth = options.line.width || 0;\n\n        return vertical ?\n            new Box(axisX, box.y1, axisX, box.y2 - lineWidth) :\n            new Box(box.x1, axisY, box.x2 - lineWidth, axisY);\n    },\n\n    createTitle: function() {\n        var options = this.options;\n        var titleOptions = deepExtend({\n            rotation: options.vertical ? -90 : 0,\n            text: \"\",\n            zIndex: 1,\n            visualSize: true\n        }, options.title);\n\n        if (titleOptions.visible && titleOptions.text) {\n            var title = new TextBox(titleOptions.text, titleOptions);\n            this.append(title);\n            this.title = title;\n        }\n    },\n\n    createNotes: function() {\n        var this$1$1 = this;\n\n        var options = this.options;\n        var notes = options.notes;\n        var items = notes.data || [];\n\n        this.notes = [];\n\n        for (var i = 0; i < items.length; i++) {\n            var item = deepExtend({}, notes, items[i]);\n            item.value = this$1$1.parseNoteValue(item.value);\n\n            var note = new Note({\n                value: item.value,\n                text: item.label.text,\n                dataItem: item\n            }, item, this$1$1.chartService);\n\n            if (note.options.visible) {\n                if (defined(note.options.position)) {\n                    if (options.vertical && !inArray(note.options.position, [ LEFT, RIGHT ])) {\n                        note.options.position = options.reverse ? LEFT : RIGHT;\n                    } else if (!options.vertical && !inArray(note.options.position, [ TOP, BOTTOM ])) {\n                        note.options.position = options.reverse ? BOTTOM : TOP;\n                    }\n                } else {\n                    if (options.vertical) {\n                        note.options.position = options.reverse ? LEFT : RIGHT;\n                    } else {\n                        note.options.position = options.reverse ? BOTTOM : TOP;\n                    }\n                }\n                this$1$1.append(note);\n                this$1$1.notes.push(note);\n            }\n        }\n    },\n\n    parseNoteValue: function(value) {\n        return value;\n    },\n\n    renderVisual: function() {\n        ChartElement.fn.renderVisual.call(this);\n\n        this.createPlotBands();\n    },\n\n    createVisual: function() {\n        ChartElement.fn.createVisual.call(this);\n\n        this.createBackground();\n        this.createLine();\n    },\n\n    gridLinesVisual: function() {\n        var gridLines = this._gridLines;\n        if (!gridLines) {\n            gridLines = this._gridLines = new Group({\n                zIndex: -2\n            });\n            this.appendVisual(this._gridLines);\n        }\n\n        return gridLines;\n    },\n\n    createTicks: function(lineGroup) {\n        var options = this.options;\n        var lineBox = this.lineBox();\n        var mirror = options.labels.mirror;\n        var majorUnit = options.majorTicks.visible ? options.majorUnit : 0;\n        var tickLineOptions = {\n            // TODO\n            // _alignLines: options._alignLines,\n            vertical: options.vertical\n        };\n\n        function render(tickPositions, tickOptions, skipUnit) {\n            var count = tickPositions.length;\n            var step = Math.max(1, tickOptions.step);\n\n            if (tickOptions.visible) {\n                for (var i = tickOptions.skip; i < count; i += step) {\n                    if (defined(skipUnit) && (i % skipUnit === 0)) {\n                        continue;\n                    }\n\n                    tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;\n                    tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;\n                    tickLineOptions.position = tickPositions[i];\n\n                    lineGroup.append(createAxisTick(tickLineOptions, tickOptions));\n                }\n            }\n        }\n\n        render(this.getMajorTickPositions(), options.majorTicks);\n        render(this.getMinorTickPositions(), options.minorTicks, majorUnit / options.minorUnit);\n    },\n\n    createLine: function() {\n        var options = this.options;\n        var line = options.line;\n        var lineBox = this.lineBox();\n\n        if (line.width > 0 && line.visible) {\n            var path = new Path({\n                stroke: {\n                    width: line.width,\n                    color: line.color,\n                    dashType: line.dashType\n                }\n\n                /* TODO\n                zIndex: line.zIndex,\n                */\n            });\n\n            path.moveTo(lineBox.x1, lineBox.y1)\n                .lineTo(lineBox.x2, lineBox.y2);\n\n            if (options._alignLines) {\n                alignPathToPixel(path);\n            }\n\n            var group = this._lineGroup = new Group();\n            group.append(path);\n\n            this.visual.append(group);\n            this.createTicks(group);\n        }\n    },\n\n    getActualTickSize: function() {\n        var options = this.options;\n        var tickSize = 0;\n\n        if (options.majorTicks.visible && options.minorTicks.visible) {\n            tickSize = Math.max(options.majorTicks.size, options.minorTicks.size);\n        } else if (options.majorTicks.visible) {\n            tickSize = options.majorTicks.size;\n        } else if (options.minorTicks.visible) {\n            tickSize = options.minorTicks.size;\n        }\n\n        return tickSize;\n    },\n\n    createBackground: function() {\n        var ref = this;\n        var options = ref.options;\n        var box = ref.box;\n        var background = options.background;\n\n        if (background) {\n            this._backgroundPath = Path.fromRect(box.toRect(), {\n                fill: {\n                    color: background\n                },\n                stroke: null\n            });\n\n            this.visual.append(this._backgroundPath);\n        }\n    },\n\n    createPlotBands: function() {\n        var this$1$1 = this;\n\n        var options = this.options;\n        var plotBands = options.plotBands || [];\n        var vertical = options.vertical;\n        var plotArea = this.plotArea;\n\n        if (plotBands.length === 0) {\n            return;\n        }\n\n        var group = this._plotbandGroup = new Group({\n            zIndex: -1\n        });\n\n        var altAxis = grep(this.pane.axes, function (axis) { return axis.options.vertical !== this$1$1.options.vertical; })[0];\n\n        for (var idx = 0; idx < plotBands.length; idx++) {\n            var item = plotBands[idx];\n            var slotX = (void 0), slotY = (void 0);\n            var labelOptions = item.label;\n            var label = (void 0);\n\n            if (vertical) {\n                slotX = (altAxis || plotArea.axisX).lineBox();\n                slotY = this$1$1.getSlot(item.from, item.to, true);\n            } else {\n                slotX = this$1$1.getSlot(item.from, item.to, true);\n                slotY = (altAxis || plotArea.axisY).lineBox();\n            }\n\n            if (labelOptions) {\n                labelOptions.vAlign = labelOptions.position || LEFT;\n                label = this$1$1.createPlotBandLabel(\n                    labelOptions,\n                    item,\n                    new Box(\n                        slotX.x1,\n                        slotY.y1,\n                        slotX.x2,\n                        slotY.y2\n                    )\n\n                );\n            }\n\n            if (slotX.width() !== 0 && slotY.height() !== 0) {\n                var bandRect = new Rect(\n                    [ slotX.x1, slotY.y1 ],\n                    [ slotX.width(), slotY.height() ]\n                );\n\n                var path = Path.fromRect(bandRect, {\n                    fill: {\n                        color: item.color,\n                        opacity: item.opacity\n                    },\n                    stroke: null\n                });\n\n                group.append(path);\n                if (label) {\n                    group.append(label);\n                }\n            }\n        }\n\n        this.appendVisual(group);\n    },\n\n    createPlotBandLabel: function(label, item, box) {\n\n        if (label.visible === false) {\n            return null;\n        }\n\n        var text = label.text;\n        var textbox;\n\n        if (defined(label) && label.visible) {\n            var labelTemplate = getTemplate(label);\n            if (labelTemplate) {\n                text = labelTemplate({ text: text, item: item });\n            } else if (label.format) {\n                text = this.chartService.format.auto(label.format, text);\n            }\n\n            if (!label.color) {\n                label.color = this.options.labels.color;\n            }\n        }\n\n        textbox = new TextBox(text, label);\n        textbox.reflow(box);\n        textbox.renderVisual();\n\n        return textbox.visual;\n    },\n\n    createGridLines: function(altAxis) {\n        var options = this.options;\n        var minorGridLines = options.minorGridLines;\n        var majorGridLines = options.majorGridLines;\n        var minorUnit = options.minorUnit;\n        var vertical = options.vertical;\n        var axisLineVisible = altAxis.options.line.visible;\n        var majorUnit = majorGridLines.visible ? options.majorUnit : 0;\n        var lineBox = altAxis.lineBox();\n        var linePos = lineBox[vertical ? \"y1\" : \"x1\"];\n        var lineOptions = {\n            lineStart: lineBox[vertical ? \"x1\" : \"y1\"],\n            lineEnd: lineBox[vertical ? \"x2\" : \"y2\"],\n            vertical: vertical\n        };\n        var majorTicks = [];\n\n        var container = this.gridLinesVisual();\n\n        function render(tickPositions, gridLine, skipUnit) {\n            var count = tickPositions.length;\n            var step = Math.max(1, gridLine.step);\n\n            if (gridLine.visible) {\n                for (var i = gridLine.skip; i < count; i += step) {\n                    var pos = round(tickPositions[i]);\n                    if (!inArray(pos, majorTicks)) {\n                        if (i % skipUnit !== 0 && (!axisLineVisible || linePos !== pos)) {\n                            lineOptions.position = pos;\n                            container.append(createAxisGridLine(lineOptions, gridLine));\n\n                            majorTicks.push(pos);\n                        }\n                    }\n                }\n            }\n        }\n\n        render(this.getMajorTickPositions(), majorGridLines);\n        render(this.getMinorTickPositions(), minorGridLines, majorUnit / minorUnit);\n\n        return container.children;\n    },\n\n    reflow: function(box) {\n        var ref = this;\n        var options = ref.options;\n        var labels = ref.labels;\n        var title = ref.title;\n        var vertical = options.vertical;\n        var count = labels.length;\n        var sizeFn = vertical ? WIDTH : HEIGHT;\n        var titleSize = title ? title.box[sizeFn]() : 0;\n        var space = this.getActualTickSize() + options.margin + titleSize;\n        var rootBox = (this.getRoot() || {}).box || box;\n        var boxSize = rootBox[sizeFn]();\n        var maxLabelSize = 0;\n\n        for (var i = 0; i < count; i++) {\n            var labelSize = labels[i].box[sizeFn]();\n            if (labelSize + space <= boxSize) {\n                maxLabelSize = Math.max(maxLabelSize, labelSize);\n            }\n        }\n\n        if (vertical) {\n            this.box = new Box(\n                box.x1, box.y1,\n                box.x1 + maxLabelSize + space, box.y2\n            );\n        } else {\n            this.box = new Box(\n                box.x1, box.y1,\n                box.x2, box.y1 + maxLabelSize + space\n            );\n        }\n\n        this.arrangeTitle();\n        this.arrangeLabels();\n        this.arrangeNotes();\n    },\n\n    getLabelsTickPositions: function() {\n        return this.getMajorTickPositions();\n    },\n\n    labelTickIndex: function(label) {\n        return label.index;\n    },\n\n    arrangeLabels: function() {\n        var this$1$1 = this;\n\n        var ref = this;\n        var options = ref.options;\n        var labels = ref.labels;\n        var labelsBetweenTicks = this.labelsBetweenTicks();\n        var vertical = options.vertical;\n        var mirror = options.labels.mirror;\n        var tickPositions = this.getLabelsTickPositions();\n\n        for (var idx = 0; idx < labels.length; idx++) {\n            var label = labels[idx];\n            var tickIx = this$1$1.labelTickIndex(label);\n            var labelSize = vertical ? label.box.height() : label.box.width();\n            var firstTickPosition = tickPositions[tickIx];\n            var nextTickPosition = tickPositions[tickIx + 1];\n            var positionStart = (void 0), positionEnd = (void 0);\n\n            if (vertical) {\n                if (labelsBetweenTicks) {\n                    var middle = firstTickPosition + (nextTickPosition - firstTickPosition) / 2;\n                    positionStart = middle - (labelSize / 2);\n                } else {\n                    positionStart = firstTickPosition - (labelSize / 2);\n                }\n\n                positionEnd = positionStart;\n            } else {\n                if (labelsBetweenTicks) {\n                    positionStart = firstTickPosition;\n                    positionEnd = nextTickPosition;\n                } else {\n                    positionStart = firstTickPosition - (labelSize / 2);\n                    positionEnd = positionStart + labelSize;\n                }\n            }\n\n            this$1$1.positionLabel(label, mirror, positionStart, positionEnd);\n        }\n    },\n\n    positionLabel: function(label, mirror, positionStart, positionEnd) {\n        if (positionEnd === void 0) { positionEnd = positionStart; }\n\n        var options = this.options;\n        var vertical = options.vertical;\n        var lineBox = this.lineBox();\n        var labelOffset = this.getActualTickSize() + options.margin;\n        var labelBox;\n\n        if (vertical) {\n            var labelX = lineBox.x2;\n\n            if (mirror) {\n                labelX += labelOffset;\n                label.options.rotationOrigin = LEFT;\n            } else {\n                labelX -= labelOffset + label.box.width();\n                label.options.rotationOrigin = RIGHT;\n            }\n\n            labelBox = label.box.move(labelX, positionStart);\n        } else {\n            var labelY = lineBox.y1;\n\n            if (mirror) {\n                labelY -= labelOffset + label.box.height();\n                label.options.rotationOrigin = BOTTOM;\n            } else {\n                labelY += labelOffset;\n                label.options.rotationOrigin = TOP;\n            }\n\n            labelBox = new Box(\n                positionStart, labelY,\n                positionEnd, labelY + label.box.height()\n            );\n        }\n\n        label.reflow(labelBox);\n    },\n\n    autoRotateLabelAngle: function(labelBox, slotWidth) {\n        if (labelBox.width() < slotWidth) {\n            return 0;\n        }\n\n        if (labelBox.height() > slotWidth) {\n            return -90;\n        }\n\n        return -45;\n    },\n\n    autoRotateLabels: function() {\n        var this$1$1 = this;\n\n        if (!this.options.autoRotateLabels || this.options.vertical) {\n            return false;\n        }\n\n        var tickPositions = this.getMajorTickPositions();\n        var labels = this.labels;\n        var limit = Math.min(labels.length, tickPositions.length - 1);\n        var angle = 0;\n\n        for (var idx = 0; idx < limit; idx++) {\n            var width = Math.abs(tickPositions[idx + 1] - tickPositions[idx]);\n            var labelBox = labels[idx].box;\n            var labelAngle = this$1$1.autoRotateLabelAngle(labelBox, width);\n\n            if (labelAngle !== 0) {\n                angle = labelAngle;\n            }\n\n            if (angle === -90) {\n                break;\n            }\n        }\n\n        if (angle !== 0) {\n            for (var idx$1 = 0; idx$1 < labels.length; idx$1++) {\n                labels[idx$1].options.rotation = angle;\n                labels[idx$1].reflow(new Box());\n            }\n\n            return true;\n        }\n    },\n\n    arrangeTitle: function() {\n        var ref = this;\n        var options = ref.options;\n        var title = ref.title;\n        var mirror = options.labels.mirror;\n        var vertical = options.vertical;\n\n        if (title) {\n            if (vertical) {\n                title.options.align = mirror ? RIGHT : LEFT;\n                title.options.vAlign = title.options.position;\n            } else {\n                title.options.align = title.options.position;\n                title.options.vAlign = mirror ? TOP : BOTTOM;\n            }\n\n            title.reflow(this.box);\n        }\n    },\n\n    arrangeNotes: function() {\n        var this$1$1 = this;\n\n        for (var idx = 0; idx < this.notes.length; idx++) {\n            var item = this$1$1.notes[idx];\n            var value = item.options.value;\n            var slot = (void 0);\n\n            if (defined(value)) {\n                if (this$1$1.shouldRenderNote(value)) {\n                    item.show();\n                } else {\n                    item.hide();\n                }\n\n                slot = this$1$1.noteSlot(value);\n            } else {\n                item.hide();\n            }\n\n            item.reflow(slot || this$1$1.lineBox());\n        }\n    },\n\n    noteSlot: function(value) {\n        return this.getSlot(value);\n    },\n\n    alignTo: function(secondAxis) {\n        var lineBox = secondAxis.lineBox();\n        var vertical = this.options.vertical;\n        var pos = vertical ? Y : X;\n\n        this.box.snapTo(lineBox, pos);\n        if (vertical) {\n            this.box.shrink(0, this.lineBox().height() - lineBox.height());\n        } else {\n            this.box.shrink(this.lineBox().width() - lineBox.width(), 0);\n        }\n        this.box[pos + 1] -= this.lineBox()[pos + 1] - lineBox[pos + 1];\n        this.box[pos + 2] -= this.lineBox()[pos + 2] - lineBox[pos + 2];\n    },\n\n    axisLabelText: function(value, options, context) {\n        var this$1$1 = this;\n\n        var text;\n        var tmpl = getTemplate(options);\n        var defaultText = function () {\n            if (!options.format) {\n                return value;\n            }\n\n            return this$1$1.chartService.format.localeAuto(\n                options.format, [ value ], options.culture\n            );\n        };\n\n        if (tmpl) {\n            var templateContext = $.extend({}, context, {\n                get text() { return defaultText(); },\n                value: value,\n                format: options.format,\n                culture: options.culture\n            });\n\n            text = tmpl(templateContext);\n        } else {\n            text = defaultText();\n        }\n\n        return text;\n    },\n\n    slot: function(from , to, limit) {\n        var slot = this.getSlot(from, to, limit);\n        if (slot) {\n            return slot.toRect();\n        }\n    },\n\n    contentBox: function() {\n        var box = this.box.clone();\n        var labels = this.labels;\n        if (labels.length) {\n            var axis = this.options.vertical ? Y : X;\n            if (this.chartService.isPannable(axis)) {\n                var offset = this.maxLabelOffset();\n                box[axis + 1] -= offset.start;\n                box[axis + 2] += offset.end;\n            } else {\n                if (labels[0].options.visible) {\n                    box.wrap(labels[0].box);\n                }\n                var lastLabel = labels[labels.length - 1];\n                if (lastLabel.options.visible) {\n                    box.wrap(lastLabel.box);\n                }\n            }\n        }\n\n        return box;\n    },\n\n    maxLabelOffset: function() {\n        var this$1$1 = this;\n\n        var ref = this.options;\n        var vertical = ref.vertical;\n        var reverse = ref.reverse;\n        var labelsBetweenTicks = this.labelsBetweenTicks();\n        var tickPositions = this.getLabelsTickPositions();\n        var offsetField = vertical ? Y : X;\n        var labels = this.labels;\n        var startPosition = reverse ? 1 : 0;\n        var endPosition = reverse ? 0 : 1;\n        var maxStartOffset = 0;\n        var maxEndOffset = 0;\n\n        for (var idx = 0; idx < labels.length; idx++) {\n            var label = labels[idx];\n            var tickIx = this$1$1.labelTickIndex(label);\n            var startTick = (void 0), endTick = (void 0);\n\n            if (labelsBetweenTicks) {\n                startTick = tickPositions[tickIx + startPosition];\n                endTick = tickPositions[tickIx + endPosition];\n            } else {\n                startTick = endTick = tickPositions[tickIx];\n            }\n\n            maxStartOffset = Math.max(maxStartOffset, startTick - label.box[offsetField + 1]);\n            maxEndOffset = Math.max(maxEndOffset, label.box[offsetField + 2] - endTick);\n        }\n\n        return {\n            start: maxStartOffset,\n            end: maxEndOffset\n        };\n    },\n\n    limitRange: function(from, to, min, max, offset) {\n        var options = this.options;\n\n        if ((from < min && offset < 0 && (!defined(options.min) || options.min <= min)) || (max < to && offset > 0 && (!defined(options.max) || max <= options.max))) {\n            return null;\n        }\n\n        if ((to < min && offset > 0) || (max < from && offset < 0)) {\n            return {\n                min: from,\n                max: to\n            };\n        }\n\n        var rangeSize = to - from;\n        var minValue = from;\n        var maxValue = to;\n\n        if (from < min && offset < 0) {\n            minValue = limitValue(from, min, max);\n            maxValue = limitValue(from + rangeSize, min + rangeSize, max);\n        } else if (to > max && offset > 0) {\n            maxValue = limitValue(to, min, max);\n            minValue = limitValue(to - rangeSize, min, max - rangeSize);\n        }\n\n        return {\n            min: minValue,\n            max: maxValue\n        };\n    },\n\n    valueRange: function() {\n        return {\n            min: this.seriesMin,\n            max: this.seriesMax\n        };\n    },\n\n    lineDir: function() {\n        /*\n         * Axis line direction:\n         *   * Vertical: up.\n         *   * Horizontal: right.\n         */\n\n        var ref = this.options;\n        var vertical = ref.vertical;\n        var reverse = ref.reverse;\n        return (vertical ? -1 : 1) * (reverse ? -1 : 1);\n    },\n\n    lineInfo: function() {\n        var ref = this.options;\n        var vertical = ref.vertical;\n        var lineBox = this.lineBox();\n        var lineSize = vertical ? lineBox.height() : lineBox.width();\n        var axis = vertical ? Y : X;\n        var axisDir = this.lineDir();\n        var startEdge = axisDir === 1 ? 1 : 2;\n        var axisOrigin = axis + startEdge.toString();\n        var lineStart = lineBox[axisOrigin];\n\n        return {\n            axis: axis,\n            axisOrigin: axisOrigin,\n            axisDir: axisDir,\n            lineBox: lineBox,\n            lineSize: lineSize,\n            lineStart: lineStart\n        };\n    },\n\n    pointOffset: function(point) {\n        var ref = this.lineInfo();\n        var axis = ref.axis;\n        var axisDir = ref.axisDir;\n        var axisOrigin = ref.axisOrigin;\n        var lineBox = ref.lineBox;\n        var lineSize = ref.lineSize;\n        var relative = axisDir > 0 ? point[axis] - lineBox[axisOrigin] : lineBox[axisOrigin] - point[axis];\n        var offset = relative / lineSize;\n\n        return offset;\n    },\n\n    scaleToDelta: function(rawScale, range) {\n        // Scale >= 1 would result in axis range of 0.\n        // Scale <= -1 would reverse the scale direction.\n        var MAX_SCALE = 0.999;\n        var scale = limitValue(rawScale, -MAX_SCALE, MAX_SCALE);\n\n        var delta;\n        if (scale > 0) {\n            delta = range * Math.min(1, scale);\n        } else {\n            delta = range - (range / (1 + scale));\n        }\n\n        return delta;\n    },\n\n    labelsBetweenTicks: function() {\n        return !this.options.justified;\n    },\n\n    prepareUserOptions: function() {\n    }\n});\n\nsetDefaultOptions(Axis, {\n    labels: {\n        visible: true,\n        rotation: 0,\n        mirror: false,\n        step: 1,\n        skip: 0\n    },\n    line: {\n        width: 1,\n        color: BLACK,\n        visible: true\n    },\n    title: {\n        visible: true,\n        position: CENTER\n    },\n    majorTicks: {\n        align: OUTSIDE,\n        size: 4,\n        skip: 0,\n        step: 1\n    },\n    minorTicks: {\n        align: OUTSIDE,\n        size: 3,\n        skip: 0,\n        step: 1\n    },\n    axisCrossingValue: 0,\n    majorTickType: OUTSIDE,\n    minorTickType: NONE,\n    majorGridLines: {\n        skip: 0,\n        step: 1\n    },\n    minorGridLines: {\n        visible: false,\n        width: 1,\n        color: BLACK,\n        skip: 0,\n        step: 1\n    },\n    // TODO: Move to line or labels options\n    margin: 5,\n    visible: true,\n    reverse: false,\n    justified: true,\n    notes: {\n        label: {\n            text: \"\"\n        }\n    },\n\n    _alignLines: true,\n    _deferLabels: false\n});\n\nvar MILLISECONDS = \"milliseconds\";\nvar SECONDS = \"seconds\";\nvar MINUTES = \"minutes\";\nvar HOURS = \"hours\";\nvar DAYS = \"days\";\nvar WEEKS = \"weeks\";\nvar MONTHS = \"months\";\nvar YEARS = \"years\";\n\nvar TIME_PER_MILLISECOND = 1;\nvar TIME_PER_SECOND = 1000;\nvar TIME_PER_MINUTE = 60 * TIME_PER_SECOND;\nvar TIME_PER_HOUR = 60 * TIME_PER_MINUTE;\nvar TIME_PER_DAY = 24 * TIME_PER_HOUR;\nvar TIME_PER_WEEK = 7 * TIME_PER_DAY;\nvar TIME_PER_MONTH = 31 * TIME_PER_DAY;\nvar TIME_PER_YEAR = 365 * TIME_PER_DAY;\nvar TIME_PER_UNIT = {\n    \"years\": TIME_PER_YEAR,\n    \"months\": TIME_PER_MONTH,\n    \"weeks\": TIME_PER_WEEK,\n    \"days\": TIME_PER_DAY,\n    \"hours\": TIME_PER_HOUR,\n    \"minutes\": TIME_PER_MINUTE,\n    \"seconds\": TIME_PER_SECOND,\n    \"milliseconds\": TIME_PER_MILLISECOND\n};\n\nfunction absoluteDateDiff(a, b) {\n    var diff = a.getTime() - b;\n    var offsetDiff = a.getTimezoneOffset() - b.getTimezoneOffset();\n\n    return diff - (offsetDiff * TIME_PER_MINUTE);\n}\n\nfunction addTicks(date, ticks) {\n    return new Date(date.getTime() + ticks);\n}\n\nfunction toDate(value) {\n    var result;\n\n    if (value instanceof Date) {\n        result = value;\n    } else if (value) {\n        result = new Date(value);\n    }\n\n    return result;\n}\n\nfunction startOfWeek(date, weekStartDay) {\n    if (weekStartDay === void 0) { weekStartDay = 0; }\n\n    var daysToSubtract = 0;\n    var day = date.getDay();\n\n    if (!isNaN(day)) {\n        while (day !== weekStartDay) {\n            if (day === 0) {\n                day = 6;\n            } else {\n                day--;\n            }\n\n            daysToSubtract++;\n        }\n    }\n\n    return addTicks(date, -daysToSubtract * TIME_PER_DAY);\n}\n\nfunction adjustDST(date, hours) {\n    if (hours === 0 && date.getHours() === 23) {\n        date.setHours(date.getHours() + 2);\n        return true;\n    }\n\n    return false;\n}\n\nfunction addHours(date, hours) {\n    var roundedDate = new Date(date);\n\n    roundedDate.setMinutes(0, 0, 0);\n\n    var tzDiff = (date.getTimezoneOffset() - roundedDate.getTimezoneOffset()) * TIME_PER_MINUTE;\n\n    return addTicks(roundedDate, tzDiff + hours * TIME_PER_HOUR);\n}\n\nfunction addDuration(dateValue, value, unit, weekStartDay) {\n    var result = dateValue;\n\n    if (dateValue) {\n        var date = toDate(dateValue);\n        var hours = date.getHours();\n\n        if (unit === YEARS) {\n            result = new Date(date.getFullYear() + value, 0, 1);\n            adjustDST(result, 0);\n        } else if (unit === MONTHS) {\n            result = new Date(date.getFullYear(), date.getMonth() + value, 1);\n            adjustDST(result, hours);\n        } else if (unit === WEEKS) {\n            result = addDuration(startOfWeek(date, weekStartDay), value * 7, DAYS);\n            adjustDST(result, hours);\n        } else if (unit === DAYS) {\n            result = new Date(date.getFullYear(), date.getMonth(), date.getDate() + value);\n            adjustDST(result, hours);\n        } else if (unit === HOURS) {\n            result = addHours(date, value);\n        } else if (unit === MINUTES) {\n            result = addTicks(date, value * TIME_PER_MINUTE);\n\n            if (result.getSeconds() > 0) {\n                result.setSeconds(0);\n            }\n        } else if (unit === SECONDS) {\n            result = addTicks(date, value * TIME_PER_SECOND);\n        } else if (unit === MILLISECONDS) {\n            result = addTicks(date, value);\n        }\n\n        if (unit !== MILLISECONDS && result.getMilliseconds() > 0) {\n            result.setMilliseconds(0);\n        }\n    }\n\n    return result;\n}\n\nfunction floorDate(date, unit, weekStartDay) {\n    return addDuration(toDate(date), 0, unit, weekStartDay);\n}\n\nfunction ceilDate(dateValue, unit, weekStartDay) {\n    var date = toDate(dateValue);\n\n    if (date && floorDate(date, unit, weekStartDay).getTime() === date.getTime()) {\n        return date;\n    }\n\n    return addDuration(date, 1, unit, weekStartDay);\n}\n\nfunction dateComparer(a, b) {\n    if (a && b) {\n        return a.getTime() - b.getTime();\n    }\n\n    return -1;\n}\n\nfunction dateDiff(a, b) {\n    return a.getTime() - b;\n}\n\nfunction toTime(value) {\n    if (isArray(value)) {\n        var result = [];\n        for (var idx = 0; idx < value.length; idx++) {\n            result.push(toTime(value[idx]));\n        }\n\n        return result;\n    } else if (value) {\n        return toDate(value).getTime();\n    }\n}\n\nfunction dateEquals(a, b) {\n    if (a && b) {\n        return toTime(a) === toTime(b);\n    }\n\n    return a === b;\n}\n\nfunction timeIndex(date, start, baseUnit) {\n    return absoluteDateDiff(date, start) / TIME_PER_UNIT[baseUnit];\n}\n\nfunction dateIndex(value, start, baseUnit, baseUnitStep) {\n    var date = toDate(value);\n    var startDate = toDate(start);\n    var index;\n\n    if (baseUnit === MONTHS) {\n        index = (date.getMonth() - startDate.getMonth() + (date.getFullYear() - startDate.getFullYear()) * 12) +\n            timeIndex(date, new Date(date.getFullYear(), date.getMonth()), DAYS) / new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();\n    } else if (baseUnit === YEARS) {\n        index = date.getFullYear() - startDate.getFullYear() + dateIndex(date, new Date(date.getFullYear(), 0), MONTHS, 1) / 12;\n    } else if (baseUnit === DAYS || baseUnit === WEEKS) {\n        index = timeIndex(date, startDate, baseUnit);\n    } else {\n        index = dateDiff(date, start) / TIME_PER_UNIT[baseUnit];\n    }\n\n    return index / baseUnitStep;\n}\n\nfunction duration(a, b, unit) {\n    var diff;\n\n    if (unit === YEARS) {\n        diff = b.getFullYear() - a.getFullYear();\n    } else if (unit === MONTHS) {\n        diff = duration(a, b, YEARS) * 12 + b.getMonth() - a.getMonth();\n    } else if (unit === DAYS) {\n        diff = Math.floor(dateDiff(b, a) / TIME_PER_DAY);\n    } else {\n        diff = Math.floor(dateDiff(b, a) / TIME_PER_UNIT[unit]);\n    }\n\n    return diff;\n}\n\nfunction lteDateIndex(date, sortedDates) {\n    var low = 0;\n    var high = sortedDates.length - 1;\n    var index;\n\n    while (low <= high) {\n        index = Math.floor((low + high) / 2);\n        var currentDate = sortedDates[index];\n\n        if (currentDate < date) {\n            low = index + 1;\n            continue;\n        }\n\n        if (currentDate > date) {\n            high = index - 1;\n            continue;\n        }\n\n        while (dateEquals(sortedDates[index - 1], date)) {\n            index--;\n        }\n\n        return index;\n    }\n\n    if (sortedDates[index] <= date) {\n        return index;\n    }\n\n    return index - 1;\n}\n\nfunction parseDate(intlService, date) {\n    var result;\n    if (isString(date)) {\n        result = intlService.parseDate(date) || toDate(date);\n    } else {\n        result = toDate(date);\n    }\n    return result;\n}\n\nfunction parseDates(intlService, dates) {\n    if (isArray(dates)) {\n        var result = [];\n        for (var idx = 0; idx < dates.length; idx++) {\n            result.push(parseDate(intlService, dates[idx]));\n        }\n\n        return result;\n    }\n\n    return parseDate(intlService, dates);\n}\n\nfunction firstDay(options, intlService) {\n    if (isNumber(options.weekStartDay)) {\n        return options.weekStartDay;\n    }\n\n    if (intlService && intlService.firstDay) {\n        return intlService.firstDay();\n    }\n\n    return 0;\n}\n\nvar MIN_CATEGORY_POINTS_RANGE = 0.01;\nvar MIN_CATEGORY_RANGE = 0.1;\n\nfunction indexOf(value, arr) {\n    if (value instanceof Date) {\n        var length = arr.length;\n        for (var idx = 0; idx < length; idx++) {\n            if (dateEquals(arr[idx], value)) {\n                return idx;\n            }\n        }\n\n        return -1;\n    }\n\n    return arr.indexOf(value);\n}\n\nvar CategoryAxis = Axis.extend({\n    initFields: function() {\n        this._ticks = {};\n    },\n\n    categoriesHash: function() {\n        return \"\";\n    },\n\n    clone: function() {\n        var copy = new CategoryAxis($.extend({}, this.options, {\n            categories: this.options.srcCategories\n        }), this.chartService);\n        copy.createLabels();\n\n        return copy;\n    },\n\n    initUserOptions: function(options) {\n        var categories = options.categories || [];\n        var definedMin = defined(options.min);\n        var definedMax = defined(options.max);\n        options.srcCategories = options.categories = categories;\n\n        if ((definedMin || definedMax) && categories.length) {\n            var min = definedMin ? Math.floor(options.min) : 0;\n            var max;\n\n            if (definedMax) {\n                max = options.justified ? Math.floor(options.max) + 1 : Math.ceil(options.max);\n            } else {\n                max = categories.length;\n            }\n\n            options.categories = options.categories.slice(min, max);\n        }\n\n        return options;\n    },\n\n    rangeIndices: function() {\n        var options = this.options;\n        var length = options.categories.length || 1;\n        var min = isNumber(options.min) ? options.min % 1 : 0;\n        var max;\n\n        if (isNumber(options.max) && options.max % 1 !== 0 && options.max < this.totalRange().max) {\n            max = length - (1 - options.max % 1);\n        } else {\n            max = length - (options.justified ? 1 : 0);\n        }\n\n        return {\n            min: min,\n            max: max\n        };\n    },\n\n    range: function() {\n        var options = this.options;\n        var min = isNumber(options.min) ? options.min : 0;\n        var max = isNumber(options.max) ? options.max : this.totalRange().max;\n\n        return {\n            min: min,\n            max: max\n        };\n    },\n\n    roundedRange: function() {\n        return this.range();\n    },\n\n    totalRange: function() {\n        var options = this.options;\n        return { min: 0, max: Math.max(this._seriesMax || 0, options.srcCategories.length) - (options.justified ? 1 : 0) };\n    },\n\n    scaleOptions: function() {\n        var ref = this.rangeIndices();\n        var min = ref.min;\n        var max = ref.max;\n        var lineBox = this.lineBox();\n        var size = this.options.vertical ? lineBox.height() : lineBox.width();\n        var scale = size / ((max - min) || 1);\n\n        return {\n            scale: scale * (this.options.reverse ? -1 : 1),\n            box: lineBox,\n            min: min,\n            max: max\n        };\n    },\n\n    arrangeLabels: function() {\n        Axis.fn.arrangeLabels.call(this);\n        this.hideOutOfRangeLabels();\n    },\n\n    hideOutOfRangeLabels: function() {\n        var ref = this;\n        var box = ref.box;\n        var labels = ref.labels;\n\n        if (labels.length > 0) {\n            var valueAxis = this.options.vertical ? Y : X;\n            var start = box[valueAxis + 1];\n            var end = box[valueAxis + 2];\n            var firstLabel = labels[0];\n            var lastLabel = last(labels);\n\n            if (firstLabel.box[valueAxis + 1] > end || firstLabel.box[valueAxis + 2] < start) {\n                firstLabel.options.visible = false;\n            }\n            if (lastLabel.box[valueAxis + 1] > end || lastLabel.box[valueAxis + 2] < start) {\n                lastLabel.options.visible = false;\n            }\n        }\n    },\n\n    getMajorTickPositions: function() {\n        return this.getTicks().majorTicks;\n    },\n\n    getMinorTickPositions: function() {\n        return this.getTicks().minorTicks;\n    },\n\n    getLabelsTickPositions: function() {\n        return this.getTicks().labelTicks;\n    },\n\n    tickIndices: function(stepSize) {\n        var ref = this.rangeIndices();\n        var min = ref.min;\n        var max = ref.max;\n        var limit = Math.ceil(max);\n        var current = Math.floor(min);\n        var indices = [];\n\n        while (current <= limit) {\n            indices.push(current);\n            current += stepSize;\n        }\n\n        return indices;\n    },\n\n    getTickPositions: function(stepSize) {\n        var ref = this.options;\n        var vertical = ref.vertical;\n        var reverse = ref.reverse;\n        var ref$1 = this.scaleOptions();\n        var scale = ref$1.scale;\n        var box = ref$1.box;\n        var min = ref$1.min;\n        var pos = box[(vertical ? Y : X) + (reverse ? 2 : 1)];\n        var indices = this.tickIndices(stepSize);\n        var positions = [];\n\n        for (var idx = 0; idx < indices.length; idx++) {\n            positions.push(pos + round(scale * (indices[idx] - min), COORD_PRECISION));\n        }\n\n        return positions;\n    },\n\n    getTicks: function() {\n        var options = this.options;\n        var cache = this._ticks;\n        var range = this.rangeIndices();\n        var lineBox = this.lineBox();\n        var hash = lineBox.getHash() + range.min + \",\" + range.max + options.reverse + options.justified;\n\n        if (cache._hash !== hash) {\n            var hasMinor = options.minorTicks.visible || options.minorGridLines.visible;\n            cache._hash = hash;\n            cache.labelTicks = this.getTickPositions(1);\n            cache.majorTicks = this.filterOutOfRangePositions(cache.labelTicks, lineBox);\n            cache.minorTicks = hasMinor ? this.filterOutOfRangePositions(this.getTickPositions(0.5), lineBox) : [];\n        }\n\n        return cache;\n    },\n\n    filterOutOfRangePositions: function(positions, lineBox) {\n        if (!positions.length) {\n            return positions;\n        }\n\n        var axis = this.options.vertical ? Y : X;\n        var inRange = function (position) { return lineBox[axis + 1] <= position && position <= lineBox[axis + 2]; };\n\n        var end = positions.length - 1;\n        var startIndex = 0;\n        while (!inRange(positions[startIndex]) && startIndex <= end) {\n            startIndex++;\n        }\n\n        var endIndex = end;\n\n        while (!inRange(positions[endIndex]) && endIndex >= 0) {\n            endIndex--;\n        }\n\n        return positions.slice(startIndex, endIndex + 1);\n    },\n\n    lineInfo: function() {\n        var ref = this.options;\n        var vertical = ref.vertical;\n        var reverse = ref.reverse;\n        var lineBox = this.lineBox();\n        var lineSize = vertical ? lineBox.height() : lineBox.width();\n        var axis = vertical ? Y : X;\n        var axisDir = reverse ? -1 : 1;\n        var startEdge = axisDir === 1 ? 1 : 2;\n        var axisOrigin = axis + startEdge.toString();\n        var lineStart = lineBox[axisOrigin];\n\n        return {\n            axis: axis,\n            axisOrigin: axisOrigin,\n            axisDir: axisDir,\n            lineBox: lineBox,\n            lineSize: lineSize,\n            lineStart: lineStart\n        };\n    },\n\n    lineDir: function() {\n        /*\n         *  Category axis line direction:\n         *    * Vertical: down.\n         *    * Horizontal: right.\n         */\n\n        var ref = this.options;\n        var reverse = ref.reverse;\n        return reverse ? -1 : 1;\n    },\n\n    getSlot: function(from, to, limit) {\n        var options = this.options;\n        var reverse = options.reverse;\n        var justified = options.justified;\n        var ref = this.scaleOptions();\n        var scale = ref.scale;\n        var box = ref.box;\n        var min = ref.min;\n        var ref$1 = this.lineInfo();\n        var valueAxis = ref$1.axis;\n        var lineStart = ref$1.lineStart;\n\n        var slotBox = box.clone();\n        var singleSlot = !defined(to);\n\n        var start = valueOrDefault(from, 0);\n        var end = valueOrDefault(to, start);\n        end = Math.max(end - 1, start);\n\n        // Fixes transient bug caused by iOS 6.0 JIT\n        // (one can never be too sure)\n        end = Math.max(start, end);\n\n        var p1 = lineStart + (start - min) * scale;\n        var p2 = lineStart + (end + 1 - min) * scale;\n\n        if (singleSlot && justified) {\n            p2 = p1;\n        }\n\n        if (limit) {\n            p1 = limitValue(p1, box[valueAxis + 1], box[valueAxis + 2]);\n            p2 = limitValue(p2, box[valueAxis + 1], box[valueAxis + 2]);\n        }\n\n        slotBox[valueAxis + 1] = reverse ? p2 : p1;\n        slotBox[valueAxis + 2] = reverse ? p1 : p2;\n\n        return slotBox;\n    },\n\n    limitSlot: function(slot) {\n        var vertical = this.options.vertical;\n        var valueAxis = vertical ? Y : X;\n        var lineBox = this.lineBox();\n        var limittedSlot = slot.clone();\n\n        limittedSlot[valueAxis + 1] = limitValue(slot[valueAxis + 1], lineBox[valueAxis + 1], lineBox[valueAxis + 2]);\n        limittedSlot[valueAxis + 2] = limitValue(slot[valueAxis + 2], lineBox[valueAxis + 1], lineBox[valueAxis + 2]);\n\n        return limittedSlot;\n    },\n\n    slot: function(from, to, limit) {\n        var min = Math.floor(this.options.min || 0);\n        var start = from;\n        var end = to;\n\n        if (typeof start === \"string\") {\n            start = this.categoryIndex(start);\n        } else if (isNumber(start)) {\n            start -= min;\n        }\n\n        if (typeof end === \"string\") {\n            end = this.categoryIndex(end);\n        } else if (isNumber(end)) {\n            end -= min;\n        }\n\n        return Axis.fn.slot.call(this, start, end, limit);\n    },\n\n    pointCategoryIndex: function(point) {\n        var ref = this.options;\n        var reverse = ref.reverse;\n        var justified = ref.justified;\n        var vertical = ref.vertical;\n        var valueAxis = vertical ? Y : X;\n        var ref$1 = this.scaleOptions();\n        var scale = ref$1.scale;\n        var box = ref$1.box;\n        var min = ref$1.min;\n        var max = ref$1.max;\n        var startValue = reverse ? max : min;\n        var lineStart = box[valueAxis + 1];\n        var lineEnd = box[valueAxis + 2];\n        var pos = point[valueAxis];\n\n        if (pos < lineStart || pos > lineEnd) {\n            return null;\n        }\n\n        var value = startValue + (pos - lineStart) / scale;\n        var diff = value % 1;\n\n        if (justified) {\n            value = Math.round(value);\n        } else if (diff === 0 && value > 0) {\n            value--;\n        }\n\n        return Math.floor(value);\n    },\n\n    getCategory: function(point) {\n        var index = this.pointCategoryIndex(point);\n\n        if (index === null) {\n            return null;\n        }\n\n        return this.options.categories[index];\n    },\n\n    categoryIndex: function(value) {\n        return this.totalIndex(value) - Math.floor(this.options.min || 0);\n    },\n\n    categoryAt: function(index, total) {\n        var options = this.options;\n\n        return (total ? options.srcCategories : options.categories)[index];\n    },\n\n    categoriesCount: function() {\n        return (this.options.categories || []).length;\n    },\n\n    translateRange: function(delta) {\n        var options = this.options;\n        var lineBox = this.lineBox();\n        var size = options.vertical ? lineBox.height() : lineBox.width();\n        var range = options.categories.length;\n        var scale = size / range;\n        var offset = round(delta / scale, DEFAULT_PRECISION);\n\n        return {\n            min: offset,\n            max: range + offset\n        };\n    },\n\n    scaleRange: function(scale, cursor) {\n        var position = Math.abs(this.pointOffset(cursor));\n        var rangeIndices = this.limitedRangeIndices();\n        var range = rangeIndices.max - rangeIndices.min;\n        var delta = this.scaleToDelta(scale, range);\n        var minDelta = position * delta;\n        var maxDelta = (1 - position) * delta;\n        var min = rangeIndices.min + minDelta;\n        var max = rangeIndices.max - maxDelta;\n\n        if (max - min < MIN_CATEGORY_RANGE) {\n            max = min + MIN_CATEGORY_RANGE;\n        }\n\n        return {\n            min: min,\n            max: max\n        };\n    },\n\n    zoomRange: function(scale, cursor) {\n        var ref = this.totalRange();\n        var totalMin = ref.min;\n        var totalMax = ref.max;\n        var range = this.scaleRange(scale, cursor);\n\n        return {\n            min: limitValue(range.min, totalMin, totalMax),\n            max: limitValue(range.max, totalMin, totalMax)\n        };\n    },\n\n    labelsCount: function() {\n        var labelsRange = this.labelsRange();\n\n        return labelsRange.max - labelsRange.min;\n    },\n\n    labelsRange: function() {\n        var options = this.options;\n        var justified = options.justified;\n        var labelOptions = options.labels;\n        var ref = this.limitedRangeIndices(true);\n        var min = ref.min;\n        var max = ref.max;\n        var start = Math.floor(min);\n\n        if (!justified) {\n            min = Math.floor(min);\n            max = Math.ceil(max);\n        } else {\n            min = Math.ceil(min);\n            max = Math.floor(max);\n        }\n\n        var skip;\n\n        if (min > labelOptions.skip) {\n            skip = labelOptions.skip + labelOptions.step * Math.ceil((min - labelOptions.skip) / labelOptions.step);\n        } else {\n            skip = labelOptions.skip;\n        }\n\n        return {\n            min: skip - start,\n            max: (options.categories.length ? max + (justified ? 1 : 0) : 0) - start\n        };\n    },\n\n    createAxisLabel: function(index, labelOptions, labelContext) {\n        var options = this.options;\n        var dataItem = options.dataItems ? options.dataItems[index] : null;\n        var category = valueOrDefault(options.categories[index], \"\");\n\n        labelContext.dataItem = dataItem;\n        var text = this.axisLabelText(category, labelOptions, labelContext);\n\n        return new AxisLabel(category, text, index, dataItem, labelOptions);\n    },\n\n    shouldRenderNote: function(value) {\n        var range = this.limitedRangeIndices();\n\n        return Math.floor(range.min) <= value && value <= Math.ceil(range.max);\n    },\n\n    noteSlot: function(value) {\n        var options = this.options;\n        var index = value - Math.floor(options.min || 0);\n        return this.getSlot(index);\n    },\n\n    arrangeNotes: function() {\n        Axis.fn.arrangeNotes.call(this);\n        this.hideOutOfRangeNotes();\n    },\n\n    hideOutOfRangeNotes: function() {\n        var ref = this;\n        var notes = ref.notes;\n        var box = ref.box;\n        if (notes && notes.length) {\n            var valueAxis = this.options.vertical ? Y : X;\n            var start = box[valueAxis + 1];\n            var end = box[valueAxis + 2];\n\n            for (var idx = 0; idx < notes.length; idx++) {\n                var note = notes[idx];\n                if (note.box && (end < note.box[valueAxis + 1] || note.box[valueAxis + 2] < start)) {\n                    note.hide();\n                }\n            }\n        }\n    },\n\n    pan: function(delta) {\n        var range = this.limitedRangeIndices(true);\n        var ref = this.scaleOptions();\n        var scale = ref.scale;\n        var offset = round(delta / scale, DEFAULT_PRECISION);\n        var totalRange = this.totalRange();\n        var min = range.min + offset;\n        var max = range.max + offset;\n\n        return this.limitRange(min, max, 0, totalRange.max, offset);\n    },\n\n    pointsRange: function(start, end) {\n        var ref = this.options;\n        var reverse = ref.reverse;\n        var vertical = ref.vertical;\n        var valueAxis = vertical ? Y : X;\n        var range = this.limitedRangeIndices(true);\n        var ref$1 = this.scaleOptions();\n        var scale = ref$1.scale;\n        var box = ref$1.box;\n        var lineStart = box[valueAxis + (reverse ? 2 : 1)];\n\n        var diffStart = start[valueAxis] - lineStart;\n        var diffEnd = end[valueAxis] - lineStart;\n\n        var min = range.min + diffStart / scale;\n        var max = range.min + diffEnd / scale;\n        var rangeMin = Math.min(min, max);\n        var rangeMax = Math.max(min, max);\n\n        if (rangeMax - rangeMin >= MIN_CATEGORY_POINTS_RANGE) {\n            return {\n                min: rangeMin,\n                max: rangeMax\n            };\n        }\n    },\n\n    valueRange: function() {\n        return this.range();\n    },\n\n    totalIndex: function(value) {\n        var options = this.options;\n        var index = this._categoriesMap ?\n            this._categoriesMap.get(value) : indexOf(value, options.srcCategories);\n\n        return index;\n    },\n\n    currentRangeIndices: function() {\n        var options = this.options;\n        var min = 0;\n\n        if (isNumber(options.min)) {\n            min = Math.floor(options.min);\n        }\n\n        var max;\n        if (isNumber(options.max)) {\n            max = options.justified ? Math.floor(options.max) : Math.ceil(options.max) - 1;\n        } else {\n            max = this.totalCount() - 1;\n        }\n\n        return {\n            min: min,\n            max: max\n        };\n    },\n\n    limitedRangeIndices: function(totalLimit) {\n        var options = this.options;\n        var min = isNumber(options.min) ? options.min : 0;\n        var max;\n\n        if (isNumber(options.max)) {\n            max = options.max;\n        } else if (isNumber(options.min)) {\n            max = min + options.categories.length;\n        } else {\n            max = this.totalRange().max || 1;\n        }\n\n        if (totalLimit) {\n            var totalRange = this.totalRange();\n            min = limitValue(min, 0, totalRange.max);\n            max = limitValue(max, 0, totalRange.max);\n        }\n\n        return {\n            min: min,\n            max: max\n        };\n    },\n\n    totalRangeIndices: function() {\n        return {\n            min: 0,\n            max: this.totalRange().max || 1\n        };\n    },\n\n    indexCategories: function() {\n        if (!this._categoriesMap) {\n            var map$$1 = this._categoriesMap = new HashMap();\n            var srcCategories = this.options.srcCategories;\n            for (var idx = 0; idx < srcCategories.length; idx++) {\n                map$$1.set(srcCategories[idx], idx);\n            }\n        }\n    },\n\n    totalCount: function() {\n        return Math.max(this.options.srcCategories.length, this._seriesMax || 0);\n    }\n});\n\nsetDefaultOptions(CategoryAxis, {\n    type: \"category\",\n    vertical: false,\n    majorGridLines: {\n        visible: false,\n        width: 1,\n        color: BLACK\n    },\n    labels: {\n        zIndex: 1\n    },\n    justified: false,\n    _deferLabels: true\n});\n\nvar COORDINATE_LIMIT = 300000;\n\nvar DateLabelFormats = {\n    milliseconds: \"HH:mm:ss.fff\",\n    seconds: \"HH:mm:ss\",\n    minutes: \"HH:mm\",\n    hours: \"HH:mm\",\n    days: \"M/d\",\n    weeks: \"M/d\",\n    months: \"MMM 'yy\",\n    years: \"yyyy\"\n};\n\nvar ZERO_THRESHOLD = 0.2;\n\nvar AUTO = \"auto\";\nvar BASE_UNITS = [\n    MILLISECONDS, SECONDS, MINUTES, HOURS, DAYS, WEEKS, MONTHS, YEARS\n];\nvar FIT = \"fit\";\n\nfunction categoryRange(categories, clearCache) {\n    if (clearCache) {\n        categories._range = undefined;\n    }\n\n    var range = categories._range;\n    if (!range) {\n        range = categories._range = sparseArrayLimits(categories);\n        range.min = toDate(range.min);\n        range.max = toDate(range.max);\n    }\n\n    return range;\n}\n\nvar EmptyDateRange = Class.extend({\n    init: function(options) {\n        this.options = options;\n    },\n\n    displayIndices: function() {\n        return {\n            min: 0,\n            max: 1\n        };\n    },\n\n    displayRange: function() {\n        return {};\n    },\n\n    total: function() {\n        return {};\n    },\n\n    valueRange: function() {\n        return {};\n    },\n\n    valueIndex: function() {\n        return -1;\n    },\n\n    values: function() {\n        return [];\n    },\n\n    totalIndex: function() {\n        return -1;\n    },\n\n    valuesCount: function() {\n        return 0;\n    },\n\n    totalCount: function() {\n        return 0;\n    },\n\n    dateAt: function() {\n        return null;\n    }\n});\n\nvar DateRange = Class.extend({\n    init: function(start, end, options) {\n        this.options = options;\n        options.baseUnitStep = options.baseUnitStep || 1;\n\n        var roundToBaseUnit = options.roundToBaseUnit;\n        var justified = options.justified;\n\n        this.start = addDuration(start, 0, options.baseUnit, options.weekStartDay);\n        var lowerEnd = this.roundToTotalStep(end);\n        var expandEnd = !justified && dateEquals(end, lowerEnd) && !options.justifyEnd;\n\n        this.end = this.roundToTotalStep(end, !justified, expandEnd ? 1 : 0);\n\n        var min = options.min || start;\n        this.valueStart = this.roundToTotalStep(min);\n        this.displayStart = roundToBaseUnit ? this.valueStart : min;\n\n        var max = options.max;\n        if (!max) {\n            this.valueEnd = lowerEnd;\n            this.displayEnd = roundToBaseUnit || expandEnd ? this.end : end;\n        } else {\n            var next = !justified && dateEquals(max, this.roundToTotalStep(max)) ? -1 : 0;\n            this.valueEnd = this.roundToTotalStep(max, false, next);\n            this.displayEnd = roundToBaseUnit ? this.roundToTotalStep(max, !justified) : options.max;\n        }\n\n        if (this.valueEnd < this.valueStart) {\n            this.valueEnd = this.valueStart;\n        }\n        if (this.displayEnd <= this.displayStart) {\n            this.displayEnd = this.roundToTotalStep(this.displayStart, false, 1);\n        }\n    },\n\n    displayRange: function() {\n        return {\n            min: this.displayStart,\n            max: this.displayEnd\n        };\n    },\n\n    displayIndices: function() {\n        if (!this._indices) {\n            var options = this.options;\n\n            var baseUnit = options.baseUnit;\n            var baseUnitStep = options.baseUnitStep;\n\n            var minIdx = dateIndex(this.displayStart, this.valueStart, baseUnit, baseUnitStep);\n            var maxIdx = dateIndex(this.displayEnd, this.valueStart, baseUnit, baseUnitStep);\n\n            this._indices = { min: minIdx, max: maxIdx };\n        }\n\n        return this._indices;\n    },\n\n    total: function() {\n        return {\n            min: this.start,\n            max: this.end\n        };\n    },\n\n    totalCount: function() {\n        var last$$1 = this.totalIndex(this.end);\n\n        return last$$1 + (this.options.justified ? 1 : 0);\n    },\n\n    valueRange: function() {\n        return {\n            min: this.valueStart,\n            max: this.valueEnd\n        };\n    },\n\n    valueIndex: function(value) {\n        var options = this.options;\n        return Math.floor(dateIndex(value, this.valueStart, options.baseUnit, options.baseUnitStep));\n    },\n\n    totalIndex: function(value) {\n        var options = this.options;\n        return Math.floor(dateIndex(value, this.start, options.baseUnit, options.baseUnitStep));\n    },\n\n    dateIndex: function(value) {\n        var options = this.options;\n        return dateIndex(value, this.valueStart, options.baseUnit, options.baseUnitStep);\n    },\n\n    valuesCount: function() {\n        var maxIdx = this.valueIndex(this.valueEnd);\n\n        return maxIdx + 1;\n    },\n\n    values: function() {\n        var values = this._values;\n        if (!values) {\n            var options = this.options;\n            var range = this.valueRange();\n            this._values = values = [];\n\n            for (var date = range.min; date <= range.max;) {\n                values.push(date);\n                date = addDuration(date, options.baseUnitStep, options.baseUnit, options.weekStartDay);\n            }\n        }\n\n        return values;\n    },\n\n    dateAt: function(index, total) {\n        var options = this.options;\n\n        return addDuration(total ? this.start : this.valueStart, options.baseUnitStep * index, options.baseUnit, options.weekStartDay);\n    },\n\n    roundToTotalStep: function(value, upper, next) {\n        var ref = this.options;\n        var baseUnit = ref.baseUnit;\n        var baseUnitStep = ref.baseUnitStep;\n        var weekStartDay = ref.weekStartDay;\n        var start = this.start;\n\n        var step = dateIndex(value, start, baseUnit, baseUnitStep);\n        var roundedStep = upper ? Math.ceil(step) : Math.floor(step);\n\n        if (next) {\n            roundedStep += next;\n        }\n\n        return addDuration(start, roundedStep * baseUnitStep, baseUnit, weekStartDay);\n    }\n});\n\nfunction autoBaseUnit(options, startUnit, startStep) {\n    var categoryLimits = categoryRange(options.categories);\n    var span = (options.max || categoryLimits.max) - (options.min || categoryLimits.min);\n    var autoBaseUnitSteps = options.autoBaseUnitSteps;\n    var maxDateGroups = options.maxDateGroups;\n    var autoUnit = options.baseUnit === FIT;\n    var autoUnitIx = startUnit ? BASE_UNITS.indexOf(startUnit) : 0;\n    var baseUnit = autoUnit ? BASE_UNITS[autoUnitIx++] : options.baseUnit;\n    var units = span / TIME_PER_UNIT[baseUnit];\n    var totalUnits = units;\n    var unitSteps, step, nextStep;\n\n    while (!step || units >= maxDateGroups) {\n        unitSteps = unitSteps || autoBaseUnitSteps[baseUnit].slice(0);\n\n        do {\n            nextStep = unitSteps.shift();\n        } while (nextStep && startUnit === baseUnit && nextStep < startStep);\n\n        if (nextStep) {\n            step = nextStep;\n            units = totalUnits / step;\n        } else if (baseUnit === last(BASE_UNITS)) {\n            step = Math.ceil(totalUnits / maxDateGroups);\n            break;\n        } else if (autoUnit) {\n            baseUnit = BASE_UNITS[autoUnitIx++] || last(BASE_UNITS);\n            totalUnits = span / TIME_PER_UNIT[baseUnit];\n            unitSteps = null;\n        } else {\n            if (units > maxDateGroups) {\n                step = Math.ceil(totalUnits / maxDateGroups);\n            }\n            break;\n        }\n    }\n\n    options.baseUnitStep = step;\n    options.baseUnit = baseUnit;\n}\n\nfunction defaultBaseUnit(options) {\n    var categories = options.categories;\n    var count = defined(categories) ? categories.length : 0;\n    var minDiff = MAX_VALUE;\n    var lastCategory, unit;\n\n    for (var categoryIx = 0; categoryIx < count; categoryIx++) {\n        var category = categories[categoryIx];\n\n        if (category && lastCategory) {\n            var diff = Math.abs(absoluteDateDiff(category, lastCategory));\n\n            if (diff !== 0) {\n                minDiff = Math.min(minDiff, diff);\n\n                if (minDiff >= TIME_PER_YEAR) {\n                    unit = YEARS;\n                } else if (minDiff >= TIME_PER_MONTH - TIME_PER_DAY * 3) {\n                    unit = MONTHS;\n                } else if (minDiff >= TIME_PER_WEEK) {\n                    unit = WEEKS;\n                } else if (minDiff >= TIME_PER_DAY) {\n                    unit = DAYS;\n                } else if (minDiff >= TIME_PER_HOUR) {\n                    unit = HOURS;\n                } else if (minDiff >= TIME_PER_MINUTE) {\n                    unit = MINUTES;\n                } else {\n                    unit = SECONDS;\n                }\n            }\n        }\n\n        lastCategory = category;\n    }\n\n    options.baseUnit = unit || DAYS;\n}\n\nfunction initUnit(options) {\n    var baseUnit = (options.baseUnit || \"\").toLowerCase();\n    var useDefault = baseUnit !== FIT && !inArray(baseUnit, BASE_UNITS);\n\n    if (useDefault) {\n        defaultBaseUnit(options);\n    }\n\n    if (baseUnit === FIT || options.baseUnitStep === AUTO) {\n        autoBaseUnit(options);\n    }\n\n    return options;\n}\n\nvar DateCategoryAxis = CategoryAxis.extend({\n    clone: function() {\n        var copy = new DateCategoryAxis($.extend({}, this.options), this.chartService);\n        copy.createLabels();\n\n        return copy;\n    },\n\n    categoriesHash: function() {\n        var start = this.dataRange.total().min;\n        return this.options.baseUnit + this.options.baseUnitStep + start;\n    },\n\n    initUserOptions: function(options) {\n        return options;\n    },\n\n    initFields: function() {\n        CategoryAxis.fn.initFields.call(this);\n\n        var chartService = this.chartService;\n        var intlService = chartService.intl;\n        var options = this.options;\n\n        var categories = options.categories || [];\n        if (!categories._parsed) {\n            categories = parseDates(intlService, categories);\n            categories._parsed = true;\n        }\n\n        options = deepExtend({\n            roundToBaseUnit: true\n        }, options, {\n            categories: categories,\n            min: parseDate(intlService, options.min),\n            max: parseDate(intlService, options.max),\n            weekStartDay: firstDay(options, intlService)\n        });\n\n        if (chartService.panning && chartService.isPannable(options.vertical ? Y : X)) {\n            options.roundToBaseUnit = false;\n        }\n\n        options.userSetBaseUnit = options.userSetBaseUnit || options.baseUnit;\n        options.userSetBaseUnitStep = options.userSetBaseUnitStep || options.baseUnitStep;\n\n        this.options = options;\n        options.srcCategories = categories;\n\n        if (categories.length > 0) {\n            var range = categoryRange(categories, true);\n            var maxDivisions = options.maxDivisions;\n            var safeOptions = initUnit(options);\n\n            var forecast = options._forecast;\n            if (forecast) {\n                if (forecast.before > 0) {\n                    range.min = addDuration(range.min, -forecast.before, safeOptions.baseUnit, safeOptions.weekStartDay);\n                }\n\n                if (forecast.after > 0) {\n                    range.max = addDuration(range.max, forecast.after, safeOptions.baseUnit, safeOptions.weekStartDay);\n                }\n            }\n\n            this.dataRange = new DateRange(range.min, range.max, safeOptions);\n\n            if (maxDivisions) {\n                var dataRange = this.dataRange.displayRange();\n\n                var divisionOptions = $.extend({}, options, {\n                    justified: true,\n                    roundToBaseUnit: false,\n                    baseUnit: 'fit',\n                    min: dataRange.min,\n                    max: dataRange.max,\n                    maxDateGroups: maxDivisions\n                });\n\n                var dataRangeOptions = this.dataRange.options;\n\n                autoBaseUnit(divisionOptions, dataRangeOptions.baseUnit, dataRangeOptions.baseUnitStep);\n\n                this.divisionRange = new DateRange(range.min, range.max, divisionOptions);\n            } else {\n                this.divisionRange = this.dataRange;\n            }\n\n        } else {\n            options.baseUnit = options.baseUnit || DAYS;\n            this.dataRange = this.divisionRange = new EmptyDateRange(options);\n        }\n\n        this.rangeLabels = [];\n    },\n\n    tickIndices: function(stepSize) {\n        var ref = this;\n        var dataRange = ref.dataRange;\n        var divisionRange = ref.divisionRange;\n        var valuesCount = divisionRange.valuesCount();\n\n        if (!this.options.maxDivisions || !valuesCount) {\n            return CategoryAxis.fn.tickIndices.call(this, stepSize);\n        }\n\n        var indices = [];\n        var values = divisionRange.values();\n        var offset = 0;\n\n        if (!this.options.justified) {\n            values = values.concat(divisionRange.dateAt(valuesCount));\n            offset = 0.5;//align ticks to the center of not justified categories\n        }\n\n        for (var idx = 0; idx < values.length; idx++) {\n            indices.push(dataRange.dateIndex(values[idx]) + offset);\n            if (stepSize !== 1 && idx >= 1) {\n                var last$$1 = indices.length - 1;\n                indices.splice(idx, 0, indices[last$$1 - 1] + (indices[last$$1] - indices[last$$1 - 1]) * stepSize);\n            }\n        }\n\n        return indices;\n    },\n\n    shouldRenderNote: function(value) {\n        var range = this.range();\n        var categories = this.options.categories || [];\n\n        return dateComparer(value, range.min) >= 0 && dateComparer(value, range.max) <= 0 && categories.length;\n    },\n\n    parseNoteValue: function(value) {\n        return parseDate(this.chartService.intl, value);\n    },\n\n    noteSlot: function(value) {\n        return this.getSlot(value);\n    },\n\n    translateRange: function(delta) {\n        var options = this.options;\n        var baseUnit = options.baseUnit;\n        var weekStartDay = options.weekStartDay;\n        var vertical = options.vertical;\n        var lineBox = this.lineBox();\n        var size = vertical ? lineBox.height() : lineBox.width();\n        var range = this.range();\n        var scale = size / (range.max - range.min);\n        var offset = round(delta / scale, DEFAULT_PRECISION);\n\n        if (range.min && range.max) {\n            var from = addTicks(options.min || range.min, offset);\n            var to = addTicks(options.max || range.max, offset);\n\n            range = {\n                min: addDuration(from, 0, baseUnit, weekStartDay),\n                max: addDuration(to, 0, baseUnit, weekStartDay)\n            };\n        }\n\n        return range;\n    },\n\n    labelsRange: function() {\n        return {\n            min: this.options.labels.skip,\n            max: this.divisionRange.valuesCount()\n        };\n    },\n\n    pan: function(delta) {\n        if (this.isEmpty()) {\n            return null;\n        }\n\n        var options = this.options;\n        var lineBox = this.lineBox();\n        var size = options.vertical ? lineBox.height() : lineBox.width();\n        var ref = this.dataRange.displayRange();\n        var min = ref.min;\n        var max = ref.max;\n        var totalLimits = this.dataRange.total();\n        var scale = size / (max - min);\n        var offset = round(delta / scale, DEFAULT_PRECISION) * (options.reverse ? -1 : 1);\n        var from = addTicks(min, offset);\n        var to = addTicks(max, offset);\n\n        var panRange = this.limitRange(toTime(from), toTime(to), toTime(totalLimits.min), toTime(totalLimits.max), offset);\n\n        if (panRange) {\n            panRange.min = toDate(panRange.min);\n            panRange.max = toDate(panRange.max);\n            panRange.baseUnit = options.baseUnit;\n            panRange.baseUnitStep = options.baseUnitStep || 1;\n            panRange.userSetBaseUnit = options.userSetBaseUnit;\n            panRange.userSetBaseUnitStep = options.userSetBaseUnitStep;\n\n            return panRange;\n        }\n    },\n\n    pointsRange: function(start, end) {\n        if (this.isEmpty()) {\n            return null;\n        }\n\n        var pointsRange = CategoryAxis.fn.pointsRange.call(this, start, end);\n        var datesRange = this.dataRange.displayRange();\n        var indicesRange = this.dataRange.displayIndices();\n        var scale = dateDiff(datesRange.max, datesRange.min) / (indicesRange.max - indicesRange.min);\n        var options = this.options;\n\n        var min = addTicks(datesRange.min, pointsRange.min * scale);\n        var max = addTicks(datesRange.min, pointsRange.max * scale);\n\n        return {\n            min: min,\n            max: max,\n            baseUnit: options.userSetBaseUnit || options.baseUnit,\n            baseUnitStep: options.userSetBaseUnitStep || options.baseUnitStep\n        };\n    },\n\n    scaleRange: function(scale, cursor) {\n        if (this.isEmpty()) {\n            return {};\n        }\n\n        var options = this.options;\n        var fit = options.userSetBaseUnit === FIT;\n        var totalLimits = this.dataRange.total();\n        var ref = this.dataRange.displayRange();\n        var rangeMin = ref.min;\n        var rangeMax = ref.max;\n\n        var position = Math.abs(this.pointOffset(cursor));\n        var range = rangeMax - rangeMin;\n        var delta = this.scaleToDelta(scale, range);\n        var minDelta = Math.round(position * delta);\n        var maxDelta = Math.round((1 - position) * delta);\n\n        var ref$1 = this.dataRange.options;\n        var baseUnit = ref$1.baseUnit;\n        var min = new Date(rangeMin.getTime() + minDelta);\n        var max = new Date(rangeMax.getTime() - maxDelta);\n\n        if (fit) {\n            var autoBaseUnitSteps = options.autoBaseUnitSteps;\n            var maxDateGroups = options.maxDateGroups;\n\n            var maxDiff = last(autoBaseUnitSteps[baseUnit]) * maxDateGroups * TIME_PER_UNIT[baseUnit];\n            var rangeDiff = dateDiff(rangeMax, rangeMin);\n            var diff = dateDiff(max, min);\n            var baseUnitIndex = BASE_UNITS.indexOf(baseUnit);\n            var autoBaseUnitStep, ticks;\n\n            if (diff < TIME_PER_UNIT[baseUnit] && baseUnit !== MILLISECONDS) {\n                baseUnit = BASE_UNITS[baseUnitIndex - 1];\n                autoBaseUnitStep = last(autoBaseUnitSteps[baseUnit]);\n                ticks = (rangeDiff - (maxDateGroups - 1) * autoBaseUnitStep * TIME_PER_UNIT[baseUnit]) / 2;\n                min = addTicks(rangeMin, ticks);\n                max = addTicks(rangeMax, -ticks);\n\n            } else if (diff > maxDiff && baseUnit !== YEARS) {\n                var stepIndex = 0;\n\n                do {\n                    baseUnitIndex++;\n                    baseUnit = BASE_UNITS[baseUnitIndex];\n                    stepIndex = 0;\n                    ticks = 2 * TIME_PER_UNIT[baseUnit];\n                    do {\n                        autoBaseUnitStep = autoBaseUnitSteps[baseUnit][stepIndex];\n                        stepIndex++;\n                    } while (stepIndex < autoBaseUnitSteps[baseUnit].length && ticks * autoBaseUnitStep < rangeDiff);\n                } while (baseUnit !== YEARS && ticks * autoBaseUnitStep < rangeDiff);\n\n                ticks = (ticks * autoBaseUnitStep - rangeDiff) / 2;\n                if (ticks > 0) {\n                    min = addTicks(rangeMin, -ticks);\n                    max = addTicks(rangeMax, ticks);\n                    min = addTicks(min, limitValue(max, totalLimits.min, totalLimits.max) - max);\n                    max = addTicks(max, limitValue(min, totalLimits.min, totalLimits.max) - min);\n                }\n            }\n        }\n\n        if (min && max && dateDiff(max, min) > 0) {\n            return {\n                min: min,\n                max: max,\n                baseUnit: options.userSetBaseUnit || options.baseUnit,\n                baseUnitStep: options.userSetBaseUnitStep || options.baseUnitStep\n            };\n        }\n    },\n\n    zoomRange: function(scale, cursor) {\n        var totalLimits = this.dataRange.total();\n        var range = this.scaleRange(scale, cursor);\n\n        if (range) {\n            if (range.min < totalLimits.min) {\n                range.min = totalLimits.min;\n            }\n            if (range.max > totalLimits.max) {\n                range.max = totalLimits.max;\n            }\n        }\n\n        return range;\n    },\n\n    range: function() {\n        return this.dataRange.displayRange();\n    },\n\n    createLabels: function() {\n        CategoryAxis.fn.createLabels.call(this);\n        this.createRangeLabels();\n    },\n\n    clearLabels: function() {\n        CategoryAxis.fn.clearLabels.call(this);\n        this.rangeLabels = [];\n    },\n\n    arrangeLabels: function() {\n        this.arrangeRangeLabels();\n        CategoryAxis.fn.arrangeLabels.call(this);\n    },\n\n    arrangeRangeLabels: function() {\n        var ref = this;\n        var options = ref.options;\n        var rangeLabels = ref.rangeLabels;\n        if (rangeLabels.length === 0) {\n            return;\n        }\n\n        var lineBox = this.lineBox();\n        var vertical = options.vertical;\n        var mirror = options.rangeLabels.mirror || options.labels.mirror;\n\n        var firstLabel = rangeLabels[0];\n        if (firstLabel) {\n            var position = vertical ? lineBox.y1 - (firstLabel.box.height() / 2) : lineBox.x1;\n            this.positionLabel(firstLabel, mirror, position);\n        }\n\n        var lastLabel = rangeLabels[1];\n        if (lastLabel) {\n            var position$1 = vertical ? lineBox.y2 - (lastLabel.box.height() / 2) : lineBox.x2;\n            this.positionLabel(lastLabel, mirror, position$1);\n        }\n    },\n\n    autoRotateLabels: function() {\n        CategoryAxis.fn.autoRotateLabels.call(this);\n        this.autoRotateRangeLabels();\n    },\n\n    hideOutOfRangeLabels: function() {\n        CategoryAxis.fn.hideOutOfRangeLabels.call(this);\n        this.hideOverlappingLabels();\n    },\n\n    hideOverlappingLabels: function() {\n        var ref = this;\n        var rangeLabels = ref.rangeLabels;\n        var labels = ref.labels;\n        if (rangeLabels.length === 0) {\n            return;\n        }\n\n        function clip(rangeLabel, label) {\n            if (!label.options.visible || label.box.overlaps(rangeLabel.box)) {\n                label.options.visible = false;\n                return true;\n            }\n\n            return false;\n        }\n\n        var firstRangeLabel = rangeLabels[0];\n        if (firstRangeLabel && firstRangeLabel.options.visible) {\n            for (var i = 0; i < labels.length; i++) {\n                var overlaps = clip(firstRangeLabel, labels[i]);\n                if (!overlaps) {\n                    break;\n                }\n            }\n        }\n\n        var lastRangeLabel = rangeLabels[1];\n        if (lastRangeLabel && lastRangeLabel.options.visible) {\n            for (var i$1 = labels.length - 1; i$1 > 0; --i$1) {\n                var overlaps$1 = clip(lastRangeLabel, labels[i$1]);\n                if (!overlaps$1) {\n                    break;\n                }\n            }\n        }\n    },\n\n    contentBox: function() {\n        var box = CategoryAxis.fn.contentBox.call(this);\n        var rangeLabels = this.rangeLabels;\n\n        for (var i = 0; i < rangeLabels.length; i++) {\n            var label = rangeLabels[i];\n            if (label.options.visible) {\n                box.wrap(label.box);\n            }\n        }\n\n        return box;\n    },\n\n    createAxisLabel: function(index, labelOptions, labelContext) {\n        if (labelContext === void 0) { labelContext = {}; }\n\n        var options = this.options;\n        var dataItem = options.dataItems && !options.maxDivisions ? options.dataItems[index] : null;\n        var date = this.divisionRange.dateAt(index);\n        var unitFormat = labelOptions.dateFormats[this.divisionRange.options.baseUnit];\n\n        labelOptions.format = labelOptions.format || unitFormat;\n        labelContext.dataItem = dataItem;\n\n        var text = this.axisLabelText(date, labelOptions, labelContext);\n        if (text) {\n            return new AxisLabel(date, text, index, dataItem, labelOptions);\n        }\n    },\n\n    createRangeLabels: function() {\n        var this$1$1 = this;\n\n        var ref = this.divisionRange;\n        var displayStart = ref.displayStart;\n        var displayEnd = ref.displayEnd;\n        var options = this.options;\n        var labelOptions = $.extend({}, options.labels, options.rangeLabels, {\n            align: CENTER,\n            zIndex: options.zIndex\n        });\n\n        if (labelOptions.visible !== true) {\n            return;\n        }\n\n        this.normalizeLabelRotation(labelOptions);\n        labelOptions.alignRotation = CENTER;\n\n        if (labelOptions.rotation === \"auto\") {\n            labelOptions.rotation = 0;\n            options.autoRotateRangeLabels = true;\n        }\n\n        var unitFormat = labelOptions.dateFormats[this.divisionRange.options.baseUnit];\n        labelOptions.format = labelOptions.format || unitFormat;\n\n        var createLabel = function (index, date, text) {\n            if (text) {\n                var label = new AxisLabel(date, text, index, null, labelOptions);\n                this$1$1.append(label);\n                this$1$1.rangeLabels.push(label);\n            }\n        };\n\n        var startText = this.axisLabelText(displayStart, labelOptions, { index: 0, count: 2 });\n        createLabel(0, displayStart, startText);\n\n        var endText = this.axisLabelText(displayEnd, labelOptions, { index: 1, count: 2 });\n        createLabel(1, displayEnd, endText);\n    },\n\n    autoRotateRangeLabels: function() {\n        var this$1$1 = this;\n\n        var labels = this.rangeLabels;\n        if (!this.options.autoRotateRangeLabels || this.options.vertical || labels.length !== 2) {\n            return;\n        }\n\n        var rotateLabel = function (label, tickPositions, index) {\n            var width = Math.abs(tickPositions[index + 1] - tickPositions[index]) * 2;\n            var angle = this$1$1.autoRotateLabelAngle(label.box, width);\n            if (angle !== 0) {\n                label.options.rotation = angle;\n                label.reflow(new Box());\n            }\n        };\n\n        var tickPositions = this.getMajorTickPositions();\n        rotateLabel(labels[0], tickPositions, 0);\n        rotateLabel(labels[1], tickPositions, tickPositions.length - 2);\n    },\n\n    categoryIndex: function(value) {\n        return this.dataRange.valueIndex(value);\n    },\n\n    slot: function(from, to, limit) {\n        var dateRange = this.dataRange;\n        var start = from;\n        var end = to;\n\n        if (start instanceof Date) {\n            start = dateRange.dateIndex(start);\n        }\n\n        if (end instanceof Date) {\n            end = dateRange.dateIndex(end);\n        }\n\n        var slot = this.getSlot(start, end, limit);\n        if (slot) {\n            return slot.toRect();\n        }\n    },\n\n    getSlot: function(a, b, limit) {\n        var start = a;\n        var end = b;\n\n        if (typeof start === OBJECT) {\n            start = this.categoryIndex(start);\n        }\n\n        if (typeof end === OBJECT) {\n            end = this.categoryIndex(end);\n        }\n\n        return CategoryAxis.fn.getSlot.call(this, start, end, limit);\n    },\n\n    valueRange: function() {\n        var options = this.options;\n        var range = categoryRange(options.srcCategories);\n\n        return {\n            min: toDate(range.min),\n            max: toDate(range.max)\n        };\n    },\n\n    categoryAt: function(index, total) {\n        return this.dataRange.dateAt(index, total);\n    },\n\n    categoriesCount: function() {\n        return this.dataRange.valuesCount();\n    },\n\n    rangeIndices: function() {\n        return this.dataRange.displayIndices();\n    },\n\n    labelsBetweenTicks: function() {\n        return !this.divisionRange.options.justified;\n    },\n\n    prepareUserOptions: function() {\n        if (this.isEmpty()) {\n            return;\n        }\n\n        this.options.categories = this.dataRange.values();\n    },\n\n    getCategory: function(point) {\n        var index = this.pointCategoryIndex(point);\n\n        if (index === null) {\n            return null;\n        }\n\n        return this.dataRange.dateAt(index);\n    },\n\n    totalIndex: function(value) {\n        return this.dataRange.totalIndex(value);\n    },\n\n    currentRangeIndices: function() {\n        var range = this.dataRange.valueRange();\n        return {\n            min: this.dataRange.totalIndex(range.min),\n            max: this.dataRange.totalIndex(range.max)\n        };\n    },\n\n    totalRange: function() {\n        return this.dataRange.total();\n    },\n\n    totalRangeIndices: function() {\n        var range = this.dataRange.total();\n        return {\n            min: this.dataRange.totalIndex(range.min),\n            max: this.dataRange.totalIndex(range.max)\n        };\n    },\n\n    totalCount: function() {\n        return this.dataRange.totalCount();\n    },\n\n    isEmpty: function() {\n        return !this.options.srcCategories.length;\n    },\n\n    roundedRange: function() {\n        if (this.options.roundToBaseUnit !== false || this.isEmpty()) {\n            return this.range();\n        }\n\n        var options = this.options;\n        var datesRange = categoryRange(options.srcCategories);\n\n        var dateRange = new DateRange(datesRange.min, datesRange.max, $.extend({}, options, {\n            justified: false,\n            roundToBaseUnit: true,\n            justifyEnd: false\n        }));\n\n        return dateRange.displayRange();\n    }\n});\n\nsetDefaultOptions(DateCategoryAxis, {\n    type: DATE,\n    labels: {\n        dateFormats: DateLabelFormats\n    },\n    rangeLabels: {\n        visible: false\n    },\n    autoBaseUnitSteps: {\n        milliseconds: [ 1, 10, 100 ],\n        seconds: [ 1, 2, 5, 15, 30 ],\n        minutes: [ 1, 2, 5, 15, 30 ],\n        hours: [ 1, 2, 3 ],\n        days: [ 1, 2, 3 ],\n        weeks: [ 1, 2 ],\n        months: [ 1, 2, 3, 6 ],\n        years: [ 1, 2, 3, 5, 10, 25, 50 ]\n    },\n    maxDateGroups: 10\n});\n\nfunction autoAxisMin(min, max, narrow) {\n    if (!min && !max) {\n        return 0;\n    }\n\n    var axisMin;\n\n    if (min >= 0 && max >= 0) {\n        var minValue = min === max ? 0 : min;\n\n        var diff = (max - minValue) / max;\n        if (narrow === false || (!narrow && diff > ZERO_THRESHOLD)) {\n            return 0;\n        }\n\n        axisMin = Math.max(0, minValue - ((max - minValue) / 2));\n    } else {\n        axisMin = min;\n    }\n\n    return axisMin;\n}\n\nfunction autoAxisMax(min, max, narrow) {\n    if (!min && !max) {\n        return 1;\n    }\n\n    var axisMax;\n\n    if (min <= 0 && max <= 0) {\n        var maxValue = min === max ? 0 : max;\n\n        var diff = Math.abs((maxValue - min) / maxValue);\n        if (narrow === false || (!narrow && diff > ZERO_THRESHOLD)) {\n            return 0;\n        }\n\n        axisMax = Math.min(0, maxValue - ((min - maxValue) / 2));\n    } else {\n        axisMax = max;\n    }\n\n    return axisMax;\n}\n\nfunction floor(value, step) {\n    return round(Math.floor(value / step) * step, DEFAULT_PRECISION);\n}\n\nfunction ceil(value, step) {\n    return round(Math.ceil(value / step) * step, DEFAULT_PRECISION);\n}\n\nfunction limitCoordinate(value) {\n    return Math.max(Math.min(value, COORDINATE_LIMIT), -COORDINATE_LIMIT);\n}\n\nvar MIN_VALUE_RANGE$1 = Math.pow(10, -DEFAULT_PRECISION + 1);\n\nvar NumericAxis = Axis.extend({\n    init: function(seriesMin, seriesMax, options, chartService) {\n        Axis.fn.init.call(this, $.extend({}, options, {\n            seriesMin: seriesMin,\n            seriesMax: seriesMax\n        }), chartService);\n    },\n\n    initUserOptions: function(options) {\n        var autoOptions = autoAxisOptions(options.seriesMin, options.seriesMax, options);\n        this.totalOptions = totalAxisOptions(autoOptions, options);\n\n        return axisOptions(autoOptions, options);\n    },\n\n    initFields: function() {\n        this.totalMin = this.totalOptions.min;\n        this.totalMax = this.totalOptions.max;\n        this.totalMajorUnit = this.totalOptions.majorUnit;\n        this.seriesMin = this.options.seriesMin;\n        this.seriesMax = this.options.seriesMax;\n    },\n\n    clone: function() {\n        return new NumericAxis(\n            this.seriesMin,\n            this.seriesMax,\n            $.extend({}, this.options),\n            this.chartService\n        );\n    },\n\n    startValue: function() {\n        return 0;\n    },\n\n    range: function() {\n        var options = this.options;\n        return { min: options.min, max: options.max };\n    },\n\n    getDivisions: function(stepValue) {\n        if (stepValue === 0) {\n            return 1;\n        }\n\n        var options = this.options;\n        var range = options.max - options.min;\n\n        return Math.floor(round(range / stepValue, COORD_PRECISION)) + 1;\n    },\n\n    getTickPositions: function(unit, skipUnit) {\n        var options = this.options;\n        var ref = this.lineInfo();\n        var axisDir = ref.axisDir;\n        var axisOrigin = ref.axisOrigin;\n        var lineBox = ref.lineBox;\n        var lineSize = ref.lineSize;\n        var range = options.max - options.min;\n        var scale = lineSize / range;\n        var step = unit * scale;\n        var divisions = this.getDivisions(unit);\n        var positions = [];\n        var pos = lineBox[axisOrigin];\n        var skipStep = 0;\n\n        if (skipUnit) {\n            skipStep = skipUnit / unit;\n        }\n\n        for (var idx = 0; idx < divisions; idx++) {\n            if (idx % skipStep !== 0) {\n                positions.push(round(pos, COORD_PRECISION));\n            }\n\n            pos = pos + step * axisDir;\n        }\n\n        return positions;\n    },\n\n    getMajorTickPositions: function() {\n        return this.getTickPositions(this.options.majorUnit);\n    },\n\n    getMinorTickPositions: function() {\n        return this.getTickPositions(this.options.minorUnit);\n    },\n\n    getSlot: function(a, b, limit) {\n        if (limit === void 0) { limit = false; }\n\n        var options = this.options;\n        var ref = this.lineInfo();\n        var axis = ref.axis;\n        var axisDir = ref.axisDir;\n        var lineBox = ref.lineBox;\n        var lineSize = ref.lineSize;\n        var lineStart = ref.lineStart;\n        var step = axisDir * (lineSize / (options.max - options.min));\n\n        var start = valueOrDefault(a, b || 0);\n        var end = valueOrDefault(b, a || 0);\n\n        if (limit) {\n            start = limitValue(start, options.min, options.max);\n            end = limitValue(end, options.min, options.max);\n        }\n\n        var p1 = Math.min(start, end) - options.min;\n        var p2 = Math.max(start, end) - options.min;\n\n        var slotBox = new Box(lineBox.x1, lineBox.y1, lineBox.x1, lineBox.y1);\n        slotBox[axis + 1] = limitCoordinate(lineStart + step * (axisDir > 0 ? p1 : p2));\n        slotBox[axis + 2] = limitCoordinate(lineStart + step * (axisDir > 0 ? p2 : p1));\n\n        return slotBox;\n    },\n\n    getValue: function(point) {\n        var options = this.options;\n        var max = Number(options.max);\n        var min = Number(options.min);\n        var offset = this.pointOffset(point);\n        var valueOffset = offset * (max - min);\n\n        if (offset < 0 || offset > 1) {\n            return null;\n        }\n\n        var value = min + valueOffset;\n        return round(value, DEFAULT_PRECISION);\n    },\n\n    translateRange: function(delta) {\n        var options = this.options;\n        var vertical = options.vertical;\n        var reverse = options.reverse;\n        var max = options.max;\n        var min = options.min;\n        var ref = this.lineInfo();\n        var lineSize = ref.lineSize;\n        var range = max - min;\n        var scale = lineSize / range;\n        var offset = round(delta / scale, DEFAULT_PRECISION);\n\n        if ((vertical || reverse) && !(vertical && reverse )) {\n            offset = -offset;\n        }\n\n        return {\n            min: min + offset,\n            max: max + offset,\n            offset: offset\n        };\n    },\n\n    labelsCount: function() {\n        return this.getDivisions(this.options.majorUnit);\n    },\n\n    createAxisLabel: function(index, labelOptions, labelContext) {\n        var options = this.options;\n        var value = round(options.min + (index * options.majorUnit), DEFAULT_PRECISION);\n        var text = this.axisLabelText(value, labelOptions, labelContext);\n\n        return new AxisLabel(value, text, index, null, labelOptions);\n    },\n\n    shouldRenderNote: function(value) {\n        var range = this.range();\n        return range.min <= value && value <= range.max;\n    },\n\n    pan: function(delta) {\n        var range = this.translateRange(delta);\n        return this.limitRange(range.min, range.max, this.totalMin, this.totalMax, range.offset);\n    },\n\n    pointsRange: function(start, end) {\n        var startValue = this.getValue(start);\n        var endValue = this.getValue(end);\n        var min = Math.min(startValue, endValue);\n        var max = Math.max(startValue, endValue);\n\n        if (this.isValidRange(min, max)) {\n            return {\n                min: min,\n                max: max\n            };\n        }\n    },\n\n    scaleRange: function(scale, cursor) {\n        var position = Math.abs(this.pointOffset(cursor));\n        var range = this.options.max - this.options.min;\n        var delta = this.scaleToDelta(scale, range);\n        var minDelta = position * delta;\n        var maxDelta = (1 - position) * delta;\n        var min = round(this.options.min + minDelta, DEFAULT_PRECISION);\n        var max = round(this.options.max - maxDelta, DEFAULT_PRECISION);\n\n        if (max - min < MIN_VALUE_RANGE$1) {\n            max = min + MIN_VALUE_RANGE$1;\n        }\n\n        return {\n            min: min,\n            max: max\n        };\n    },\n\n    zoomRange: function(scale, cursor) {\n        var ref = this;\n        var totalMin = ref.totalMin;\n        var totalMax = ref.totalMax;\n        var range = this.scaleRange(scale, cursor);\n\n        return {\n            min: limitValue(range.min, totalMin, totalMax),\n            max: limitValue(range.max, totalMin, totalMax),\n            narrowRange: false\n        };\n    },\n\n    isValidRange: function(min, max) {\n        return max - min > MIN_VALUE_RANGE$1;\n    }\n});\n\nfunction autoAxisOptions(seriesMin, seriesMax, options) {\n    var narrowRange = options.narrowRange;\n\n    var autoMin = autoAxisMin(seriesMin, seriesMax, narrowRange);\n    var autoMax = autoAxisMax(seriesMin, seriesMax, narrowRange);\n\n    var majorUnit = autoMajorUnit(autoMin, autoMax);\n    var autoOptions = {\n        majorUnit: majorUnit\n    };\n\n    if (options.roundToMajorUnit !== false) {\n        if (autoMin < 0 && remainderClose(autoMin, majorUnit, 1 / 3)) {\n            autoMin -= majorUnit;\n        }\n\n        if (autoMax > 0 && remainderClose(autoMax, majorUnit, 1 / 3)) {\n            autoMax += majorUnit;\n        }\n    }\n\n    autoOptions.min = floor(autoMin, majorUnit);\n    autoOptions.max = ceil(autoMax, majorUnit);\n\n    return autoOptions;\n}\n\nfunction totalAxisOptions(autoOptions, options) {\n    return {\n        min: defined(options.min) ? Math.min(autoOptions.min, options.min) : autoOptions.min,\n        max: defined(options.max) ? Math.max(autoOptions.max, options.max) : autoOptions.max,\n        majorUnit: autoOptions.majorUnit\n    };\n}\n\nfunction clearNullValues(options, fields) {\n    for (var idx = 0; idx < fields.length; idx++) {\n        var field = fields[idx];\n        if (options[field] === null) {\n            options[field] = undefined;\n        }\n    }\n}\n\nfunction axisOptions(autoOptions, userOptions) {\n    var options = userOptions;\n    var userSetMin, userSetMax;\n\n    if (userOptions) {\n        clearNullValues(userOptions, [ 'min', 'max' ]);\n\n        userSetMin = defined(userOptions.min);\n        userSetMax = defined(userOptions.max);\n\n        var userSetLimits = userSetMin || userSetMax;\n\n        if (userSetLimits) {\n            if (userOptions.min === userOptions.max) {\n                if (userOptions.min > 0) {\n                    userOptions.min = 0;\n                } else {\n                    userOptions.max = 1;\n                }\n            }\n        }\n\n        if (userOptions.majorUnit) {\n            autoOptions.min = floor(autoOptions.min, userOptions.majorUnit);\n            autoOptions.max = ceil(autoOptions.max, userOptions.majorUnit);\n        } else if (userSetLimits) {\n            options = deepExtend(autoOptions, userOptions);\n\n            // Determine an auto major unit after min/max have been set\n            autoOptions.majorUnit = autoMajorUnit(options.min, options.max);\n        }\n    }\n\n    autoOptions.minorUnit = (options.majorUnit || autoOptions.majorUnit) / 5;\n\n    var result = deepExtend(autoOptions, options);\n    if (result.min >= result.max) {\n        if (userSetMin && !userSetMax) {\n            result.max = result.min + result.majorUnit;\n        } else if (!userSetMin && userSetMax) {\n            result.min = result.max - result.majorUnit;\n        }\n    }\n\n    return result;\n}\n\nfunction remainderClose(value, divisor, ratio) {\n    var remainder = round(Math.abs(value % divisor), DEFAULT_PRECISION);\n    var threshold = divisor * (1 - ratio);\n\n    return remainder === 0 || remainder > threshold;\n}\n\nsetDefaultOptions(NumericAxis, {\n    type: \"numeric\",\n    min: 0,\n    max: 1,\n    vertical: true,\n    majorGridLines: {\n        visible: true,\n        width: 1,\n        color: BLACK\n    },\n    labels: {\n        format: \"#.####################\"\n    },\n    zIndex: 1\n});\n\nvar MIN_VALUE_RANGE = 1000;\n\nvar DateValueAxis = Axis.extend({\n    init: function(seriesMin, seriesMax, axisOptions, chartService) {\n        var min = toDate(seriesMin);\n        var max = toDate(seriesMax);\n\n        var intlService = chartService.intl;\n        var options = axisOptions || {};\n        options = deepExtend(options || {}, {\n            min: parseDate(intlService, options.min),\n            max: parseDate(intlService, options.max),\n            axisCrossingValue: parseDates(intlService, options.axisCrossingValues || options.axisCrossingValue),\n            weekStartDay: firstDay(options, intlService)\n        });\n        options = applyDefaults(min, max, options);\n\n        Axis.fn.init.call(this, options, chartService);\n\n        this.intlService = intlService;\n        this.seriesMin = min;\n        this.seriesMax = max;\n\n        var weekStartDay = options.weekStartDay || 0;\n        this.totalMin = toTime(floorDate(toTime(min) - 1, options.baseUnit, weekStartDay));\n        this.totalMax = toTime(ceilDate(toTime(max) + 1, options.baseUnit, weekStartDay));\n    },\n\n    clone: function() {\n        return new DateValueAxis(this.seriesMin, this.seriesMax, $.extend({}, this.options), this.chartService);\n    },\n\n    range: function() {\n        var options = this.options;\n        return { min: options.min, max: options.max };\n    },\n\n    getDivisions: function(stepValue) {\n        var options = this.options;\n\n        return Math.floor(\n            duration(options.min, options.max, options.baseUnit) / stepValue + 1\n        );\n    },\n\n    getTickPositions: function(step) {\n        var options = this.options;\n        var ref = this.lineInfo();\n        var dir = ref.axisDir;\n        var lineSize = ref.lineSize;\n        var start = ref.lineStart;\n        var divisions = this.getDivisions(step);\n        var timeRange = dateDiff(options.max, options.min);\n        var scale = lineSize / timeRange;\n        var weekStartDay = options.weekStartDay || 0;\n\n        var positions = [ start ];\n        for (var i = 1; i < divisions; i++) {\n            var date = addDuration(options.min, i * step, options.baseUnit, weekStartDay);\n            var pos = start + dateDiff(date, options.min) * scale * dir;\n\n            positions.push(round(pos, COORD_PRECISION));\n        }\n\n        return positions;\n    },\n\n    getMajorTickPositions: function() {\n        return this.getTickPositions(this.options.majorUnit);\n    },\n\n    getMinorTickPositions: function() {\n        return this.getTickPositions(this.options.minorUnit);\n    },\n\n    getSlot: function(a, b, limit) {\n        return NumericAxis.prototype.getSlot.call(\n            this, parseDate(this.intlService, a), parseDate(this.intlService, b), limit\n        );\n    },\n\n    getValue: function(point) {\n        var value = NumericAxis.prototype.getValue.call(this, point);\n\n        return value !== null ? toDate(value) : null;\n    },\n\n    labelsCount: function() {\n        return this.getDivisions(this.options.majorUnit);\n    },\n\n    createAxisLabel: function(index, labelOptions, labelContext) {\n        var options = this.options;\n        var offset = index * options.majorUnit;\n        var weekStartDay = options.weekStartDay || 0;\n        var date = options.min;\n\n        if (offset > 0) {\n            date = addDuration(date, offset, options.baseUnit, weekStartDay);\n        }\n\n        var unitFormat = labelOptions.dateFormats[options.baseUnit];\n        labelOptions.format = labelOptions.format || unitFormat;\n\n        var text = this.axisLabelText(date, labelOptions, labelContext);\n        return new AxisLabel(date, text, index, null, labelOptions);\n    },\n\n    translateRange: function(delta) {\n        var options = this.options;\n        var lineBox = this.lineBox();\n        var vertical = options.vertical;\n        var reverse = options.reverse;\n        var size = vertical ? lineBox.height() : lineBox.width();\n        var range = this.range();\n        var scale = size / dateDiff(range.max, range.min);\n\n        var offset = round(delta / scale, DEFAULT_PRECISION);\n        if ((vertical || reverse) && !(vertical && reverse )) {\n            offset = -offset;\n        }\n\n        var from = addTicks(options.min, offset);\n        var to = addTicks(options.max, offset);\n\n        return {\n            min: from,\n            max: to,\n            offset: offset\n        };\n    },\n\n    shouldRenderNote: function(value) {\n        var range = this.range();\n\n        return dateComparer(value, range.min) >= 0 && dateComparer(value, range.max) <= 0;\n    },\n\n    pan: function(delta) {\n        var range = this.translateRange(delta, true);\n        var limittedRange = this.limitRange(toTime(range.min), toTime(range.max), this.totalMin, this.totalMax, range.offset);\n\n        if (limittedRange) {\n            return {\n                min: toDate(limittedRange.min),\n                max: toDate(limittedRange.max)\n            };\n        }\n    },\n\n    pointsRange: function(start, end) {\n        var startValue = this.getValue(start);\n        var endValue = this.getValue(end);\n        var min = Math.min(startValue, endValue);\n        var max = Math.max(startValue, endValue);\n\n        return {\n            min: toDate(min),\n            max: toDate(max)\n        };\n    },\n\n    scaleRange: function(scale, cursor) {\n        var position = Math.abs(this.pointOffset(cursor));\n        var range = this.options.max - this.options.min;\n        var delta = this.scaleToDelta(scale, range);\n        var minDelta = position * delta;\n        var maxDelta = (1 - position) * delta;\n        var min = toDate(toTime(this.options.min) + minDelta);\n        var max = toDate(toTime(this.options.max) - maxDelta);\n\n        if (max - min < MIN_VALUE_RANGE) {\n            max = toDate(toTime(min) + MIN_VALUE_RANGE);\n        }\n\n        return {\n            min: min,\n            max: max\n        };\n    },\n\n    zoomRange: function(scale, cursor) {\n        var range = this.scaleRange(scale, cursor);\n        var min = toDate(limitValue(toTime(range.min), this.totalMin, this.totalMax));\n        var max = toDate(limitValue(toTime(range.max), this.totalMin, this.totalMax));\n\n        return {\n            min: min,\n            max: max\n        };\n    }\n});\n\nfunction timeUnits(delta) {\n    var unit = HOURS;\n\n    if (delta >= TIME_PER_YEAR) {\n        unit = YEARS;\n    } else if (delta >= TIME_PER_MONTH) {\n        unit = MONTHS;\n    } else if (delta >= TIME_PER_WEEK) {\n        unit = WEEKS;\n    } else if (delta >= TIME_PER_DAY) {\n        unit = DAYS;\n    }\n\n    return unit;\n}\n\nfunction applyDefaults(seriesMin, seriesMax, options) {\n    var min = options.min || seriesMin;\n    var max = options.max || seriesMax;\n    var baseUnit = options.baseUnit || (max && min ? timeUnits(absoluteDateDiff(max, min)) : HOURS);\n    var baseUnitTime = TIME_PER_UNIT[baseUnit];\n    var weekStartDay = options.weekStartDay || 0;\n    var autoMin = floorDate(toTime(min) - 1, baseUnit, weekStartDay) || toDate(max);\n    var autoMax = ceilDate(toTime(max) + 1, baseUnit, weekStartDay);\n    var userMajorUnit = options.majorUnit ? options.majorUnit : undefined;\n    var majorUnit = userMajorUnit || ceil(\n        autoMajorUnit(autoMin.getTime(), autoMax.getTime()),\n        baseUnitTime\n    ) / baseUnitTime;\n    var actualUnits = duration(autoMin, autoMax, baseUnit);\n    var totalUnits = ceil(actualUnits, majorUnit);\n    var unitsToAdd = totalUnits - actualUnits;\n    var head = Math.floor(unitsToAdd / 2);\n    var tail = unitsToAdd - head;\n\n    if (!options.baseUnit) {\n        delete options.baseUnit;\n    }\n\n    options.baseUnit = options.baseUnit || baseUnit;\n    options.min = options.min || addDuration(autoMin, -head, baseUnit, weekStartDay);\n    options.max = options.max || addDuration(autoMax, tail, baseUnit, weekStartDay);\n    options.minorUnit = options.minorUnit || majorUnit / 5;\n    options.majorUnit = majorUnit;\n\n    return options;\n}\n\nsetDefaultOptions(DateValueAxis, {\n    type: DATE,\n    majorGridLines: {\n        visible: true,\n        width: 1,\n        color: BLACK\n    },\n    labels: {\n        dateFormats: DateLabelFormats\n    }\n});\n\nvar DEFAULT_MAJOR_UNIT = 10;\nvar MIN_VALUE_RANGE$2 = 1e-6;\n\nvar LogarithmicAxis = Axis.extend({\n    init: function(seriesMin, seriesMax, options, chartService) {\n\n        var axisOptions = deepExtend({ majorUnit: DEFAULT_MAJOR_UNIT, min: seriesMin, max: seriesMax }, options);\n        var base = axisOptions.majorUnit;\n        var autoMax = autoAxisMax$1(seriesMax, base);\n        var autoMin = autoAxisMin$1(seriesMin, seriesMax, axisOptions);\n        var range = initRange(autoMin, autoMax, axisOptions, options);\n\n        axisOptions.max = range.max;\n        axisOptions.min = range.min;\n        axisOptions.minorUnit = options.minorUnit || round(base - 1, DEFAULT_PRECISION);\n\n        Axis.fn.init.call(this, axisOptions, chartService);\n\n        this.totalMin = defined(options.min) ? Math.min(autoMin, options.min) : autoMin;\n        this.totalMax = defined(options.max) ? Math.max(autoMax, options.max) : autoMax;\n        this.logMin = round(log(range.min, base), DEFAULT_PRECISION);\n        this.logMax = round(log(range.max, base), DEFAULT_PRECISION);\n        this.seriesMin = seriesMin;\n        this.seriesMax = seriesMax;\n\n        this.createLabels();\n    },\n\n    clone: function() {\n        return new LogarithmicAxis(\n            this.seriesMin,\n            this.seriesMax,\n            $.extend({}, this.options),\n            this.chartService\n        );\n    },\n\n    startValue: function() {\n        return this.options.min;\n    },\n\n    getSlot: function(a, b, limit) {\n        var ref = this;\n        var options = ref.options;\n        var logMin = ref.logMin;\n        var logMax = ref.logMax;\n        var base = options.majorUnit;\n        var min = options.min;\n        var max = options.max;\n        var ref$1 = this.lineInfo();\n        var axis = ref$1.axis;\n        var axisDir = ref$1.axisDir;\n        var lineBox = ref$1.lineBox;\n        var lineSize = ref$1.lineSize;\n        var lineStart = ref$1.lineStart;\n        var step = axisDir * (lineSize / (logMax - logMin));\n        var start = valueOrDefault(a, b || 1);\n        var end = valueOrDefault(b, a || 1);\n\n        if (start <= 0 || end <= 0) {\n            return null;\n        }\n\n        if (limit) {\n            start = limitValue(start, min, max);\n            end = limitValue(end, min, max);\n        }\n\n        start = log(start, base);\n        end = log(end, base);\n\n        var p1 = Math.min(start, end) - logMin;\n        var p2 = Math.max(start, end) - logMin;\n\n        var slotBox = new Box(lineBox.x1, lineBox.y1, lineBox.x1, lineBox.y1);\n        slotBox[axis + 1] = limitCoordinate(lineStart + step * (axisDir > 0 ? p1 : p2));\n        slotBox[axis + 2] = limitCoordinate(lineStart + step * (axisDir > 0 ? p2 : p1));\n\n        return slotBox;\n    },\n\n    getValue: function(point) {\n        var ref = this;\n        var options = ref.options;\n        var logMin = ref.logMin;\n        var logMax = ref.logMax;\n        var base = options.majorUnit;\n        var ref$1 = this.lineInfo();\n        var axis = ref$1.axis;\n        var axisDir = ref$1.axisDir;\n        var lineStart = ref$1.lineStart;\n        var lineSize = ref$1.lineSize;\n        var step = ((logMax - logMin) / lineSize);\n        var offset = axisDir * (point[axis] - lineStart);\n        var valueOffset = offset * step;\n\n        if (offset < 0 || offset > lineSize) {\n            return null;\n        }\n\n        var value = logMin + valueOffset;\n\n        return round(Math.pow(base, value), DEFAULT_PRECISION);\n    },\n\n    range: function() {\n        var options = this.options;\n        return { min: options.min, max: options.max };\n    },\n\n    translateRange: function(delta) {\n        var ref = this;\n        var options = ref.options;\n        var logMin = ref.logMin;\n        var logMax = ref.logMax;\n        var reverse = options.reverse;\n        var vertical = options.vertical;\n        var base = options.majorUnit;\n        var lineBox = this.lineBox();\n        var size = vertical ? lineBox.height() : lineBox.width();\n        var scale = size / (logMax - logMin);\n        var offset = round(delta / scale, DEFAULT_PRECISION);\n\n        if ((vertical || reverse) && !(vertical && reverse )) {\n            offset = -offset;\n        }\n\n        return {\n            min: Math.pow(base, logMin + offset),\n            max: Math.pow(base, logMax + offset),\n            offset: offset\n        };\n    },\n\n    labelsCount: function() {\n        var floorMax = Math.floor(this.logMax);\n        var count = Math.floor(floorMax - this.logMin) + 1;\n\n        return count;\n    },\n\n    getMajorTickPositions: function() {\n        var ticks = [];\n\n        this.traverseMajorTicksPositions(function (position) {\n            ticks.push(position);\n        }, { step: 1, skip: 0 });\n\n        return ticks;\n    },\n\n    createTicks: function(lineGroup) {\n        var options = this.options;\n        var majorTicks = options.majorTicks;\n        var minorTicks = options.minorTicks;\n        var vertical = options.vertical;\n        var mirror = options.labels.mirror;\n        var lineBox = this.lineBox();\n        var ticks = [];\n        var tickLineOptions = {\n            // TODO\n            // _alignLines: options._alignLines,\n            vertical: vertical\n        };\n\n        function render(tickPosition, tickOptions) {\n            tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;\n            tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;\n            tickLineOptions.position = tickPosition;\n\n            lineGroup.append(createAxisTick(tickLineOptions, tickOptions));\n        }\n\n        if (majorTicks.visible) {\n            this.traverseMajorTicksPositions(render, majorTicks);\n        }\n\n        if (minorTicks.visible) {\n            this.traverseMinorTicksPositions(render, minorTicks);\n        }\n\n        return ticks;\n    },\n\n    createGridLines: function(altAxis) {\n        var options = this.options;\n        var minorGridLines = options.minorGridLines;\n        var majorGridLines = options.majorGridLines;\n        var vertical = options.vertical;\n        var lineBox = altAxis.lineBox();\n        var lineOptions = {\n            lineStart: lineBox[vertical ? \"x1\" : \"y1\"],\n            lineEnd: lineBox[vertical ? \"x2\" : \"y2\"],\n            vertical: vertical\n        };\n        var majorTicks = [];\n\n        var container = this.gridLinesVisual();\n        function render(tickPosition, gridLine) {\n            if (!inArray(tickPosition, majorTicks)) {\n                lineOptions.position = tickPosition;\n                container.append(createAxisGridLine(lineOptions, gridLine));\n\n                majorTicks.push(tickPosition);\n            }\n        }\n\n        if (majorGridLines.visible) {\n            this.traverseMajorTicksPositions(render, majorGridLines);\n        }\n\n        if (minorGridLines.visible) {\n            this.traverseMinorTicksPositions(render, minorGridLines);\n        }\n\n        return container.children;\n    },\n\n    traverseMajorTicksPositions: function(callback, tickOptions) {\n        var ref = this.lineInfo();\n        var lineStart = ref.lineStart;\n        var step = ref.step;\n        var ref$1 = this;\n        var logMin = ref$1.logMin;\n        var logMax = ref$1.logMax;\n\n        for (var power = Math.ceil(logMin) + tickOptions.skip; power <= logMax; power += tickOptions.step) {\n            var position = round(lineStart + step * (power - logMin), DEFAULT_PRECISION);\n            callback(position, tickOptions);\n        }\n    },\n\n    traverseMinorTicksPositions: function(callback, tickOptions) {\n        var this$1$1 = this;\n\n        var ref = this.options;\n        var min = ref.min;\n        var max = ref.max;\n        var minorUnit = ref.minorUnit;\n        var base = ref.majorUnit;\n        var ref$1 = this.lineInfo();\n        var lineStart = ref$1.lineStart;\n        var step = ref$1.step;\n        var ref$2 = this;\n        var logMin = ref$2.logMin;\n        var logMax = ref$2.logMax;\n        var start = Math.floor(logMin);\n\n        for (var power = start; power < logMax; power++) {\n            var minorOptions = this$1$1._minorIntervalOptions(power);\n            for (var idx = tickOptions.skip; idx < minorUnit; idx += tickOptions.step) {\n                var value = minorOptions.value + idx * minorOptions.minorStep;\n                if (value > max) {\n                    break;\n                }\n                if (value >= min) {\n                    var position = round(lineStart + step * (log(value, base) - logMin), DEFAULT_PRECISION);\n                    callback(position, tickOptions);\n                }\n            }\n        }\n    },\n\n    createAxisLabel: function(index, labelOptions, labelContext) {\n        var power = Math.ceil(this.logMin + index);\n        var value = Math.pow(this.options.majorUnit, power);\n        var text = this.axisLabelText(value, labelOptions, labelContext);\n\n        return new AxisLabel(value, text, index, null, labelOptions);\n    },\n\n    shouldRenderNote: function(value) {\n        var range = this.range();\n        return range.min <= value && value <= range.max;\n    },\n\n    pan: function(delta) {\n        var range = this.translateRange(delta);\n        return this.limitRange(range.min, range.max, this.totalMin, this.totalMax, range.offset);\n    },\n\n    pointsRange: function(start, end) {\n        var startValue = this.getValue(start);\n        var endValue = this.getValue(end);\n        var min = Math.min(startValue, endValue);\n        var max = Math.max(startValue, endValue);\n\n        return {\n            min: min,\n            max: max\n        };\n    },\n\n    scaleRange: function(scale, cursor) {\n        var ref = this.options;\n        var base = ref.majorUnit;\n        var logMin = log(this.options.min, base);\n        var logMax = log(this.options.max, base);\n        var position = Math.abs(this.pointOffset(cursor));\n        var range = logMax - logMin;\n        var delta = this.scaleToDelta(scale, range);\n        var min = Math.pow(base, logMin + position * delta);\n        var max = Math.pow(base, logMax - (1 - position) * delta);\n\n        if (max - min < MIN_VALUE_RANGE$2) {\n            max = min + MIN_VALUE_RANGE$2;\n        }\n\n        return {\n            min: min,\n            max: max\n        };\n    },\n\n    zoomRange: function(scale, cursor) {\n        var range = this.scaleRange(scale, cursor);\n        var ref = this;\n        var totalMin = ref.totalMin;\n        var totalMax = ref.totalMax;\n\n        return {\n            min: limitValue(range.min, totalMin, totalMax),\n            max: limitValue(range.max, totalMin, totalMax)\n        };\n    },\n\n    _minorIntervalOptions: function(power) {\n        var ref = this.options;\n        var minorUnit = ref.minorUnit;\n        var base = ref.majorUnit;\n        var value = Math.pow(base, power);\n        var nextValue = Math.pow(base, power + 1);\n        var difference = nextValue - value;\n        var minorStep = difference / minorUnit;\n\n        return {\n            value: value,\n            minorStep: minorStep\n        };\n    },\n\n    lineInfo: function() {\n        var info = Axis.fn.lineInfo.call(this);\n        info.step = info.axisDir * (info.lineSize / (this.logMax - this.logMin));\n\n        return info;\n    }\n});\n\nfunction initRange(autoMin, autoMax, axisOptions, options) {\n    var min = axisOptions.min;\n    var max = axisOptions.max;\n\n    if (defined(axisOptions.axisCrossingValue) && axisOptions.axisCrossingValue <= 0) {\n        throwNegativeValuesError();\n    }\n\n    if (!defined(options.max)) {\n        max = autoMax;\n    } else if (options.max <= 0) {\n        throwNegativeValuesError();\n    }\n\n    if (!defined(options.min)) {\n        min = autoMin;\n    } else if (options.min <= 0) {\n        throwNegativeValuesError();\n    }\n\n    return {\n        min: min,\n        max: max\n    };\n}\n\nfunction autoAxisMin$1(min, max, options) {\n    var base = options.majorUnit;\n    var autoMin = min;\n    if (min <= 0) {\n        autoMin = max <= 1 ? Math.pow(base, -2) : 1;\n    } else if (!options.narrowRange) {\n        autoMin = Math.pow(base, Math.floor(log(min, base)));\n    }\n    return autoMin;\n}\n\nfunction autoAxisMax$1(max, base) {\n    var logMaxRemainder = round(log(max, base), DEFAULT_PRECISION) % 1;\n    var autoMax;\n    if (max <= 0) {\n        autoMax = base;\n    } else if (logMaxRemainder !== 0 && (logMaxRemainder < 0.3 || logMaxRemainder > 0.9)) {\n        autoMax = Math.pow(base, log(max, base) + 0.2);\n    } else {\n        autoMax = Math.pow(base, Math.ceil(log(max, base)));\n    }\n\n    return autoMax;\n}\n\nfunction throwNegativeValuesError() {\n    throw new Error(\"Non positive values cannot be used for a logarithmic axis\");\n}\n\nfunction log(x, base) {\n    return Math.log(x) / Math.log(base);\n}\n\nsetDefaultOptions(LogarithmicAxis, {\n    type: \"log\",\n    majorUnit: DEFAULT_MAJOR_UNIT,\n    minorUnit: 1,\n    axisCrossingValue: 1,\n    vertical: true,\n    majorGridLines: {\n        visible: true,\n        width: 1,\n        color: BLACK\n    },\n    zIndex: 1,\n    _deferLabels: true\n});\n\nvar GridLinesMixin = {\n    createGridLines: function(altAxis) {\n        var options = this.options;\n        var radius = Math.abs(this.box.center().y - altAxis.lineBox().y1);\n        var gridLines = [];\n        var skipMajor = false;\n        var majorAngles, minorAngles;\n\n        if (options.majorGridLines.visible) {\n            majorAngles = this.majorGridLineAngles(altAxis);\n            skipMajor = true;\n\n            gridLines = this.renderMajorGridLines(\n                majorAngles, radius, options.majorGridLines\n            );\n        }\n\n        if (options.minorGridLines.visible) {\n            minorAngles = this.minorGridLineAngles(altAxis, skipMajor);\n\n            append(gridLines, this.renderMinorGridLines(\n                minorAngles, radius, options.minorGridLines, altAxis, skipMajor\n            ));\n        }\n\n        return gridLines;\n    },\n\n    renderMajorGridLines: function(angles, radius, options) {\n        return this.renderGridLines(angles, radius, options);\n    },\n\n    renderMinorGridLines: function(angles, radius, options, altAxis, skipMajor) {\n        var radiusCallback = this.radiusCallback && this.radiusCallback(radius, altAxis, skipMajor);\n        return this.renderGridLines(angles, radius, options, radiusCallback);\n    },\n\n    renderGridLines: function(angles, radius, options, radiusCallback) {\n        var style = {\n            stroke: {\n                width: options.width,\n                color: options.color,\n                dashType: options.dashType\n            }\n        };\n\n        var center = this.box.center();\n        var circle = new Circle([ center.x, center.y ], radius);\n        var container = this.gridLinesVisual();\n\n        for (var i = 0; i < angles.length; i++) {\n            var line = new Path(style);\n            if (radiusCallback) {\n                circle.radius = radiusCallback(angles[i]);\n            }\n\n            line.moveTo(circle.center)\n                .lineTo(circle.pointAt(angles[i] + 180));\n\n            container.append(line);\n        }\n\n        return container.children;\n    },\n\n    gridLineAngles: function(altAxis, size, skip, step, skipAngles) {\n        var this$1$1 = this;\n\n        var divs = this.intervals(size, skip, step, skipAngles);\n        var options = altAxis.options;\n        var altAxisVisible = options.visible && (options.line || {}).visible !== false;\n\n        return map(divs, function (d) {\n            var alpha = this$1$1.intervalAngle(d);\n\n            if (!altAxisVisible || alpha !== 90) {\n                return alpha;\n            }\n        });\n    }\n};\n\nvar RadarCategoryAxis = CategoryAxis.extend({\n    range: function() {\n        return { min: 0, max: this.options.categories.length };\n    },\n\n    reflow: function(box) {\n        this.box = box;\n        this.reflowLabels();\n    },\n\n    lineBox: function() {\n        return this.box;\n    },\n\n    reflowLabels: function() {\n        var this$1$1 = this;\n\n        var ref = this;\n        var labels = ref.labels;\n        var labelOptions = ref.options.labels;\n        var skip = labelOptions.skip || 0;\n        var step = labelOptions.step || 1;\n        var measureBox = new Box();\n\n        for (var i = 0; i < labels.length; i++) {\n            labels[i].reflow(measureBox);\n            var labelBox = labels[i].box;\n\n            labels[i].reflow(this$1$1.getSlot(skip + i * step).adjacentBox(\n                0, labelBox.width(), labelBox.height()\n            ));\n        }\n    },\n\n    intervals: function(size, skipOption, stepOption, skipAngles) {\n        if (skipAngles === void 0) { skipAngles = false; }\n\n        var options = this.options;\n        var categories = options.categories.length;\n        var divCount = categories / size || 1;\n        var divAngle = 360 / divCount;\n        var skip = skipOption || 0;\n        var step = stepOption || 1;\n        var divs = [];\n        var angle = 0;\n\n        for (var i = skip; i < divCount; i += step) {\n            if (options.reverse) {\n                angle = 360 - i * divAngle;\n            } else {\n                angle = i * divAngle;\n            }\n\n            angle = round(angle, COORD_PRECISION) % 360;\n\n            if (!(skipAngles && inArray(angle, skipAngles))) {\n                divs.push(angle);\n            }\n        }\n\n        return divs;\n    },\n\n    majorIntervals: function() {\n        return this.intervals(1);\n    },\n\n    minorIntervals: function() {\n        return this.intervals(0.5);\n    },\n\n    intervalAngle: function(interval) {\n        return (360 + interval + this.options.startAngle) % 360;\n    },\n\n    majorAngles: function() {\n        var this$1$1 = this;\n\n        return map(this.majorIntervals(), function (interval) { return this$1$1.intervalAngle(interval); });\n    },\n\n    createLine: function() {\n        return [];\n    },\n\n    majorGridLineAngles: function(altAxis) {\n        var majorGridLines = this.options.majorGridLines;\n        return this.gridLineAngles(altAxis, 1, majorGridLines.skip, majorGridLines.step);\n    },\n\n    minorGridLineAngles: function(altAxis, skipMajor) {\n        var ref = this.options;\n        var minorGridLines = ref.minorGridLines;\n        var majorGridLines = ref.majorGridLines;\n        var majorGridLineAngles = skipMajor ? this.intervals(1, majorGridLines.skip, majorGridLines.step) : null;\n\n        return this.gridLineAngles(altAxis, 0.5, minorGridLines.skip, minorGridLines.step, majorGridLineAngles);\n    },\n\n    radiusCallback: function(radius, altAxis, skipMajor) {\n        if (altAxis.options.type !== ARC) {\n            var minorAngle = rad(360 / (this.options.categories.length * 2));\n            var minorRadius = Math.cos(minorAngle) * radius;\n            var majorAngles = this.majorAngles();\n\n            var radiusCallback = function(angle) {\n                if (!skipMajor && inArray(angle, majorAngles)) {\n                    return radius;\n                }\n\n                return minorRadius;\n            };\n            return radiusCallback;\n        }\n    },\n\n    createPlotBands: function() {\n        var this$1$1 = this;\n\n        var plotBands = this.options.plotBands || [];\n\n        var group = this._plotbandGroup = new Group({\n            zIndex: -1\n        });\n\n        for (var i = 0; i < plotBands.length; i++) {\n            var band = plotBands[i];\n            var slot = this$1$1.plotBandSlot(band);\n            var singleSlot = this$1$1.getSlot(band.from);\n\n            var head = band.from - Math.floor(band.from);\n            slot.startAngle += head * singleSlot.angle;\n\n            var tail = Math.ceil(band.to) - band.to;\n            slot.angle -= (tail + head) * singleSlot.angle;\n\n            var ring = ShapeBuilder.current.createRing(slot, {\n                fill: {\n                    color: band.color,\n                    opacity: band.opacity\n                },\n                stroke: {\n                    opacity: band.opacity\n                }\n            });\n            group.append(ring);\n        }\n\n        this.appendVisual(group);\n    },\n\n    plotBandSlot: function(band) {\n        return this.getSlot(band.from, band.to - 1);\n    },\n\n    getSlot: function(from, to) {\n        var options = this.options;\n        var justified = options.justified;\n        var box = this.box;\n        var divs = this.majorAngles();\n        var totalDivs = divs.length;\n        var slotAngle = 360 / totalDivs;\n        var fromValue = from;\n\n        if (options.reverse && !justified) {\n            fromValue = (fromValue + 1) % totalDivs;\n        }\n\n        fromValue = limitValue(Math.floor(fromValue), 0, totalDivs - 1);\n        var slotStart = divs[fromValue];\n\n        if (justified) {\n            slotStart = slotStart - slotAngle / 2;\n\n            if (slotStart < 0) {\n                slotStart += 360;\n            }\n        }\n\n        var toValue = limitValue(Math.ceil(to || fromValue), fromValue, totalDivs - 1);\n        var slots = toValue - fromValue + 1;\n        var angle = slotAngle * slots;\n\n        return new Ring(box.center(), 0, box.height() / 2, slotStart, angle);\n    },\n\n    slot: function(from, to) {\n        var slot = this.getSlot(from, to);\n        var startAngle = slot.startAngle + 180;\n        var endAngle = startAngle + slot.angle;\n\n        return new geometry.Arc([ slot.center.x, slot.center.y ], {\n            startAngle: startAngle,\n            endAngle: endAngle,\n            radiusX: slot.radius,\n            radiusY: slot.radius\n        });\n    },\n\n    pointCategoryIndex: function(point) {\n        var this$1$1 = this;\n\n        var length = this.options.categories.length;\n        var index = null;\n\n        for (var i = 0; i < length; i++) {\n            var slot = this$1$1.getSlot(i);\n            if (slot.containsPoint(point)) {\n                index = i;\n                break;\n            }\n        }\n\n        return index;\n    }\n});\n\nsetDefaultOptions(RadarCategoryAxis, {\n    startAngle: 90,\n    labels: {\n        margin: getSpacing(10)\n    },\n    majorGridLines: {\n        visible: true\n    },\n    justified: true\n});\ndeepExtend(RadarCategoryAxis.prototype, GridLinesMixin);\n\nvar PolarAxis = Axis.extend({\n    init: function(options, chartService) {\n        Axis.fn.init.call(this, options, chartService);\n\n        var instanceOptions = this.options;\n\n        instanceOptions.minorUnit = instanceOptions.minorUnit || instanceOptions.majorUnit / 2;\n    },\n\n    getDivisions: function(stepValue) {\n        return NumericAxis.prototype.getDivisions.call(this, stepValue) - 1;\n    },\n\n    reflow: function(box) {\n        this.box = box;\n        this.reflowLabels();\n    },\n\n    reflowLabels: function() {\n        var this$1$1 = this;\n\n        var ref = this;\n        var options = ref.options;\n        var labels = ref.labels;\n        var labelOptions = ref.options.labels;\n        var skip = labelOptions.skip || 0;\n        var step = labelOptions.step || 1;\n\n        var measureBox = new Box();\n        var divs = this.intervals(options.majorUnit, skip, step);\n\n        for (var i = 0; i < labels.length; i++) {\n            labels[i].reflow(measureBox);\n            var labelBox = labels[i].box;\n\n            labels[i].reflow(this$1$1.getSlot(divs[i]).adjacentBox(0, labelBox.width(), labelBox.height()));\n        }\n    },\n\n    lineBox: function() {\n        return this.box;\n    },\n\n    intervals: function(size, skipOption, stepOption, skipAngles) {\n        if (skipAngles === void 0) { skipAngles = false; }\n\n        var min = this.options.min;\n        var divisions = this.getDivisions(size);\n        var divs = [];\n        var skip = skipOption || 0;\n        var step = stepOption || 1;\n\n        for (var i = skip; i < divisions; i += step) {\n            var current = (360 + min + i * size) % 360;\n            if (!(skipAngles && inArray(current, skipAngles))) {\n                divs.push(current);\n            }\n        }\n\n        return divs;\n    },\n\n    majorIntervals: function() {\n        return this.intervals(this.options.majorUnit);\n    },\n\n    minorIntervals: function() {\n        return this.intervals(this.options.minorUnit);\n    },\n\n    intervalAngle: function(i) {\n        return (540 - i - this.options.startAngle) % 360;\n    },\n\n    createLine: function() {\n        return [];\n    },\n\n    majorGridLineAngles: function(altAxis) {\n        var majorGridLines = this.options.majorGridLines;\n        return this.gridLineAngles(altAxis, this.options.majorUnit, majorGridLines.skip, majorGridLines.step);\n    },\n\n    minorGridLineAngles: function(altAxis, skipMajor) {\n        var options = this.options;\n        var minorGridLines = options.minorGridLines;\n        var majorGridLines = options.majorGridLines;\n        var majorGridLineAngles = skipMajor ? this.intervals(options.majorUnit, majorGridLines.skip, majorGridLines.step) : null;\n\n        return this.gridLineAngles(altAxis, options.minorUnit, minorGridLines.skip, minorGridLines.step, majorGridLineAngles);\n    },\n\n    plotBandSlot: function(band) {\n        return this.getSlot(band.from, band.to);\n    },\n\n    getSlot: function(a, b) {\n        var ref = this;\n        var options = ref.options;\n        var box = ref.box;\n        var startAngle = options.startAngle;\n        var start = limitValue(a, options.min, options.max);\n        var end = limitValue(b || start, start, options.max);\n\n        if (options.reverse) {\n            start *= -1;\n            end *= -1;\n        }\n\n        start = (540 - start - startAngle) % 360;\n        end = (540 - end - startAngle) % 360;\n\n        if (end < start) {\n            var tmp = start;\n            start = end;\n            end = tmp;\n        }\n\n        return new Ring(box.center(), 0, box.height() / 2, start, end - start);\n    },\n\n    slot: function(from, to) {\n        if (to === void 0) { to = from; }\n\n        var options = this.options;\n        var start = 360 - options.startAngle;\n        var slot = this.getSlot(from, to);\n        var min = Math.min(from, to);\n        var max = Math.max(from, to);\n        var startAngle, endAngle;\n\n        if (options.reverse) {\n            startAngle = min;\n            endAngle = max;\n        } else {\n            startAngle = 360 - max;\n            endAngle = 360 - min;\n        }\n\n        startAngle = (startAngle + start) % 360;\n        endAngle = (endAngle + start) % 360;\n\n        return new geometry.Arc([ slot.center.x, slot.center.y ], {\n            startAngle: startAngle,\n            endAngle: endAngle,\n            radiusX: slot.radius,\n            radiusY: slot.radius\n        });\n    },\n\n    getValue: function(point) {\n        var options = this.options;\n        var center = this.box.center();\n        var dx = point.x - center.x;\n        var dy = point.y - center.y;\n        var theta = Math.round(deg(Math.atan2(dy, dx)));\n        var start = options.startAngle;\n\n        if (!options.reverse) {\n            theta *= -1;\n            start *= -1;\n        }\n\n        return (theta + start + 360) % 360;\n    },\n\n    valueRange: function() {\n        return {\n            min: 0,\n            max: Math.PI * 2\n        };\n    }\n});\n\nsetDefaultOptions(PolarAxis, {\n    type: \"polar\",\n    startAngle: 0,\n    reverse: false,\n    majorUnit: 60,\n    min: 0,\n    max: 360,\n    labels: {\n        margin: getSpacing(10)\n    },\n    majorGridLines: {\n        color: BLACK,\n        visible: true,\n        width: 1\n    },\n    minorGridLines: {\n        color: \"#aaa\"\n    }\n});\n\ndeepExtend(PolarAxis.prototype, GridLinesMixin, {\n    createPlotBands: RadarCategoryAxis.prototype.createPlotBands,\n    majorAngles: RadarCategoryAxis.prototype.majorAngles,\n    range: NumericAxis.prototype.range,\n    labelsCount: NumericAxis.prototype.labelsCount,\n    createAxisLabel: NumericAxis.prototype.createAxisLabel\n});\n\nvar RadarNumericAxisMixin = {\n    options: {\n        majorGridLines: {\n            visible: true\n        }\n    },\n\n    createPlotBands: function() {\n        var this$1$1 = this;\n\n        var ref = this.options;\n        var type = ref.majorGridLines.type;\n        var plotBands = ref.plotBands; if (plotBands === void 0) { plotBands = []; }\n        var altAxis = this.plotArea.polarAxis;\n        var majorAngles = altAxis.majorAngles();\n        var center = altAxis.box.center();\n        var group = this._plotbandGroup = new Group({\n            zIndex: -1\n        });\n\n        for (var i = 0; i < plotBands.length; i++) {\n            var band = plotBands[i];\n            var bandStyle = {\n                fill: {\n                    color: band.color,\n                    opacity: band.opacity\n                },\n                stroke: {\n                    opacity: band.opacity\n                }\n            };\n\n            var slot = this$1$1.getSlot(band.from, band.to, true);\n            var ring = new Ring(center, center.y - slot.y2, center.y - slot.y1, 0, 360);\n\n            var shape = (void 0);\n            if (type === ARC) {\n                shape = ShapeBuilder.current.createRing(ring, bandStyle);\n            } else {\n                shape = Path.fromPoints(this$1$1.plotBandPoints(ring, majorAngles), bandStyle).close();\n            }\n\n            group.append(shape);\n        }\n\n        this.appendVisual(group);\n    },\n\n    plotBandPoints: function(ring, angles) {\n        var innerPoints = [];\n        var outerPoints = [];\n        var center = [ ring.center.x, ring.center.y ];\n        var innerCircle = new Circle(center, ring.innerRadius);\n        var outerCircle = new Circle(center, ring.radius);\n\n        for (var i = 0; i < angles.length; i++) {\n            innerPoints.push(innerCircle.pointAt(angles[i] + 180));\n            outerPoints.push(outerCircle.pointAt(angles[i] + 180));\n        }\n\n        innerPoints.reverse();\n        innerPoints.push(innerPoints[0]);\n        outerPoints.push(outerPoints[0]);\n\n        return outerPoints.concat(innerPoints);\n    },\n\n    createGridLines: function(altAxis) {\n        var options = this.options;\n        var majorTicks = this.radarMajorGridLinePositions();\n        var majorAngles = altAxis.majorAngles();\n        var center = altAxis.box.center();\n        var gridLines = [];\n\n        if (options.majorGridLines.visible) {\n            gridLines = this.renderGridLines(\n                center, majorTicks, majorAngles, options.majorGridLines\n            );\n        }\n\n        if (options.minorGridLines.visible) {\n            var minorTicks = this.radarMinorGridLinePositions();\n            append(gridLines, this.renderGridLines(\n                center, minorTicks, majorAngles, options.minorGridLines\n            ));\n        }\n\n        return gridLines;\n    },\n\n    renderGridLines: function(center, ticks, angles, options) {\n        var style = {\n            stroke: {\n                width: options.width,\n                color: options.color,\n                dashType: options.dashType\n            }\n        };\n        var skip = options.skip; if (skip === void 0) { skip = 0; }\n        var step = options.step; if (step === void 0) { step = 0; }\n        var container = this.gridLinesVisual();\n\n        for (var tickIx = skip; tickIx < ticks.length; tickIx += step) {\n            var tickRadius = center.y - ticks[tickIx];\n            if (tickRadius > 0) {\n                var circle = new Circle([ center.x, center.y ], tickRadius);\n                if (options.type === ARC) {\n                    container.append(new drawing.Circle(circle, style));\n                } else {\n                    var line = new Path(style);\n                    for (var angleIx = 0; angleIx < angles.length; angleIx++) {\n                        line.lineTo(circle.pointAt(angles[angleIx] + 180));\n                    }\n\n                    line.close();\n                    container.append(line);\n                }\n            }\n        }\n\n        return container.children;\n    },\n\n    getValue: function(point) {\n        var lineBox = this.lineBox();\n        var altAxis = this.plotArea.polarAxis;\n        var majorAngles = altAxis.majorAngles();\n        var center = altAxis.box.center();\n        var radius = point.distanceTo(center);\n        var distance = radius;\n\n        if (this.options.majorGridLines.type !== ARC && majorAngles.length > 1) {\n            var dx = point.x - center.x;\n            var dy = point.y - center.y;\n            var theta = (deg(Math.atan2(dy, dx)) + 540) % 360;\n\n            majorAngles.sort(function(a, b) {\n                return angularDistance(a, theta) - angularDistance(b, theta);\n            });\n\n            // Solve triangle (center, point, axis X) using one side (radius) and two angles.\n            // Angles are derived from triangle (center, point, gridline X)\n            var midAngle = angularDistance(majorAngles[0], majorAngles[1]) / 2;\n            var alpha = angularDistance(theta, majorAngles[0]);\n            var gamma = 90 - midAngle;\n            var beta = 180 - alpha - gamma;\n\n            distance = radius * (Math.sin(rad(beta)) / Math.sin(rad(gamma)));\n        }\n\n        return this.axisType().prototype.getValue.call(\n            this, new Point(lineBox.x1, lineBox.y2 - distance)\n        );\n    }\n};\n\nfunction angularDistance(a, b) {\n    return 180 - Math.abs(Math.abs(a - b) - 180);\n}\n\nvar RadarNumericAxis = NumericAxis.extend({\n    radarMajorGridLinePositions: function() {\n        return this.getTickPositions(this.options.majorUnit);\n    },\n\n    radarMinorGridLinePositions: function() {\n        var options = this.options;\n        var minorSkipStep = 0;\n\n        if (options.majorGridLines.visible) {\n            minorSkipStep = options.majorUnit;\n        }\n        return this.getTickPositions(options.minorUnit, minorSkipStep);\n    },\n\n    axisType: function() {\n        return NumericAxis;\n    }\n});\n\ndeepExtend(RadarNumericAxis.prototype, RadarNumericAxisMixin);\n\nvar RadarLogarithmicAxis = LogarithmicAxis.extend({\n    radarMajorGridLinePositions: function() {\n        var positions = [];\n\n        this.traverseMajorTicksPositions(function(position) {\n            positions.push(position);\n        }, this.options.majorGridLines);\n\n        return positions;\n    },\n\n    radarMinorGridLinePositions: function() {\n        var positions = [];\n\n        this.traverseMinorTicksPositions(function(position) {\n            positions.push(position);\n        }, this.options.minorGridLines);\n\n        return positions;\n    },\n\n    axisType: function() {\n        return LogarithmicAxis;\n    }\n});\n\ndeepExtend(RadarLogarithmicAxis.prototype, RadarNumericAxisMixin);\n\nvar WEIGHT = 0.333;\nvar EXTREMUM_ALLOWED_DEVIATION = 0.01;\n\nvar CurveProcessor = Class.extend({\n    init: function(closed) {\n\n        this.closed = closed;\n    },\n\n    process: function(dataPoints) {\n        var this$1$1 = this;\n\n        var points = dataPoints.slice(0);\n        var segments = [];\n        var closed = this.closed;\n        var length = points.length;\n\n        if (length > 2) {\n            this.removeDuplicates(0, points);\n            length = points.length;\n        }\n\n        if (length < 2 || (length === 2 && points[0].equals(points[1]))) {\n            return segments;\n        }\n\n        var p0 = points[0];\n        var p1 = points[1];\n        var p2 = points[2];\n\n        segments.push(new Segment(p0));\n\n        while (p0.equals(points[length - 1])) {\n            closed = true;\n            points.pop();\n            length--;\n        }\n\n        if (length === 2) {\n            var tangent = this.tangent(p0,p1, X, Y);\n\n            last(segments).controlOut(\n                this.firstControlPoint(tangent, p0, p1, X, Y)\n            );\n\n            segments.push(new Segment(\n                p1,\n                this.secondControlPoint(tangent, p0, p1, X, Y)\n            ));\n\n            return segments;\n        }\n\n        var initialControlPoint, lastControlPoint;\n\n        if (closed) {\n            p0 = points[length - 1]; p1 = points[0]; p2 = points[1];\n            var controlPoints = this.controlPoints(p0, p1, p2);\n            initialControlPoint = controlPoints[1];\n            lastControlPoint = controlPoints[0];\n        } else {\n            var tangent$1 = this.tangent(p0, p1, X,Y);\n            initialControlPoint = this.firstControlPoint(tangent$1, p0, p1, X, Y);\n        }\n\n        var cp0 = initialControlPoint;\n        for (var idx = 0; idx <= length - 3; idx++) {\n            this$1$1.removeDuplicates(idx, points);\n            length = points.length;\n            if (idx + 3 <= length) {\n                p0 = points[idx]; p1 = points[idx + 1]; p2 = points[idx + 2];\n                var controlPoints$1 = this$1$1.controlPoints(p0,p1,p2);\n\n                last(segments).controlOut(cp0);\n                cp0 = controlPoints$1[1];\n\n                var cp1 = controlPoints$1[0];\n                segments.push(new Segment(p1, cp1));\n            }\n        }\n\n        if (closed) {\n            p0 = points[length - 2]; p1 = points[length - 1]; p2 = points[0];\n            var controlPoints$2 = this.controlPoints(p0, p1, p2);\n\n            last(segments).controlOut(cp0);\n            segments.push(new Segment(\n                p1,\n                controlPoints$2[0]\n            ));\n\n            last(segments).controlOut(controlPoints$2[1]);\n            segments.push(new Segment(\n                p2,\n                lastControlPoint\n            ));\n        } else {\n            var tangent$2 = this.tangent(p1, p2, X, Y);\n\n            last(segments).controlOut(cp0);\n            segments.push(new Segment(\n                p2,\n                this.secondControlPoint(tangent$2, p1, p2, X, Y)\n            ));\n        }\n\n        return segments;\n    },\n\n    removeDuplicates: function(idx, points) {\n        while (points[idx + 1] && (points[idx].equals(points[idx + 1]) || points[idx + 1].equals(points[idx + 2]))) {\n            points.splice(idx + 1, 1);\n        }\n    },\n\n    invertAxis: function(p0, p1, p2) {\n        var invertAxis = false;\n\n        if (p0.x === p1.x) {\n            invertAxis = true;\n        } else if (p1.x === p2.x) {\n            if ((p1.y < p2.y && p0.y <= p1.y) || (p2.y < p1.y && p1.y <= p0.y)) {\n                invertAxis = true;\n            }\n        } else {\n            var fn = this.lineFunction(p0,p1);\n            var y2 = this.calculateFunction(fn, p2.x);\n            if (!(p0.y <= p1.y && p2.y <= y2) &&\n                !(p1.y <= p0.y && p2.y >= y2)) {\n                invertAxis = true;\n            }\n        }\n\n        return invertAxis;\n    },\n\n    isLine: function(p0, p1, p2) {\n        var fn = this.lineFunction(p0, p1);\n        var y2 = this.calculateFunction(fn, p2.x);\n\n        return (p0.x === p1.x && p1.x === p2.x) || round(y2, 1) === round(p2.y, 1);\n    },\n\n    lineFunction: function(p1, p2) {\n        var a = (p2.y - p1.y) / (p2.x - p1.x);\n        var b = p1.y - a * p1.x;\n\n        return [ b, a ];\n    },\n\n    controlPoints: function(p0, p1, p2) {\n        var xField = X;\n        var yField = Y;\n        var restrict = false;\n        var switchOrientation = false;\n        var tangent;\n\n        if (this.isLine(p0, p1, p2)) {\n            tangent = this.tangent(p0, p1, X, Y);\n        } else {\n            var monotonic = {\n                x: this.isMonotonicByField(p0, p1, p2, X),\n                y: this.isMonotonicByField(p0, p1, p2, Y)\n            };\n\n            if (monotonic.x && monotonic.y) {\n                tangent = this.tangent(p0, p2, X, Y);\n                restrict = true;\n            } else {\n                if (this.invertAxis(p0, p1, p2)) {\n                    xField = Y;\n                    yField = X;\n                }\n\n                if (monotonic[xField]) {\n                    tangent = 0;\n                } else {\n                    var sign;\n                    if ((p2[yField] < p0[yField] && p0[yField] <= p1[yField]) ||\n                        (p0[yField] < p2[yField] && p1[yField] <= p0[yField])) {\n                        sign = numberSign((p2[yField] - p0[yField]) * (p1[xField] - p0[xField]));\n                    } else {\n                        sign = -numberSign((p2[xField] - p0[xField]) * (p1[yField] - p0[yField]));\n                    }\n\n                    tangent = EXTREMUM_ALLOWED_DEVIATION * sign;\n                    switchOrientation = true;\n                }\n            }\n        }\n\n        var secondControlPoint = this.secondControlPoint(tangent, p0, p1, xField, yField);\n\n        if (switchOrientation) {\n            var oldXField = xField;\n            xField = yField;\n            yField = oldXField;\n        }\n\n        var firstControlPoint = this.firstControlPoint(tangent, p1, p2, xField, yField);\n\n        if (restrict) {\n            this.restrictControlPoint(p0, p1, secondControlPoint, tangent);\n            this.restrictControlPoint(p1, p2, firstControlPoint, tangent);\n        }\n\n        return [ secondControlPoint, firstControlPoint ];\n    },\n\n    restrictControlPoint: function(p1, p2, cp, tangent) {\n        if (p1.y < p2.y) {\n            if (p2.y < cp.y) {\n                cp.x = p1.x + (p2.y - p1.y) / tangent;\n                cp.y = p2.y;\n            } else if (cp.y < p1.y) {\n                cp.x = p2.x - (p2.y - p1.y) / tangent;\n                cp.y = p1.y;\n            }\n        } else {\n            if (cp.y < p2.y) {\n                cp.x = p1.x - (p1.y - p2.y) / tangent;\n                cp.y = p2.y;\n            } else if (p1.y < cp.y) {\n                cp.x = p2.x + (p1.y - p2.y) / tangent;\n                cp.y = p1.y;\n            }\n        }\n    },\n\n    tangent: function(p0, p1, xField, yField) {\n        var x = p1[xField] - p0[xField];\n        var y = p1[yField] - p0[yField];\n        var tangent;\n\n        if (x === 0) {\n            tangent = 0;\n        } else {\n            tangent = y / x;\n        }\n\n        return tangent;\n    },\n\n    isMonotonicByField: function(p0, p1, p2, field) {\n        return (p2[field] > p1[field] && p1[field] > p0[field]) ||\n                    (p2[field] < p1[field] && p1[field] < p0[field]);\n    },\n\n    firstControlPoint: function(tangent, p0, p3, xField, yField) {\n        var t1 = p0[xField];\n        var t2 = p3[xField];\n        var distance = (t2 - t1) * WEIGHT;\n\n        return this.point(t1 + distance, p0[yField] + distance * tangent, xField, yField);\n    },\n\n    secondControlPoint: function(tangent, p0, p3, xField, yField) {\n        var t1 = p0[xField];\n        var t2 = p3[xField];\n        var distance = (t2 - t1) * WEIGHT;\n\n        return this.point(t2 - distance, p3[yField] - distance * tangent, xField, yField);\n    },\n\n    point: function(xValue, yValue, xField, yField) {\n        var controlPoint = new geometry.Point();\n        controlPoint[xField] = xValue;\n        controlPoint[yField] = yValue;\n\n        return controlPoint;\n    },\n\n    calculateFunction: function(fn, x) {\n        var length = fn.length;\n        var result = 0;\n\n        for (var i = 0; i < length; i++) {\n            result += Math.pow(x,i) * fn[i];\n        }\n        return result;\n    }\n});\n\nfunction numberSign(value) {\n    return value <= 0 ? -1 : 1;\n}\n\ndataviz.Gradients = GRADIENTS;\n\nkendo.deepExtend(kendo.dataviz, {\n    constants: constants,\n    services: services,\n    autoMajorUnit: autoMajorUnit,\n    Point: Point,\n    Box: Box,\n    Ring: Ring,\n    Sector: Sector,\n    ShapeBuilder: ShapeBuilder,\n    ShapeElement: ShapeElement,\n    ChartElement: ChartElement,\n    BoxElement: BoxElement,\n    RootElement: RootElement,\n    FloatElement: FloatElement,\n    Text: Text,\n    TextBox: TextBox,\n    Title: Title,\n    AxisLabel: AxisLabel,\n    Axis: Axis,\n    Note: Note,\n    CategoryAxis: CategoryAxis,\n    DateCategoryAxis: DateCategoryAxis,\n    DateValueAxis: DateValueAxis,\n    NumericAxis: NumericAxis,\n    LogarithmicAxis: LogarithmicAxis,\n    PolarAxis: PolarAxis,\n    RadarCategoryAxis: RadarCategoryAxis,\n    RadarNumericAxis: RadarNumericAxis,\n    RadarLogarithmicAxis: RadarLogarithmicAxis,\n    CurveProcessor: CurveProcessor,\n    rectToBox: rectToBox,\n    addClass: addClass,\n    removeClass: removeClass,\n    alignPathToPixel: alignPathToPixel,\n    clockwise: clockwise,\n    convertableToNumber: convertableToNumber,\n    cycleUp: cycleUp,\n    cycleDown: cycleDown,\n    cycleIndex: cycleIndex,\n    deepExtend: deepExtend,\n    elementStyles: elementStyles,\n    getSpacing: getSpacing,\n    getTemplate: getTemplate,\n    getAriaTemplate: getTemplate$1,\n    getter: __common_getter_js,\n    grep: grep,\n    hasClasses: hasClasses,\n    HashMap: HashMap,\n    inArray: inArray,\n    interpolateValue: interpolateValue,\n    InstanceObserver: InstanceObserver,\n    isArray: isArray,\n    isFunction: isFunction,\n    isNumber: isNumber,\n    isObject: isObject,\n    isPlainObject: isPlainObject,\n    isString: isString,\n    map: map,\n    mousewheelDelta: mousewheelDelta,\n    FontLoader: FontLoader,\n    renderIcon: renderIcon,\n    setDefaultOptions: setDefaultOptions,\n    sparseArrayLimits: sparseArrayLimits,\n    styleValue: styleValue,\n    find: find,\n    elementScale: elementScale,\n    autoTextColor: autoTextColor,\n    createHashSet: createHashSet,\n    defaultErrorHandler: defaultErrorHandler,\n    keys: keys,\n    hasOwnProperty: hasOwnProperty,\n    Matrix: Matrix$1,\n    Observable: Observable$$1,\n    append: append,\n    bindEvents: bindEvents,\n    Class: Class,\n    defined: defined,\n    deg: deg,\n    elementOffset: elementOffset,\n    elementSize: elementSize,\n    eventCoordinates: eventCoordinates,\n    eventElement: eventElement,\n    hashKey: hashKey,\n    last: last,\n    limitValue: limitValue,\n    logToConsole: kendo.logToConsole,\n    objectKey: objectKey,\n    rad: rad,\n    round: round,\n    unbindEvents: unbindEvents,\n    valueOrDefault: valueOrDefault,\n    absoluteDateDiff: absoluteDateDiff,\n    addDuration: addDuration,\n    addTicks: addTicks,\n    ceilDate: ceilDate,\n    dateComparer: dateComparer,\n    dateDiff: dateDiff,\n    dateEquals: dateEquals,\n    dateIndex: dateIndex,\n    duration: duration,\n    floorDate: floorDate,\n    lteDateIndex: lteDateIndex,\n    startOfWeek: startOfWeek,\n    toDate: toDate,\n    parseDate: parseDate,\n    parseDates: parseDates,\n    toTime: toTime,\n    firstDay: firstDay\n});\n\n})(window.kendo.jQuery);\n\n(function($) {\n\n    var dataviz = kendo.dataviz;\n    var services = dataviz.services;\n    var draw = kendo.drawing;\n\n    dataviz.SASS_THEMES = [\"sass\", \"default-v2\", \"bootstrap-v4\", \"material-v2\"];\n\n    dataviz.ExportMixin = {\n        extend: function(proto, skipLegacy) {\n            if (!proto.exportVisual) {\n                throw new Error(\"Mixin target has no exportVisual method defined.\");\n            }\n\n            proto.exportSVG = this.exportSVG;\n            proto.exportImage = this.exportImage;\n            proto.exportPDF = this.exportPDF;\n\n            if (!skipLegacy) {\n                proto.svg = this.svg;\n                proto.imageDataURL = this.imageDataURL;\n            }\n        },\n\n        exportSVG: function(options) {\n            return draw.exportSVG(this.exportVisual(), options);\n        },\n\n        exportImage: function(options) {\n            return draw.exportImage(this.exportVisual(options), options);\n        },\n\n        exportPDF: function(options) {\n            return draw.exportPDF(this.exportVisual(), options);\n        },\n\n        svg: function() {\n            if (draw.svg.Surface) {\n                return draw.svg.exportGroup(this.exportVisual());\n            } else {\n                throw new Error(\"SVG Export failed. Unable to export instantiate kendo.drawing.svg.Surface\");\n            }\n        },\n\n        imageDataURL: function() {\n            if (!kendo.support.canvas) {\n                return null;\n            }\n\n            if (draw.canvas.Surface) {\n                var container = $(\"<div />\").css({\n                    display: \"none\",\n                    width: this.element.width(),\n                    height: this.element.height()\n                }).appendTo(document.body);\n\n                var surface = new draw.canvas.Surface(container[0]);\n                surface.draw(this.exportVisual());\n                var image = surface._rootElement.toDataURL();\n\n                surface.destroy();\n                container.remove();\n\n                return image;\n            } else {\n                throw new Error(\"Image Export failed. Unable to export instantiate kendo.drawing.canvas.Surface\");\n            }\n        }\n    };\n\n    services.IntlService.register({\n       format: function(format) {\n           return kendo.format.apply(null, [format].concat(Array.prototype.slice.call(arguments, 1)));\n       },\n       toString: kendo.toString,\n       parseDate: kendo.parseDate,\n       firstDay: function() {\n           return kendo.culture().calendars.standard.firstDay;\n       }\n    });\n\n    services.TemplateService.register({\n       compile: kendo.template\n    });\n\n    dataviz.Point2D = dataviz.Point;\n    dataviz.Box2D = dataviz.Box;\n    dataviz.mwDelta = function(e) {\n        return dataviz.mousewheelDelta(e.originalEvent);\n    };\n\n})(window.kendo.jQuery);\n\nvar __meta__ = {\n    id: \"dataviz.core\",\n    name: \"Core\",\n    description: \"The DataViz core functions\",\n    category: \"dataviz\",\n    depends: [ \"core\", \"drawing\" ],\n    hidden: true\n};\n\nvar kendo$1 = kendo;\n\nexport { kendo$1 as default };\n"]}