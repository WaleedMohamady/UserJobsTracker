{"version":3,"sources":["raw-mjs/kendo.dataviz.gauge.js"],"names":["$","window","kendo","dataviz","getSpacing","defined","constants","BLACK","COORD_PRECISION","services","deepExtend","isArray","setDefaultOptions","NumericAxis","limitValue","Box","interpolateValue","round","drawing","DrawingGroup","Group","DrawingPath","Path","Animation","AnimationFactory","geometry","Rect","GeometryPoint","Point","transform","ANGULAR_SPEED","ARROW_POINTER","BAR_POINTER","DEFAULT_LINE_WIDTH","DEGREE","Math","PI","INSIDE","LINEAR","OUTSIDE","RADIAL_POINTER","RADIAL_RANGE_POINTER","pad","bbox","value","origin","getOrigin","size","getSize","spacing","setOrigin","x","left","y","top","setSize","width","right","height","bottom","Path$1","Text","buildLabelElement","label","options","labelBox","box","textBox","children","border","background","wrapper","fromRect","x1","y1","stroke","text","font","fill","color","styleGeometry","clone","padding","styleBox","opacity","dashType","lineJoin","lineCap","elements","append","getRange","range","min","max","from","MIN_VALUE","to","MAX_VALUE","unpad","Surface","Gauge","Class","extend","init","element","userOptions","theme","context","this","contextService","ChartService","_originalOptions","_initTheme","redraw","destroy","surface","surfaceElement","pointerValue","pointer","pointers","arguments","length","_setValueOptions","_draw","clear","draw","_visuals","exportVisual","allValues","values","i","push","i$1","isNumber","concat","arrayValues","resize","noTransitionsRedraw","transitions","_toggleTransitions","_surfaceSize","_initSurface","gaugeArea","_createGaugeArea","_createModel","_gaugeAreaMargin","reflow","setOptions","setDirection","rtl","Boolean","type","setIntlService","intl","currentTheme","areaGeometry","margin","_surfaceElement","elementSize","renderAs","create","_getSize","document","createElement","appendChild","defaultSize","_defaultSize","offsetWidth","offsetHeight","animation","plotArea","scale","Path$2","Group$2","renderAxisTick","tickRenderOptions","tickOptions","start","end","position","tickX","tickY","vertical","moveTo","lineTo","renderTicks","tickGroup","tickPositions","count","visible","mirror","lineBox","skip","step","skipUnit","x2","LinearScale","service","scaleOptions","reverse","fn","call","minorUnit","majorUnit","initUserOptions","labels","autoMajorUnit","initFields","render","renderLabels","scaleLine","renderLine","scaleTicks","ranges","renderRanges","this$1$1","rangeSize","minorTicks","slot","getSlot","slotX","slotY","y2","line","linePath","ticks","majorTicks","getMajorTickPositions","getMinorTickPositions","align","_alignLines","Pointer","ref","newValue","_oldValue","repaint","LinearPointer","track","pointerBox","pointerRangeBox","trackBox","ref$1","trackSize","pointerHalfSize","space","shape","getElementOptions","_margin","ArrowLinearPointerAnimation","setup","axis","fromScale","toScale","duration","distanceTo","pos","translateX","translateY","translate","easing","current","register","Point$1","Path$3","ArrowLinearPointer","pointerShape","halfSize","sign","play","elementOptions","close","BarLinearPointerAnimation","Y","X","newPoints","oldPoints","abs","speed","_set","setter","toUpperCase","points","Group$3","Path$4","BarLinearPointer","dir","minSlot","sizeAxis","p1","p2","p3","p4","pointerPath","oldShape","group","renderTrack","trackOptions","toRect","Group$1","LinearGauge","bboxX","bboxY","_shrinkScaleWidth","_getBox","_alignElements","_shrinkElements","_buildVisual","visuals","scaleElements","currentOptions","pointerType","boxCenter","center","plotAreaBox","wrap","diff","scaleBox","overflow","contentBox","shrink","alignTo","GEO_ARC_ADJUST_ANGLE","Arc","Path$5","Group$5","drawTicks","arc","tickAngles","unit","radius","getRadiusX","tickStart","pointAt","tickEnd","rotate","rangeSegment","RadialScale","renderArc","labelElements","repositionRanges","slotAngle","startAngle","endAngle","angle","hasRanges","ticksSize","labelsCount","labelsGroup","rangeDistance","labelsOptions","isInside","hasLabelElements","setRadiusX","setRadiusY","paddingWidth","paddingHeight","halfWidth","halfHeight","labelAngle","lp","cx","cos","cy","sin","labelPos","labelElement","prevLabelPos","labelTransform","union","rangeRadius","getRangeRadius","newRadius","_geometry","segments","rangeSegments","segmentsCount","result","segment","createRange","rangeGeom","radiusX","radiusY","defaultColor","rangePlaceholderColor","j","majorTickSize","tickArc","majorTickAngles","allTicks","minorTickSize","_tickDifference","minorTickAngles","normalizeTickAngles","angles","splice","ring","stepValue","tickCount","positions","repositionTicks","minor","newPoint","xDiff","anchor","yDiff","RadialPointerAnimation","animationOptions","newAngle","oldAngle","Circle","Group$6","Path$6","RadialPointer","setAngle","_renderNeedle","_renderCap","capSize","cap","fromPoints","needleColor","needlePath","capColor","circle","arrow","Group$4","RadialGauge","_initialPlotArea","fitScale","alignScale","_buildPointers","minDiff","midDiff","maxDiff","mid","oldDiff","getDiff","staleFlag","getPlotBox","scaleArc","plotBbox","plotBox","plotBoxCenter","paddingX","paddingY","pointersArr","ArcScale","rangeLineCap","placeholderRangeAngle","geometry$$1","setEndAngle","setStartAngle","addRange","RangePointerAnimation","startColor","get","currentColor","Color","r","g","b","toHex","RangePointer","abort","colors","currentValue","idx","ref$2","rangeColor","ArcGauge","centerLabelPosition","yLimit","bottomRight","CircularGauge","jQuery","Widget","ui","themeOptions","themes","themeName","lowerName","toLowerCase","SASS_THEMES","indexOf","autoTheme","gauge","empty","_createInstance","addClass","notify","_instance","_copyFields","gaugeType","_gaugeType","_resize","proxyMembers","createProxyMember","name","apply","ExportMixin","RadialGaugeWidget","LinearGaugeWidget","ArcGaugeWidget","css","_centerTemplate","instance","_centerElement","centerTemplate","template","centerElement","_getCenterElement","html","remove","CircularGaugeWidget","createExportMethod","method","drawDOM","then","visual","exportMethods","plugin","__meta__","id","category","description","depends","kendo$1"],"mappings":";;;;;;;;MAAA,wBACA,yBACA,2BACA,gCACA,6BASA,SAAAA,GAGAC,OAAAC,MAAAC,QAAAF,OAAAC,MAAAC,SAAA,CAAA,EACA,IAAAA,EAAAD,MAAAC,QACAC,EAAAD,EAAAC,WACAC,EAAAF,EAAAE,QACAC,EAAAH,EAAAG,UACAC,EAAAD,EAAAC,MACAC,EAAAF,EAAAE,gBACAC,EAAAN,EAAAM,SACAC,EAAAP,EAAAO,WACAC,EAAAR,EAAAQ,QACAC,EAAAT,EAAAS,kBACAC,EAAAV,EAAAU,YACAC,EAAAX,EAAAW,WACAC,EAAAZ,EAAAY,IACAC,EAAAb,EAAAa,iBACAC,EAAAd,EAAAc,MACAC,EAAAhB,MAAAgB,QACAC,EAAAD,EAAAE,MACAC,EAAAH,EAAAI,KACAC,EAAAL,EAAAK,UACAC,EAAAN,EAAAM,iBACAC,EAAAvB,MAAAuB,SACAC,EAAAD,EAAAC,KACAC,EAAAF,EAAAG,MACAC,EAAAJ,EAAAI,UAEAC,EAAA,IAGAC,EAAA,eACAC,EAAA,aAEAC,EAAA,GAEAC,EAAAC,KAAAC,GAAA,IACAC,EAAA,SACAC,EAAA,SACAC,EAAA,UACAC,EAAA,gBACAC,EAAA,qBAEA,SAAAC,EAAAC,EAAAC,GACA,IAAAC,EAAAF,EAAAG,YACAC,EAAAJ,EAAAK,UACAC,EAAA7C,EAAAwC,GAKA,OAHAD,EAAAO,UAAA,CAAAL,EAAAM,EAAAF,EAAAG,KAAAP,EAAAQ,EAAAJ,EAAAK,MACAX,EAAAY,QAAA,CAAAR,EAAAS,OAAAP,EAAAG,KAAAH,EAAAQ,OAAAV,EAAAW,QAAAT,EAAAK,IAAAL,EAAAU,UAEAhB,CACA,CAEA,IAAAvB,EAAAD,EACAyC,EAAAvC,EACAwC,EAAA3C,EAAA2C,KAEA,SAAAC,EAAAC,EAAAC,GACA,IAAAC,EAAAF,EAAAG,IACAC,EAAAJ,EAAAK,SAAA,GAAAF,IACAG,EAAAL,EAAAK,QAAA,CAAA,EACAC,EAAAN,EAAAM,YAAA,GAEAC,EAAAX,EAAAY,SAAA,IAAA9C,EAAA,CAAAuC,EAAAQ,GAAAR,EAAAS,IAAA,CAAAT,EAAAT,QAAAS,EAAAP,WAAA,CACAiB,OAAA,CAAA,IAGAC,EAAA,IAAAf,EAAAE,EAAAa,KAAA,IAAAjD,EAAAwC,EAAAM,GAAAN,EAAAO,IAAA,CACAG,KAAAb,EAAAa,KACAC,KAAA,CAAAC,MAAAf,EAAAe,SAGAC,EAAAtC,EAAAkC,EAAAjC,OAAAsC,QAAAjB,EAAAkB,SAEAC,EAAAvB,EAAAY,SAAAQ,EAAA,CACAL,OAAA,CACAI,MAAAV,EAAAb,MAAAa,EAAAU,MAAA,GACAvB,MAAAa,EAAAb,MACA4B,QAAAf,EAAAe,QACAC,SAAAhB,EAAAgB,SACAC,SAAA,QACAC,QAAA,SAEAT,KAAA,CACAC,MAAAT,KAIAkB,EAAA,IAAApE,EAKA,OAJAoE,EAAAC,OAAAlB,GACAiB,EAAAC,OAAAN,GACAK,EAAAC,OAAAb,GAEAY,CACA,CAEA,SAAAE,EAAAC,EAAAC,EAAAC,GACA,IAAAC,EAAAzF,EAAAsF,EAAAG,MAAAH,EAAAG,KAAAxF,EAAAyF,UACAC,EAAA3F,EAAAsF,EAAAK,IAAAL,EAAAK,GAAA1F,EAAA2F,UAKA,OAHAN,EAAAG,KAAA3D,KAAA0D,IAAA1D,KAAAyD,IAAAI,EAAAF,GAAAF,GACAD,EAAAK,GAAA7D,KAAAyD,IAAAzD,KAAA0D,IAAAG,EAAAF,GAAAD,GAEAF,CACA,CAEA,SAAAO,EAAAvD,EAAAC,GACA,IAAAK,EAAA7C,EAAAwC,GAKA,OAHAK,EAAAG,MAAAH,EAAAG,KAAAH,EAAAK,KAAAL,EAAAK,IACAL,EAAAQ,OAAAR,EAAAQ,MAAAR,EAAAU,QAAAV,EAAAU,OAEAjB,EAAAC,EAAAM,EACA,CAEA,IACA3B,EAAAD,EACA8E,EAAAjF,EAAAiF,QAEAC,EAAAjG,EAAAkG,MAAAC,OAAA,CACAC,KAAA,SAAAC,EAAAC,EAAAC,EAAAC,QACA,IAAAA,IAAAA,EAAA,CAAA,GAEAC,KAAAJ,QAAAA,EACAI,KAAAF,MAAAA,EACAE,KAAAC,eAAA,IAAApG,EAAAqG,aAAAF,KAAAD,GACAC,KAAAG,iBAAArG,EAAA,CAAA,EAAAkG,KAAA5C,QAAAyC,GACAG,KAAA5C,QAAAtD,EAAA,CAAA,EAAAkG,KAAAG,kBACAH,KAAAI,WAAAN,GAEAE,KAAAK,QACA,EAEAC,QAAA,WACAN,KAAAO,UACAP,KAAAO,QAAAD,UACAN,KAAAO,QAAA,aAGAP,KAAAJ,eACAI,KAAAQ,cACA,EAEAxE,MAAA,SAAAyE,GACA,IAAAC,EAAAV,KAAAW,SAAA,GAEA,GAAA,IAAAC,UAAAC,OACA,OAAAH,EAAA1E,QAGA0E,EAAA1E,MAAAyE,GACAT,KAAAc,iBAAAL,EACA,EAEAM,MAAA,WACA,IAAAR,EAAAP,KAAAO,QAEAA,EAAAS,QACAT,EAAAU,KAAAjB,KAAAkB,SACA,EAEAC,aAAA,WACA,OAAAnB,KAAAkB,QACA,EAEAE,UAAA,SAAAC,GACA,IAAAV,EAAAX,KAAAW,SACAS,EAAA,GAEA,GAAA,IAAAR,UAAAC,OAAA,CACA,IAAA,IAAAS,EAAA,EAAAA,EAAAX,EAAAE,OAAAS,IACAF,EAAAG,KAAAZ,EAAAW,GAAAtF,SAGA,OAAAoF,CACA,CAEA,GAAArH,EAAAsH,GACA,IAAA,IAAAG,EAAA,EAAAA,EAAAH,EAAAR,OAAAW,IACAjI,EAAAkI,SAAAJ,EAAAG,KACAb,EAAAa,GAAAxF,MAAAqF,EAAAG,IAKAxB,KAAAc,iBAAAO,EACA,EAEAP,iBAAA,SAAAO,GAIA,IAHA,IAAAV,EAAA,GAAAe,OAAA1B,KAAA5C,QAAAsD,SACAiB,EAAA,GAAAD,OAAAL,GAEAC,EAAA,EAAAA,EAAAK,EAAAd,OAAAS,IACAX,EAAAW,GAAAtF,MAAA2F,EAAAL,EAEA,EAEAM,OAAA,WACA5B,KAAA6B,qBACA,EAEAA,oBAAA,WACA,IAAAC,EAAA9B,KAAA5C,QAAA0E,YAEA9B,KAAA+B,oBAAA,GAEA/B,KAAAK,SAEAL,KAAA+B,mBAAAD,EACA,EAEAzB,OAAA,WACA,IAAAlE,EAAA6D,KAAAgC,eACArE,EAAA,IAAA7C,EAAA,CAAA,EAAA,GAAA,CAAAqB,EAAAS,MAAAT,EAAAW,SAEAkD,KAAAiC,eAEAjC,KAAAkC,UAAAlC,KAAAmC,mBAEAnC,KAAAoC,eAEA,IAAArG,EAAAuD,EAAA3B,EAAA5B,OAAAiE,KAAAqC,kBACArC,KAAAsC,OAAAvG,EACA,EAEAwG,WAAA,SAAAnF,EAAA0C,GACAE,KAAAG,iBAAArG,EAAAkG,KAAAG,iBAAA/C,GACA4C,KAAA5C,QAAAtD,EAAA,CAAA,EAAAkG,KAAAG,kBAEAH,KAAAI,WAAAN,GAEAE,KAAAK,QACA,EAEAmC,aAAA,SAAAC,GACAzC,KAAAC,eAAAwC,IAAAC,QAAAD,GACAzC,KAAAO,SAAA,QAAAP,KAAAO,QAAAoC,OACA3C,KAAAO,QAAAD,UACAN,KAAAO,QAAA,KAEA,EAEAqC,eAAA,SAAAC,GACA7C,KAAAC,eAAA4C,KAAAA,CACA,EAEAzC,WAAA,SAAAN,GACA,IAAAgD,EAAAhD,GAAAE,KAAAF,OAAA,CAAA,EACAE,KAAAF,MAAAgD,EAEA9C,KAAA5C,QAAAtD,EAAA,CAAA,EAAAgJ,EAAA9C,KAAA5C,SACA,IAAAA,EAAA4C,KAAA5C,QACAsD,EAAAtD,EAAAsD,QAEA,GAAA3G,EAAA2G,GAAA,CAEA,IADA,IAAAC,EAAA,GACAW,EAAA,EAAAA,EAAAZ,EAAAG,OAAAS,IACAX,EAAAY,KAAAzH,EAAA,CAAA,EAAAgJ,EAAApC,QAAAA,EAAAY,KAEAlE,EAAAsD,QAAAC,CACA,CACA,EAEAwB,iBAAA,WACA,IAAA/E,EAAA4C,KAAA5C,QAAA8E,UACA/F,EAAA6D,KAAAO,QAAApE,OACAsB,EAAAL,EAAAK,QAAA,CAAA,EACAsF,EAAA,IAAAjI,EAAA,CAAA,EAAA,GAAA,CAAAqB,EAAAS,MAAAT,EAAAW,SAsBA,OApBAkD,KAAAqC,iBAAAjF,EAAA4F,QA1JA,EA4JAvF,EAAAb,MAAA,IACAmG,EAAAzD,EAAAyD,EAAAtF,EAAAb,QAGAlC,EAAAkD,SAAAmF,EAAA,CACAhF,OAAA,CACAI,MAAAV,EAAAb,MAAAa,EAAAU,MAAA,GACAvB,MAAAa,EAAAb,MACA4B,QAAAf,EAAAe,QACAC,SAAAhB,EAAAgB,SACAC,SAAA,QACAC,QAAA,SAEAT,KAAA,CACAC,MAAAf,EAAAM,aAKA,EAEAuE,aAAA,WACA,IACA7E,EADA4C,KACA5C,QACAmD,EAFAP,KAEAO,QACAX,EAAAI,KAAAiD,kBACA9G,EAAA6D,KAAAgC,eAEAzI,EAAA2J,YAAAtD,EAAAzD,GAEAoE,GAAAA,EAAAnD,QAAAuF,OAAAvF,EAAA+F,UASAnD,KAAAO,QAAAS,QACAhB,KAAAO,QAAAqB,WATArB,GACAA,EAAAD,UAGAN,KAAAO,QAAAhB,EAAA6D,OAAAxD,EAAA,CACA+C,KAAAvF,EAAA+F,WAMA,EAEAnB,aAAA,WACA,IAAA5E,EAAA4C,KAAA5C,QACAjB,EAAA6D,KAAAqD,WAMA,OAJAjG,EAAA8E,WACApI,EAAAqC,EAAAiB,EAAA8E,WAGA/F,CACA,EAEA8G,gBAAA,WAMA,OALAjD,KAAAQ,iBACAR,KAAAQ,eAAA8C,SAAAC,cAAA,OACAvD,KAAAJ,QAAA4D,YAAAxD,KAAAQ,iBAGAR,KAAAQ,cACA,EAEApE,QAAA,WACA,OAAA4D,KAAAqD,UACA,EAEAA,SAAA,WACA,IAAAzD,EAAAI,KAAAJ,QACA6D,EAAAzD,KAAA0D,eACA9G,EAAAgD,EAAA+D,YACA7G,EAAA8C,EAAAgE,aAUA,OARAhH,IACAA,EAAA6G,EAAA7G,OAGAE,IACAA,EAAA2G,EAAA3G,QAGA,CAAAF,MAAAA,EAAAE,OAAAA,EACA,EAEA4G,aAAA,WACA,MAAA,CACA9G,MApUA,IAqUAE,OAvUA,IAyUA,EAEAiF,mBAAA,SAAA/F,GAGAgE,KAAA5C,QAAA0E,YAAA9F,EACA,IAAA,IAAAsF,EAAA,EAAAA,EAAAtB,KAAAW,SAAAE,OAAAS,IAHAtB,KAIAW,SAAAW,GAAAlE,QAAAyG,UAAA/B,YAAA9F,CAEA,IAGAhC,EAAAwF,EAAA,CACAsE,SAAA,CAAA,EACAhE,MAAA,OACAqD,SAAA,GACAzC,QAAA,CAAA,EACAqD,MAAA,CAAA,EACA7B,UAAA,CAAA,IAGA,IAAA8B,EAAAvJ,EACAwJ,EAAA1J,EACAS,EAAAD,EAEA,SAAAmJ,EAAAC,EAAAC,GACA,IAGAC,EAAAC,EAHAC,EAAAJ,EAAAI,SACAC,EAAAL,EAAAK,MACAC,EAAAN,EAAAM,MAkBA,OAfAN,EAAAO,UACAL,EAAA,IAAArJ,EAAAwJ,EAAAD,GACAD,EAAA,IAAAtJ,EAAAwJ,EAAAJ,EAAAjI,KAAAoI,KAEAF,EAAA,IAAArJ,EAAAuJ,EAAAE,GACAH,EAAA,IAAAtJ,EAAAuJ,EAAAE,EAAAL,EAAAjI,OAGA,IAAA6H,EAAA,CACAjG,OAAA,CACAI,MAAAiG,EAAAjG,MACAvB,MAAAwH,EAAAxH,SAEA+H,OAAAN,GAAAO,OAAAN,EAGA,CAEA,SAAAO,EAAAC,EAAAC,EAAAZ,EAAAC,GACA,IAAAY,EAAAD,EAAAlE,OAEA,GAAAuD,EAAAa,QAGA,IAFA,IAAAC,EAAAf,EAAAe,OACAC,EAAAhB,EAAAgB,QACA7D,EAAA8C,EAAAgB,KAAA9D,EAAA0D,EAAA1D,GAAA8C,EAAAiB,KACA/D,EAAA8C,EAAAkB,UAAA,IAIAnB,EAAAK,MAAAU,EAAAC,EAAAI,GAAAJ,EAAAI,GAAAnB,EAAAjI,KACAgI,EAAAM,MAAAS,EAAAC,EAAArH,GAAAsG,EAAAjI,KAAAgJ,EAAArH,GACAqG,EAAAI,SAAAQ,EAAAzD,GAEAwD,EAAAjG,OAAAqF,EAAAC,EAAAC,IAGA,CAEA,IAAAoB,EAAAvL,EAAAyF,OAAA,CACAC,KAAA,SAAAvC,EAAAqI,GACA,IAAAC,EAAAtI,GAAA,CAAA,GACA3D,EAAAiM,EAAAC,WAAA,IAAAD,EAAAhB,WAAAe,GAAA,CAAA,GAAAhD,MACAiD,EAAAtM,EAAAsG,OAAA,CAAA,EAAAgG,EAAA,CACAC,SAAA,KAIA1L,EAAA2L,GAAAjG,KAAAkG,KAAA7F,KAAA,EAAA,EAAA0F,EAAAD,GAEAzF,KAAA5C,QAAA0I,UAAA9F,KAAA5C,QAAA0I,WAAA9F,KAAA5C,QAAA2I,UAAA,EACA,EAEAC,gBAAA,SAAA5I,GACA,IAAAsI,EAAA5L,EAAA,CAAA,EAAAkG,KAAA5C,QAAAA,GAIA,OAHAsI,EAAA5L,EAAA,CAAA,EAAA4L,EAAA,CAAAO,OAAA,CAAAf,OAAAQ,EAAAR,WACAa,UAAAL,EAAAK,WAAAxM,EAAA2M,cAAAR,EAAA1G,IAAA0G,EAAAzG,KAEAyG,CACA,EAEAS,WAAA,WACA,EAEAC,OAAA,WACA,IAAAxH,EAAAoB,KAAApB,SAAA,IAAAqF,EACAgC,EAAAjG,KAAAqG,eACAC,EAAAtG,KAAAuG,aACAC,EAAAxG,KAAA6E,cACA4B,EAAAzG,KAAA0G,eAIA,OAFA9H,EAAAC,OAAAyH,EAAAL,EAAAO,EAAAC,GAEA7H,CACA,EAEA8H,aAAA,WAaA,IAZA,IAAAC,EAAA3G,KAEA5C,EAAA4C,KAAA5C,QACA4B,EAAA5B,EAAA4B,IACAC,EAAA7B,EAAA6B,IACAyF,EAAAtH,EAAAsH,SACAQ,EAAA9H,EAAA6I,OAAAf,OACAuB,EAAArJ,EAAAqJ,QAAA,GACA7H,EAAA,IAAAqF,EACAe,EAAAyB,EAAA5F,OACA+F,EAAAxJ,EAAAwJ,WAAAxJ,EAAAyJ,WAAA1K,KAAA,EAEAmF,EAAA,EAAAA,EAAA0D,EAAA1D,IAAA,CACA,IAAAvC,EAAAD,EAAA2H,EAAAnF,GAAAtC,EAAAC,GACA6H,EAAAH,EAAAI,QAAAhI,EAAAG,KAAAH,EAAAK,IACA4H,EAAAtC,EAAAiC,EAAAxB,UAAA2B,EACAG,EAAAvC,EAAAoC,EAAAH,EAAAxB,UACAT,EACAsC,EAAAnJ,IAAA+I,GAAA1B,GAAA,EAAA,GAEA+B,EAAAC,IAAAN,GAAA1B,GAAA,EAAA,GAGAtG,EAAAC,OAAAmF,EAAApG,SAAA,IAAA9C,EAAA,CAAAkM,EAAAnJ,GAAAoJ,EAAAnJ,IAAA,CAAAkJ,EAAAzB,GAAAyB,EAAAnJ,GAAAoJ,EAAAC,GAAAD,EAAAnJ,KAAA,CACAI,KAAA,CAAAC,MAAAY,EAAAZ,MAAAK,QAAAO,EAAAP,SACAT,OAAA,CAAA,IAEA,CAEA,OAAAa,CACA,EAEAyH,aAAA,WAMA,IALA,IACAJ,EADAjG,KACAiG,OACA7I,EAFA4C,KAEA5C,QACAwB,EAAA,IAAAqF,EAEA3C,EAAA,EAAAA,EAAA2E,EAAApF,OAAAS,IACA1C,EAAAC,OAAA3B,EAAA+I,EAAA3E,GAAAlE,EAAA6I,SAGA,OAAArH,CACA,EAEA2H,WAAA,WACA,IAAAY,EAAAnH,KAAA5C,QAAA+J,KACAhC,EAAAnF,KAAAmF,UACAvG,EAAA,IAAAqF,EAEA,GAAAkD,EAAAvK,MAAA,GAAAuK,EAAAlC,QAAA,CACA,IAAAmC,EAAA,IAAApD,EAAA,CACAjG,OAAA,CACAI,MAAAgJ,EAAAhJ,MACAM,SAAA0I,EAAA1I,SACA7B,MAAAuK,EAAAvK,SAIAwK,EAAAzC,OAAAQ,EAAAtH,GAAAsH,EAAArH,IAAA8G,OAAAO,EAAAI,GAAAJ,EAAA+B,IACAtI,EAAAC,OAAAuI,EACA,CAEA,OAAAxI,CACA,EAEAiG,YAAA,WACA,IAAAwC,EAAA,IAAApD,EACA7G,EAAA4C,KAAA5C,QACA2I,EAAA3I,EAAAkK,WAAArC,QAAA7H,EAAA2I,UAAA,EACA5B,EAAA,CACAO,SAAAtH,EAAAsH,SACAQ,OAAA9H,EAAA6I,OAAAf,OACAC,QAAAnF,KAAAmF,WAQA,OALAN,EAAAwC,EAAArH,KAAAuH,wBAAApD,EAAA/G,EAAAkK,YACAzC,EAAAwC,EAAArH,KAAAwH,wBAAArD,EAAArK,EAAA,CAAA,EAAA,CACAwL,SAAAS,EAAA3I,EAAA0I,WACA1I,EAAAyJ,aAEAQ,CACA,IAGArN,EAAAwL,EAAA,CACAxG,IAAA,EACAC,IAAA,GAEAqI,WAAA,CACAnL,KAAA,GACAsL,MAAAhM,EACA0C,MAAAxE,EACAiD,MAAAvB,EACA4J,SAAA,GAGA4B,WAAA,CACA1K,KAAA,GACAsL,MAAAhM,EACA0C,MAAAxE,EACAiD,MAAAvB,EACA4J,SAAA,GAGAkC,KAAA,CACAvK,MAAAvB,GAGA4K,OAAA,CACA1B,SAAA9I,EACA6C,QAAA,GAEA4G,QAAA,EACAwC,aAAA,IAGA,IAAAC,EAAApO,EAAAkG,MAAAC,OAAA,CACAC,KAAA,SAAAoE,EAAAlE,GAEA,IAAA+H,EAAA7D,EAAA3G,QACA4B,EAAA4I,EAAA5I,IACAC,EAAA2I,EAAA3I,IACA7B,EAAA4C,KAAA5C,QAAAtD,EAAA,CAAA,EAAAkG,KAAA5C,QAAAyC,GAEAzC,EAAAc,KAAAd,EAAAe,MAEA6B,KAAA+D,MAAAA,EAEAtK,EAAA2D,EAAApB,OACAoB,EAAApB,MAAA9B,EAAAkD,EAAApB,MAAAgD,EAAAC,GAEA7B,EAAApB,MAAAgD,CAEA,EAEAhD,MAAA,SAAA6L,GACA,IAAAzK,EAAA4C,KAAA5C,QACApB,EAAAoB,EAAApB,MAEA,GAAA,IAAA4E,UAAAC,OACA,OAAA7E,EAGA,IAAA4L,EAAA5H,KAAA+D,MAAA3G,QACA4B,EAAA4I,EAAA5I,IACAC,EAAA2I,EAAA3I,IAEA7B,EAAA0K,UAAArO,EAAA2D,EAAA0K,WAAA1K,EAAApB,MAAAgD,EACA5B,EAAApB,MAAA9B,EAAA2N,EAAA7I,EAAAC,GAEAe,KAAApB,UACAoB,KAAA+H,SAEA,IAGA/N,EAAA2N,EAAA,CACAxJ,MAAAxE,IAGA,IAAAqO,EAAAL,EAAAjI,OAAA,CACAC,KAAA,SAAAoE,EAAA3G,GACAuK,EAAA/B,GAAAjG,KAAAkG,KAAA7F,KAAA+D,EAAA3G,GAEA4C,KAAA5C,QAAAtD,EAAA,CACAmO,MAAA,CACAhD,QAAAxL,EAAA2D,EAAA6K,SAEAjI,KAAA5C,QACA,EAEAkF,OAAA,WACA,IAaA4F,EAAAC,EAAAC,EAZAhL,EADA4C,KACA5C,QACA2G,EAFA/D,KAEA+D,MACAsE,EAAAtE,EAAA3G,QACA8H,EAAAmD,EAAAnD,OACAR,EAAA2D,EAAA3D,SACA4B,EAAAvC,EAAAoB,UACAmD,EAAAlL,EAAA6K,MAAA9L,MAAAiB,EAAAjB,KACAoM,EAAAnL,EAAAjB,KAAA,EACA6G,EAAAxJ,EAAA4D,EAAA4F,QACAwF,EAAA9D,EACA1B,EAAAkC,EAAA,OAAA,SACAlC,EAAAkC,EAAA,SAAA,OAGAsD,EAAAtD,GAAAsD,EAAAA,EAEA9D,GACA0D,EAAA,IAAAjO,EACAmM,EAAAzI,GAAA2K,EAAAlC,EAAAxI,GACAwI,EAAAzI,GAAA2K,EAAAlC,EAAAY,IAEAhC,EACAkD,EAAAvK,IAAAyK,EAEAF,EAAA7C,IAAA+C,EAGAlL,EAAAqL,QAAArN,IAKA8M,EAJAC,EAAA,IAAAhO,EACAmM,EAAAf,GAAAiD,EAAAlC,EAAAxI,GAAAyK,EACAjC,EAAAf,GAAAiD,EAAAlC,EAAAY,GAAAqB,MAKAH,EAAA,IAAAjO,EACAmM,EAAAzI,GAAAyI,EAAAxI,GAAA0K,EACAlC,EAAAf,GAAAe,EAAAxI,GAAA0K,GAEAtD,EACAkD,EAAAlB,IAAAoB,EAEAF,EAAAtK,IAAAwK,EAGAlL,EAAAqL,QAAArN,IAKA8M,EAJAC,EAAA,IAAAhO,EACAmM,EAAAzI,GAAA0K,EAAAjC,EAAAxI,GAAA0K,EACAlC,EAAAf,GAAAgD,EAAAjC,EAAAxI,GAAA0K,KAMAxI,KAAAoI,SAAAA,EACApI,KAAAmI,gBAAAA,EACAnI,KAAA1C,IAAA4K,GAAAE,EAAA/J,QAAAvC,IAAAsB,EAAAK,OAAAb,MACA,EAEA8L,kBAAA,WACA,IAAAtL,EAAA4C,KAAA5C,QAEA,MAAA,CACAc,KAAA,CACAC,MAAAf,EAAAe,MACAK,QAAApB,EAAAoB,SAEAT,OAAAtE,EAAA2D,EAAAK,QAAA,CACAU,MAAAf,EAAAK,OAAAb,MAAAQ,EAAAK,OAAAU,OAAAf,EAAAe,MAAA,GACAvB,MAAAQ,EAAAK,OAAAb,MACA6B,SAAArB,EAAAK,OAAAgB,SACAD,QAAApB,EAAAoB,SACA,KAEA,EAEAmK,QAAA,WACA,IACA5E,EADA/D,KACA+D,MACA3G,EAFA4C,KAEA5C,QACAiL,EAAAtE,EAAA3G,QACA8H,EAAAmD,EAAAnD,OACAR,EAAA2D,EAAA3D,SACA1B,EAAAxJ,EAAA4D,EAAA4F,QAMA,OAJA0B,EACA1B,EAAAkC,EAAA,OAAA,SACAlC,EAAAkC,EAAA,SAAA,MAGA,IAGAlL,EAAAgO,EAAA,CACAS,MAAArN,EAEA6M,MAAA,CACAxK,OAAA,CACAb,MAAA,IAIAuB,MAAAxE,EACA8D,OAAA,CACAb,MAAA,GAEA4B,QAAA,EAEAwE,OAAAxJ,EAAA,GACAqK,UAAA,CACAlB,KAAAvH,GAEA6J,SAAA,IAGA,IAAA2D,EAAAjO,EAAA+E,OAAA,CACAmJ,MAAA,WACA,IAAAzL,EAAA4C,KAAA5C,QACA4F,EAAA5F,EAAA4F,OACA9D,EAAA9B,EAAA8B,KACAE,EAAAhC,EAAAgC,GACAsF,EAAAtH,EAAAsH,SACAoE,EAAApE,EAAA,KAAA,KAEAtH,EAAA8H,SAAAR,GACAxF,EAAA4J,IAAA9F,EAAA5D,EAAA0J,IAAA9F,IAEA9D,EAAA4J,IAAA9F,EAAA5D,EAAA0J,IAAA9F,GAGA,IAAA+F,EAAA/I,KAAA+I,UAAA,IAAAhO,EAAAmE,EAAArB,GAAAqB,EAAApB,IACAkL,EAAAhJ,KAAAgJ,QAAA,IAAAjO,EAAAqE,EAAAvB,GAAAuB,EAAAtB,IAEA,IAAAV,EAAA6L,WACA7L,EAAA6L,SAAA1N,KAAA0D,IAAA8J,EAAAG,WAAAF,GAAA5L,EAAA6L,SAAA,IAAA,GAEA,EAEA5D,KAAA,SAAA8D,GACA,IAAAC,EAAAhP,EAAA4F,KAAA+I,UAAAxM,EAAAyD,KAAAgJ,QAAAzM,EAAA4M,GACAE,EAAAjP,EAAA4F,KAAA+I,UAAAtM,EAAAuD,KAAAgJ,QAAAvM,EAAA0M,GAEAnJ,KAAAJ,QAAA3E,UAAAA,IAAAqO,UAAAF,EAAAC,GACA,IAGArP,EAAA4O,EAAA,CACAW,OAAA7N,EACAuN,SA1vBA,MA6vBArO,EAAA4O,QAAAC,SAAAtO,EAAAyN,GAEA,IAAAc,GAAA3O,EACA4O,GAAAlP,EAEAmP,GAAA5B,EAAAtI,OAAA,CACAC,KAAA,SAAAoE,EAAA3G,GACA4K,EAAApC,GAAAjG,KAAAkG,KAAA7F,KAAA+D,EAAA3G,GAEA3D,EAAAuG,KAAA5C,QAAAjB,QACA6D,KAAA5C,QAAAjB,KAAA,GAAA6D,KAAA+D,MAAA3G,QAAAkK,WAAAnL,KAEA,EAEA0N,aAAA,WACA,IACA9F,EADA/D,KACA+D,MACA5H,EAFA6D,KAEA5C,QAAAjB,KACA2N,EAAA3N,EAAA,EACA4N,EAAAhG,EAAA3G,QAAA8H,QAAA,EAAA,EAaA,OAVAnB,EAAA3G,QAAAsH,SACA,CACA,IAAAgF,GAAA,EAAA,EAAAI,GAAA,IAAAJ,GAAA,EAAAK,EAAA5N,EAAA,GAAA,IAAAuN,GAAA,EAAA,EAAAI,IAGA,CACA,IAAAJ,GAAA,EAAAI,EAAA,GAAA,IAAAJ,GAAA,EAAA,EAAAK,EAAA5N,GAAA,IAAAuN,GAAA,EAAAI,EAAA,GAKA,EAEA/B,QAAA,WACA,IACAhE,EADA/D,KACA+D,MACA3G,EAFA4C,KAEA5C,QACAyG,EAAA,IAAA+E,EAAA5I,KAAApB,SAAA9E,EAAAsD,EAAAyG,UAAA,CACAa,SAAAX,EAAA3G,QAAAsH,SACAQ,OAAAnB,EAAA3G,QAAA8H,OACAlC,OAAAhD,KAAA2I,QAAAvL,EAAA4F,QACA9D,KAAA6E,EAAAgD,QAAA3J,EAAA0K,WACA1I,GAAA2E,EAAAgD,QAAA3J,EAAApB,WAGA,IAAAoB,EAAAyG,UAAA/B,cACA+B,EAAAzG,QAAA6L,SAAA,GAGApF,EAAAgF,QACAhF,EAAAmG,MACA,EAEA5D,OAAA,WACA,IACArC,EADA/D,KACA+D,MACA3G,EAFA4C,KAEA5C,QACA6M,EAAAjK,KAAA0I,oBACAD,EAAAzI,KAAA6J,aAAAzM,EAAApB,OAEAoB,EAAAyG,UAAAlB,KAAAxH,EAEA,IAAAyD,EAAA,IAAA+K,GAAA,CACA5L,OAAAkM,EAAAlM,OACAG,KAAA+L,EAAA/L,OACAyG,OAAA8D,EAAA,IAAA7D,OAAA6D,EAAA,IAAA7D,OAAA6D,EAAA,IAAAyB,QAEApD,EAAA/C,EAAAgD,QAAA3J,EAAApB,OAKA,OAJA4C,EAAA3D,UAAAA,IAAAqO,UAAAxC,EAAAjJ,GAAAiJ,EAAAhJ,KAEAkC,KAAApB,SAAAA,EAEAA,CACA,IAGAuL,GAAAxP,EAAA+E,OAAA,CACAmJ,MAAA,WACA,IAAAzL,EAAA4C,KAAA5C,QACA0L,EAAA9I,KAAA8I,KAAA1L,EAAAsH,SAAAhL,EAAA0Q,EAAA1Q,EAAA2Q,EACAjL,EAAAY,KAAAZ,GAAAhC,EAAAkN,UAAA,GAAAxB,GACA5J,EAAAc,KAAAd,KAAA9B,EAAAmN,UAAA,GAAAzB,GAEA,IAAA1L,EAAA6L,WACA7L,EAAA6L,SAAA1N,KAAA0D,IAAA1D,KAAAiP,IAAApL,EAAAF,GAAA9B,EAAAqN,MAAA,IAAA,IAGAzK,KAAA0K,KAAAxL,EACA,EAEAmG,KAAA,SAAA8D,GACA,IAAAnN,EAAA5B,EAAA4F,KAAAd,KAAAc,KAAAZ,GAAA+J,GACAnJ,KAAA0K,KAAA1O,EACA,EAEA0O,KAAA,SAAA1O,GACA,IAAA2O,EAAA,MAAA3K,KAAA8I,KAAA8B,cACAC,EAAA7K,KAAA5C,QAAAkN,UAEAO,EAAA,GAAAF,GAAA3O,GACA6O,EAAA,GAAAF,GAAA3O,EACA,IAGAhC,EAAAmQ,GAAA,CACAZ,OAAA7N,EACA+O,MAz2BA,MA42BA7P,EAAA4O,QAAAC,SAAArO,EAAA+O,IAEA,IAAAW,GAAAvQ,EACAwQ,GAAAtQ,EAEAuQ,GAAAhD,EAAAtI,OAAA,CACAC,KAAA,SAAAoE,EAAA3G,GACA4K,EAAApC,GAAAjG,KAAAkG,KAAA7F,KAAA+D,EAAA3G,GAEA3D,EAAAuG,KAAA5C,QAAAjB,QACA6D,KAAA5C,QAAAjB,KAAA,GAAA6D,KAAA+D,MAAA3G,QAAAkK,WAAAnL,KAEA,EAEA0N,aAAA,SAAA7N,GACA,IACA+H,EADA/D,KACA+D,MACA3G,EAFA4C,KAEA5C,QACAiL,EAAAtE,EAAA3G,QACA8H,EAAAmD,EAAAnD,OACAR,EAAA2D,EAAA3D,SACAuG,EAAA/F,IAAAR,GAAA,EAAA,EACAvI,EAAAiB,EAAAjB,KAAA8O,EACAC,EAAAnH,EAAAgD,QAAAhD,EAAA3G,QAAA4B,KACA8H,EAAA/C,EAAAgD,QAAA/K,GACA8M,EAAApE,EAAAhL,EAAA0Q,EAAA1Q,EAAA2Q,EACAc,EAAAzG,EAAAhL,EAAA2Q,EAAA3Q,EAAA0Q,EACApH,EAAAhD,KAAA2I,UAAAsC,EAEAG,EAAA,IAAArQ,EACAqQ,EAAAtC,GAAAoC,EAAApC,EAAA,KACAsC,EAAAD,GAAAD,EAAAC,EAAA,KAEA,IAAAE,EAAA,IAAAtQ,EACAsQ,EAAAvC,GAAAhC,EAAAgC,EAAA,KACAuC,EAAAF,GAAArE,EAAAqE,EAAA,KAEAzG,GACA0G,EAAA9B,UAAAtG,EAAA,GACAqI,EAAA/B,UAAAtG,EAAA,KAEAoI,EAAA9B,UAAA,EAAAtG,GACAqI,EAAA/B,UAAA,EAAAtG,IAGA,IAAAsI,EAAAD,EAAAhN,QACAkN,EAAAH,EAAA/M,QAUA,OARAqG,GACA4G,EAAAhC,UAAAnN,EAAA,GACAoP,EAAAjC,UAAAnN,EAAA,KAEAmP,EAAAhC,UAAA,EAAAnN,GACAoP,EAAAjC,UAAA,EAAAnN,IAGA,CAAAiP,EAAAC,EAAAC,EAAAC,EACA,EAEAxD,QAAA,WACA,IACAhE,EADA/D,KACA+D,MACA3G,EAFA4C,KAEA5C,QACAqL,EAAAzI,KAAA6J,aAAAzM,EAAApB,OACAwP,EAAAxL,KAAAwL,YACAC,EAAAzL,KAAA6J,aAAAzM,EAAA0K,WAEA0D,EAAA7G,OAAA8D,EAAA,IAAA7D,OAAA6D,EAAA,IAAA7D,OAAA6D,EAAA,IAAA7D,OAAA6D,EAAA,IAAAyB,QAEA,IAAArG,EAAA,IAAAsG,GAAAqB,EAAA1R,EAAAsD,EAAAyG,UAAA,CACA8B,QAAA5B,EAAA3G,QAAAuI,QACAjB,SAAAX,EAAA3G,QAAAsH,SACA6F,UAAA,CAAAkB,EAAA,GAAAA,EAAA,IACAnB,UAAA,CAAA7B,EAAA,GAAAA,EAAA,QAGA,IAAArL,EAAAyG,UAAA/B,cACA+B,EAAAzG,QAAA6L,SAAA,GAGApF,EAAAgF,QACAhF,EAAAmG,MACA,EAEA5D,OAAA,WACA,IAAAsF,EAAA,IAAAZ,GACAb,EAAAjK,KAAA0I,oBAEA1I,KAAA5C,QAAA6K,MAAAhD,SACAyG,EAAA7M,OAAAmB,KAAA2L,eAGA,IAAAjL,EAAAV,KAAAwL,YAAA,IAAAT,GAAA,CACAhN,OAAAkM,EAAAlM,OACAG,KAAA+L,EAAA/L,OAOA,OAJAwN,EAAA7M,OAAA6B,GAEAV,KAAApB,SAAA8M,EAEAA,CACA,EAEAC,YAAA,WACA,IAAAC,EAAA5L,KAAA5C,QAAA6K,MACAxK,EAAAmO,EAAAnO,QAAA,CAAA,EACA2K,EAAApI,KAAAoI,SAAA/J,QAAAvC,IAAA2B,EAAAb,OAAA,GAEA,OAAA,IAAAmO,GAAAnN,SAAAwK,EAAAyD,SAAA,CACA3N,KAAA,CACAC,MAAAyN,EAAAzN,MACAK,QAAAoN,EAAApN,SAEAT,OAAA,CACAI,MAAAV,EAAAb,MAAAa,EAAAU,OAAAyN,EAAAzN,MAAA,GACAvB,MAAAa,EAAAb,MACA6B,SAAAhB,EAAAgB,WAGA,IAMAqN,GAAAvR,EAEAwR,GAAAvM,EAAAE,OAAA,CACA4C,OAAA,SAAAvG,GACA,IAAA4E,EAAAX,KAAAW,SACAqL,EAAAjQ,EAAAE,OAAAM,EACA0P,EAAAlQ,EAAAE,OAAAQ,EAEAa,EAAA,IAAAnD,EAAA6R,EAAAC,EAAAD,EAAAjQ,EAAAa,QAAAqP,EAAAlQ,EAAAe,UAEAkD,KAAA+D,MAAAzB,OAAAhF,GACA0C,KAAAkM,kBAAA5O,GAEA,IAAA,IAAAgE,EAAA,EAAAA,EAAAX,EAAAE,OAAAS,IACAX,EAAAW,GAAAgB,SAGAtC,KAAAjE,KAAAiE,KAAAmM,QAAA7O,GACA0C,KAAAoM,iBACApM,KAAAqM,kBACArM,KAAAsM,eACAtM,KAAAe,OACA,EAEAuL,aAAA,WACA,IAAAC,EAAA,IAAAT,GACAU,EAAAxM,KAAA+D,MAAAqC,SACAzF,EAAAX,KAAAW,SAEA4L,EAAA1N,OAAAmB,KAAAkC,WACAqK,EAAA1N,OAAA2N,GAEA,IAAA,IAAAlL,EAAA,EAAAA,EAAAX,EAAAE,OAAAS,IAAA,CACA,IAAAkI,EAAA7I,EAAAW,GACAiL,EAAA1N,OAAA2K,EAAApD,UACAoD,EAAAxN,MAAAwN,EAAApM,QAAApB,MACA,CAEAgE,KAAAkB,SAAAqL,CACA,EAEAnK,aAAA,WACA,IAEAhF,EAAA4C,KAAA5C,QACA2G,EAAA/D,KAAA+D,MAAA,IAAAyB,EAAApI,EAAA2G,MAAA/D,KAAAC,gBAEAD,KAAAW,SAAA,GAEA,IAAAA,EAAAvD,EAAAsD,QACAC,EAAA5G,EAAA4G,GAAAA,EAAA,CAAAA,GAEA,IAAA,IAAAW,EAAA,EAAAA,EAAAX,EAAAE,OAAAS,IAAA,CACA,IAAAmL,EAAA3S,EAAA,CAAA,EAAA6G,EAAAW,GAAA,CACAuC,UAAA,CACA/B,YAAA1E,EAAA0E,eAGA4K,EAniCA,UAmiCAD,EAAAhE,MAAAmB,GAAAoB,GAhBAhL,KAkBAW,SAAAY,KAAA,IAAAmL,EAAA3I,EAAA0I,GACA,CACA,EAEA/I,aAAA,WACA,IAAAgB,EAAA1E,KAAA5C,QAAA2G,MAAAW,SAEA,MAAA,CACA9H,MAAA8H,EAvEA,GAj+BA,IAyiCA5H,OAAA4H,EA3iCA,IAo+BA,GAyEA,EAEAyH,QAAA,SAAA7O,GAOA,IANA,IAUAnB,EATA4H,EADA/D,KACA+D,MACApD,EAFAX,KAEAW,SACAgM,EAAArP,EAAAsP,SACAC,EAAAlM,EAAA,GAAArD,IAAAe,QAAAyO,KAAA/I,EAAAzG,KAEAgE,EAAA,EAAAA,EAAAX,EAAAE,OAAAS,IACAuL,EAAAC,KAAAnM,EAAAW,GAAAhE,IAAAe,SAkBA,OAdA0F,EAAA3G,QAAAsH,UACAvI,EAAA0Q,EAAAjQ,QAAA,EACAiQ,EAAA,IAAA1S,EACAwS,EAAApQ,EAAAJ,EAAAmB,EAAAQ,GACA6O,EAAApQ,EAAAJ,EAAAmB,EAAA4J,MAGA/K,EAAA0Q,EAAA/P,SAAA,EACA+P,EAAA,IAAA1S,EACAmD,EAAAO,GAAA8O,EAAAlQ,EAAAN,EACAmB,EAAAiI,GAAAoH,EAAAlQ,EAAAN,IAIA0Q,CACA,EAEAT,eAAA,WAUA,IATA,IAaAW,EAVAhJ,EADA/D,KACA+D,MACApD,EAFAX,KAEAW,SACAqM,EAAAjJ,EAAAzG,IACAA,EAAAqD,EAAA,GAAArD,IAAAe,QAAAyO,KAAA/I,EAAAzG,KACAuP,EAAA7M,KAAAjE,KAEAuF,EAAA,EAAAA,EAAAX,EAAAE,OAAAS,IACAhE,EAAAwP,KAAAnM,EAAAW,GAAAhE,IAAAe,SAIA0F,EAAA3G,QAAAsH,UACAqI,EAAAF,EAAAD,SAAArQ,EAAAe,EAAAsP,SAAArQ,EACAwH,EAAAzB,OAAA,IAAAnI,EACA6S,EAAAnP,GAAAkP,EAAAF,EAAA/O,GACAkP,EAAAzH,GAAAwH,EAAAF,EAAA3F,OAGA6F,EAAAF,EAAAD,SAAAnQ,EAAAa,EAAAsP,SAAAnQ,EACAsH,EAAAzB,OAAA,IAAAnI,EACA6S,EAAAnP,GAAAmP,EAAAlP,GAAAiP,EACAC,EAAAzH,GAAAyH,EAAA9F,GAAA6F,KAIA,IAAA,IAAAvL,EAAA,EAAAA,EAAAb,EAAAE,OAAAW,IACAb,EAAAa,GAAAc,OA7BAtC,KA6BAjE,KAEA,EAEAmQ,kBAAA,SAAAnQ,GACA,IACAgI,EADA/D,KACA+D,MACA,IAAAA,EAAA3G,QAAAsH,SAAA,CACA,IAAAuI,EAAAlJ,EAAAmJ,aAAAtQ,QAAAb,EAAAa,QACAqQ,EAAA,IACAlJ,EAAAzG,IAAA6P,OAAAF,EAAA,GACAlJ,EAAAzG,IAAA8P,QAAArR,EAAA,UACAgI,EAAAzB,OAAAyB,EAAAzG,KAEA,CACA,EAEA+O,gBAAA,WAUA,IATA,IAGAtI,EADA/D,KACA+D,MACApD,EAFAX,KAEAW,SACAqM,EAAAjJ,EAAAzG,IAAAe,QACA8K,EAAApF,EAAA3G,QAAAsH,SAAA,IAAA,IACAwD,EAAAvH,EAAA,GAAArD,IAEAgE,EAAA,EAAAA,EAAAX,EAAAE,OAAAS,IACA4G,EAAA4E,KAAAnM,EAAAW,GAAAhE,IAAAe,SAGA2O,EAAA7D,EAAA,IAAA5N,KAAA0D,IAAA+N,EAAA7D,EAAA,GAAAjB,EAAAiB,EAAA,GAAA,GACA6D,EAAA7D,EAAA,IAAA5N,KAAA0D,IAAAiJ,EAAAiB,EAAA,GAAA6D,EAAA7D,EAAA,GAAA,GAEApF,EAAAzB,OAAA0K,GAEA,IAAA,IAAAxL,EAAA,EAAAA,EAAAb,EAAAE,OAAAW,IACAb,EAAAa,GAAAc,OAnBAtC,KAmBAjE,KAEA,IAGA/B,EAAA+R,GAAA,CACAjK,aAAA,EACAI,UAAA,CACAxE,WAAA,IAEAqG,MAAA,CACAW,UAAA,KAIA,IAAA2I,GAAA,IAEAC,GAAAhT,EAAAgT,IACAC,GAAA9S,EACA+S,GAAAjT,EAEA,SAAAkT,GAAAC,EAAAC,EAAAC,EAAAxJ,GACA,IAAAiD,EAAA,IAAAmG,GACAZ,EAAAc,EAAAd,OACAiB,EAAAH,EAAAI,aAEA,GAAA1J,EAAAa,QACA,IAAA,IAAA3D,EAAA,EAAAA,EAAAqM,EAAA9M,OAAAS,IAAA,CACA,IAAAyM,EAAAL,EAAAM,QAAAL,EAAArM,IACA2M,EAAA,IAAAlT,EAAA6R,EAAArQ,EAAAsR,EAAAzJ,EAAAjI,KAAAyQ,EAAAnQ,GAAAyR,OAAAP,EAAArM,GAAAsL,GAEAvF,EAAAxI,OAAA,IAAA0O,GAAA,CACAxP,OAAA,CACAI,MAAAiG,EAAAjG,MACAvB,MAAAwH,EAAAxH,SAEA+H,OAAAoJ,GAAAnJ,OAAAqJ,GACA,CAGA,OAAA5G,CACA,CAEA,SAAA8G,GAAAjP,EAAAE,EAAAjB,EAAAK,GACA,MAAA,CAAAU,KAAAA,EAAAE,GAAAA,EAAAjB,MAAAA,EAAAK,QAAAA,EACA,CAEA,IAAA4P,GAAAnU,EAAAyF,OAAA,CACAC,KAAA,SAAAvC,EAAAqI,GACAxL,EAAA2L,GAAAjG,KAAAkG,KAAA7F,KAAA,EAAA,EAAA5C,EAAAqI,EACA,EAEAO,gBAAA,SAAA5I,GACA,IAAAsI,EAAA5L,EAAA,CAAA,EAAAkG,KAAA5C,QAAAA,GAIA,OAHAsI,EAAAK,UAAAL,EAAAK,WAAAxM,EAAA2M,cAAAR,EAAA1G,IAAA0G,EAAAzG,KACAyG,EAAAI,UAAAJ,EAAAI,WAAAJ,EAAAK,UAAA,GAEAL,CACA,EAEAS,WAAA,WACA,EAEAC,OAAA,SAAAwG,EAAAiB,GACA,IAAAH,EAAA1N,KAAAqO,UAAAzB,EAAAiB,GAEA7N,KAAAjE,KAAA2R,EAAA3R,OACAiE,KAAAsO,cAAAtO,KAAAqG,eACArG,KAAAqH,MAAArH,KAAA6E,cACA7E,KAAAyG,OAAAzG,KAAA0G,cACA,EAEApE,OAAA,SAAAvG,GACA,IAAA6Q,EAAA7Q,EAAA6Q,SACAiB,EAAAtS,KAAAyD,IAAAjD,EAAAe,SAAAf,EAAAa,SAAA,EAEA,IAAAnD,EAAAuG,KAAAjE,MAMA,OAAAiE,KAAAoG,OAAAwG,EAAAiB,GALA7N,KAAAjE,KAAAiE,KAAA0N,IAAA3R,OACAiE,KAAA6N,OAAA7N,KAAA0N,IAAAI,cACA9N,KAAAuO,mBACAvO,KAAAqG,cAIA,EAEAmI,UAAA,SAAAxS,GACA,IAAA4L,EAAA5H,KAAA5C,QACA4B,EAAA4I,EAAA5I,IACAC,EAAA2I,EAAA3I,IACA0G,EAAAiC,EAAAjC,QACA8I,EAAA7G,EAAA6G,WACAC,EAAA9G,EAAA8G,SACAC,EAAAD,EAAAD,EASA,OANA9I,EACA+I,GAAA1S,EAAAgD,IAAAC,EAAAD,GAAA2P,GAEA3S,EAAAgD,IAAAC,EAAAD,GAAA2P,EAAAF,GAGApB,EACA,EAEAuB,UAAA,WACA,IAAAnI,EAAAzG,KAAA5C,QAAAqJ,OAEA,OAAAA,GAAAA,EAAA5F,MACA,EAEAgO,UAAA,WACA,IAAAjH,EAAA5H,KAAA5C,QACAkK,EAAAM,EAAAN,WACAT,EAAAe,EAAAf,WACA1K,EAAA,EASA,OARAmL,EAAArC,UACA9I,EAAAmL,EAAAnL,MAGA0K,EAAA5B,UACA9I,EAAAZ,KAAA0D,IAAA4H,EAAA1K,KAAAA,IAGAA,CACA,EAEA2S,YAAA,WACA,IAAA9J,EAAA/K,EAAA2L,GAAAkJ,YAAAjJ,KAAA7F,MACA5C,EAAA4C,KAAA5C,QAOA,OANAA,EAAAsR,SAAAtR,EAAAqR,YAEA,KAAArR,EAAA6B,IAAA7B,EAAA2I,WAAA,IACAf,GAAA,GAGAA,CACA,EAEAqB,aAAA,WACA,IAAAM,EAAA3G,KAEA5C,EAAA4C,KAAA5C,QACAsQ,EAAA1N,KAAA0N,IAAArP,QACAwP,EAAAH,EAAAI,aACAH,EAAA3N,KAAA2N,WAAAD,EAAAtQ,EAAA2I,WACAa,EAAAxJ,EAAAwJ,UAAAxJ,EAAAwJ,WAAA,GAAAiH,EACAkB,EAAA,IAAAvB,GAEAwB,EAAA,IAAAnB,EACApU,EAAA2D,EAAA4R,eACAA,EAAA5R,EAAA4R,cAEA5R,EAAA4R,cAAAA,EAGA,IAAAC,EAAA7R,EAAA6I,OACAiJ,EAAAD,EAAA1K,WAAA9I,EACA0T,EAAA1V,EAAAuG,KAAAsO,eAEAY,IACArB,GAAA7N,KAAA6O,YAEA7O,KAAA4O,cAAAO,IACAtB,GAAAjH,EAAAoI,GAEAtB,EAAA0B,WAAAvB,GAAAwB,WAAAxB,IASA,IANA,IAAA5H,EAAAjG,KAAAiG,OACAjB,EAAAiB,EAAApF,OACAvC,EAAA9E,EAAAyV,EAAA3Q,SACAgR,GAAAhR,EAAA9B,KAAA8B,EAAAzB,OAAA,EACA0S,GAAAjR,EAAA5B,IAAA4B,EAAAvB,QAAA,EAEAuE,EAAA,EAAAA,EAAA0D,EAAA1D,IAAA,CACA,IAAAnE,EAAA8I,EAAA3E,GACAkO,EAAArS,EAAAG,IAAAV,QAAA,EACA6S,EAAAtS,EAAAG,IAAAR,SAAA,EACA6R,EAAAhB,EAAArM,GACAoO,GAAAf,EAAAtB,IAAA/R,EAEAqU,EAAAjC,EAAAM,QAAAW,GACAiB,EAAAD,EAAApT,EAAAhB,KAAAsU,IAAAH,IAAAF,EAAAF,IAAAJ,EAAA,GAAA,GACAY,EAAAH,EAAAlT,EAAAlB,KAAAwU,IAAAL,IAAAD,EAAAF,IAAAL,EAAA,GAAA,GAEA/R,EAAAmF,OAAA,IAAAnI,EAAAyV,EAAAJ,EAAAM,EAAAL,EAAAG,EAAAJ,EAAAM,EAAAL,IACA,IAAAO,EAAA,IAAAjV,EAAAoC,EAAAG,IAAAO,GAAAV,EAAAG,IAAAQ,IAEAmS,OAAA,EACA,GAAAd,EAGA,CAEA,IAAAe,GADAD,EAAAtJ,EAAA2H,cAAA9Q,SAAA8D,IACAvF,OAAAE,OAEAkU,EAAAF,EAAAhV,aAAAA,IACAkV,EAAA7G,UAAA0G,EAAAzT,EAAA2T,EAAA3T,EAAAyT,EAAAvT,EAAAyT,EAAAzT,GACAwT,EAAAhV,UAAAkV,EACA,MATAF,EAAA/S,EAAAC,EAAAC,EAAA6I,QACA8I,EAAAlQ,OAAAoR,GAUAtJ,EAAA5K,KAAAjB,EAAAsV,MAAAzJ,EAAA5K,KAAAkU,EAAAlU,OACA,CAEA,OAAAgT,CACA,EAEAR,iBAAA,WACA,IAAA9H,EAAAzG,KAAAyG,OAAAjJ,SAEA,GAAAiJ,EAAA5F,OAAA,EAAA,CACA,IAAA+G,EAAA5H,KAAA5C,QACA4R,EAAApH,EAAAoH,cACApI,EAAAgB,EAAAhB,UACAyJ,EAAArQ,KAAAsQ,iBAEAtQ,KAAA5C,QAAA6I,OAAA1B,WAAA9I,IACA4U,GAAAzJ,EAAAoI,GAKA,IAFA,IAAAuB,EAAAF,EAAAzJ,EAAA,EAEAtF,EAAA,EAAAA,EAAAmF,EAAA5F,OAAAS,IACAmF,EAAAnF,GAAAkP,UAAApB,WAAAmB,GAAAlB,WAAAkB,GAGAvQ,KAAAjE,KAAAjB,EAAAsV,MAAApQ,KAAAjE,KAAAiE,KAAAyG,OAAA1K,OACA,CACA,EAEA2K,aAAA,WACA,IAAAC,EAAA3G,KAEAyQ,EAAAzQ,KAAA0Q,gBACAC,EAAAF,EAAA5P,OACA+P,EAAA,IAAApD,GAEA,GAAAmD,EAAA,CACA,IAAA/I,EAAA5H,KAAA5C,QACAwJ,EAAAgB,EAAAhB,UACAjB,EAAAiC,EAAAjC,QACAqJ,EAAApH,EAAAoH,cACAqB,EAAArQ,KAAAsQ,iBAGAtQ,KAAA6N,OAAA7N,KAAA6N,SAAAjH,EAAAoI,GAEA,IAAA,IAAA1N,EAAA,EAAAA,EAAAqP,EAAArP,IAAA,CACA,IAAAuP,EAAAJ,EAAAnP,GACApC,EAAAyH,EAAA6H,UAAAqC,EAAAlL,EAAA,KAAA,SACAvG,EAAAuH,EAAA6H,UAAAqC,EAAAlL,EAAA,OAAA,OAEAvG,EAAAF,GAAA,GACA0R,EAAA/R,OAAA8H,EAAAmK,YAAA5R,EAAAE,EAAAiR,EAAAQ,GAEA,CACA,CAEA,OAAAD,CACA,EAEAE,YAAA,SAAArC,EAAAC,EAAA2B,EAAAjT,GACA,IAAAwJ,EAAA5G,KAAA5C,QAAAwJ,UACAmK,EAAA,IAAAlW,EAAAyS,IAAAtN,KAAA0N,IAAAd,OAAA,CACAoE,QAAAX,EAAAzJ,EAAA,EACAqK,QAAAZ,EAAAzJ,EAAA,EACA6H,WAAAA,EACAC,SAAAA,IAGA,OAAA,IAAApB,GAAAyD,EAAA,CACAhT,OAAA,CACAnB,MAAAgK,EACAzI,MAAAf,EAAAe,MACAK,QAAApB,EAAAoB,QACAG,QAAAvB,EAAAuB,UAGA,EAEA+R,cAAA,WACA,IAAAtT,EAAA4C,KAAA5C,QACAqJ,EAAArJ,EAAAqJ,QAAA,GACAzB,EAAAyB,EAAA5F,OACA4P,EAAA,GAEA,GAAAzL,EAAA,CACA,IAAAhG,EAAA5B,EAAA4B,IACAC,EAAA7B,EAAA6B,IACAiS,EAAA9T,EAAA+T,sBACAV,EAAAlP,KAAA4M,GAAAnP,EAAAC,EAAAiS,IAEA,IAAA,IAAA5P,EAAA,EAAAA,EAAA0D,EAAA1D,IAIA,IAHA,IAAAvC,EAAAD,EAAA2H,EAAAnF,GAAAtC,EAAAC,GACA0R,EAAAF,EAAA5P,OAEAuQ,EAAA,EAAAA,EAAAT,EAAAS,IAAA,CACA,IAAAP,EAAAJ,EAAAW,GAEA,GAAAP,EAAA3R,MAAAH,EAAAG,MAAAH,EAAAG,MAAA2R,EAAAzR,GAAA,CACAqR,EAAAlP,KAAA4M,GAAApP,EAAAG,KAAAH,EAAAK,GAAAL,EAAAZ,MAAAY,EAAAP,UAEAqS,EAAA3R,MAAAH,EAAAK,IAAAL,EAAAK,IAAAyR,EAAAzR,IACAqR,EAAAlP,KAAA4M,GAAApP,EAAAK,GAAAyR,EAAAzR,GAAA8R,EAAAnS,EAAAP,UAGAqS,EAAAzR,GAAAL,EAAAG,KAEA,KACA,CACA,CAEA,CAEA,OAAAuR,CACA,EAEAH,eAAA,WACA,IACA5C,EADA1N,KACA0N,IACAtQ,EAFA4C,KAEA5C,QACAwJ,EAAAxJ,EAAAwJ,UACAoI,EAAA5R,EAAA4R,cACAqC,EAAAjU,EAAAkK,WAAAnL,KASA,OANAiB,EAAA6I,OAAA1B,WAAA5I,EACA+R,EAAAI,aAAAuD,EAAArC,EAAApI,EAEA8G,EAAAI,aAAAlH,CAIA,EAEAyH,UAAA,SAAAzB,EAAAiB,GACA,IAAAzQ,EAAA4C,KAAA5C,QASA,OAPA4C,KAAA0N,IAAA,IAAA7S,EAAAyS,IAAAV,EAAA,CACAoE,QAAAnD,EACAoD,QAAApD,EACAY,WAAArR,EAAAqR,WAAApB,GACAqB,SAAAtR,EAAAsR,SAAArB,IAIA,EAEAxI,YAAA,WACA,IACA6I,EADA1N,KACA0N,IACAtQ,EAFA4C,KAEA5C,QACAkU,EAAA5D,EAAArP,QAEA2B,KAAAuR,gBAAAvR,KAAA2N,WAAAD,EAAAtQ,EAAA2I,WACA/F,KAAAsH,WAAAmG,GAAA6D,EAAAtR,KAAAuR,gBAAAnU,EAAA2I,UAAA3I,EAAAkK,YAEA,IAAAkK,EAAA,IAAAhE,GACAgE,EAAA3S,OAAAmB,KAAAsH,YAEA,IAAA+J,EAAAjU,EAAAkK,WAAAnL,KACAsV,EAAArU,EAAAyJ,WAAA1K,KAIA,GAFA6D,KAAA0R,gBAAAL,EAAAI,EAEArU,EAAA6I,OAAA1B,WAAA5I,EAAA,CACA,IAAAkS,EAAAyD,EAAAxD,aACAwD,EAAAlC,WAAAvB,EAAAwD,EAAAI,GACApC,WAAAxB,EAAAwD,EAAAI,EACA,CAMA,OAJAzR,KAAA2R,gBAAA3R,KAAA4R,oBAAA5R,KAAA2N,WAAAD,EAAAtQ,EAAA0I,YACA9F,KAAA6G,WAAA4G,GAAA6D,EAAAtR,KAAA2R,gBAAAvU,EAAA0I,UAAA1I,EAAAyJ,YACA2K,EAAA3S,OAAAmB,KAAA6G,YAEA2K,CACA,EAEAI,oBAAA,SAAAC,GAIA,IAHA,IAAAzU,EAAA4C,KAAA5C,QACAgI,EAAAhI,EAAA2I,UAAA3I,EAAA0I,UAEAxE,EAAAuQ,EAAAhR,OAAA,EAAAS,GAAA,EAAAA,IACAA,EAAA8D,GAAA,GACAyM,EAAAC,OAAAxQ,EAAA,GAIA,OAAAuQ,CACA,EAEAlE,WAAA,SAAAoE,EAAAC,GACA,IAAA5U,EAAA4C,KAAA5C,QACAuI,EAAAvI,EAAAuI,QACA5G,EAAA3B,EAAA6B,IAAA7B,EAAA4B,IACA2P,EAAAoD,EAAArD,SAAAqD,EAAAtD,WACAwD,EAAAlT,EAAAiT,EACA7I,EAAA4I,EAAAtD,WACApJ,EAAAsJ,EAAAsD,EAEAtM,IACAwD,GAAAwF,EACAtJ,GAAAA,GAGAsJ,GAAA,KAAAvR,EAAA6B,IAAA+S,GAAA,IACAC,GAAA,GAIA,IADA,IAAAC,EAAA,GACA5Q,EAAA,EAAAA,EAAA2Q,EAAA3Q,IACA4Q,EAAA3Q,KAAAlH,EAAA8O,EAAAvP,IACAuP,GAAA9D,EAOA,OAJAhL,EAAA8O,IAAA4I,EAAArD,UACAwD,EAAA3Q,KAAA4H,GAGA+I,CACA,EAEArE,OAAA,SAAA7R,GACA,IAAAA,EAKA,OAAAgE,KAAA0N,IAAAI,aAJA9N,KAAA0N,IAAA0B,WAAApT,GAAAqT,WAAArT,GACAgE,KAAAmS,gBAAAnS,KAAAsH,WAAA9J,SAAAwC,KAAAuR,iBACAvR,KAAAmS,gBAAAnS,KAAA6G,WAAArJ,SAAAwC,KAAA2R,iBAAA,EAIA,EAEAQ,gBAAA,SAAA9K,EAAAsG,EAAAyE,GACA,IAAArF,EAAAqF,GAAApS,KAAA0R,iBAAA,EACAJ,EAAAtR,KAAA0N,IACAG,EAAAyD,EAAAxD,aAEAsE,GAAApS,KAAA5C,QAAA6I,OAAA1B,WAAA5I,GAAA,IAAAoR,IACAuE,EAAAtR,KAAA0N,IAAArP,SACA+Q,WAAAvB,EAAAd,GAAAsC,WAAAxB,EAAAd,GAGA,IAAA,IAAAzL,EAAA,EAAAA,EAAA+F,EAAAxG,OAAAS,IAAA,CACA,IAAA+Q,EAAAf,EAAAtD,QAAAL,EAAArM,IACAmP,EAAApJ,EAAA/F,GAAAmP,SACA6B,EAAAD,EAAA9V,EAAAkU,EAAA,GAAA8B,SAAAhW,EACAiW,EAAAH,EAAA5V,EAAAgU,EAAA,GAAA8B,SAAA9V,EAEA4K,EAAA/F,GAAArG,WAAA,IAAAA,GAAAqO,UAAAgJ,EAAAE,GACA,CACA,IAGAxY,EAAAoU,GAAA,CACApP,IAAA,EACAC,IAAA,IAEAqI,WAAA,CACAnL,KAAA,GACAsL,MAAAhM,EACA0C,MAAAxE,EACAiD,MAAAvB,EACA4J,SAAA,GAGA4B,WAAA,CACA1K,KAAA,GACAsL,MAAAhM,EACA0C,MAAAxE,EACAiD,MAAAvB,EACA4J,SAAA,GAGAwJ,YAAA,GACAC,SAAA,IAEAzI,OAAA,CACA1B,SAAA9I,EACA6C,QAAA,KAIA,IAAAmU,GAAA9X,EAAA+E,OAAA,CACAC,KAAA,SAAAC,EAAAxC,GACAzC,EAAAiL,GAAAjG,KAAAkG,KAAA7F,KAAAJ,EAAAxC,GAEA,IAAAsV,EAAA1S,KAAA5C,QAEAsV,EAAAzJ,SAAA1N,KAAA0D,IAAA1D,KAAAiP,IAAAkI,EAAAC,SAAAD,EAAAE,UAAAF,EAAAzJ,SAAA,IAAA,EACA,EAEA5D,KAAA,SAAA8D,GACA,IAAA/L,EAAA4C,KAAA5C,QACAuR,EAAAvU,EAAAgD,EAAAwV,SAAAxV,EAAAuV,SAAAxJ,GAEAnJ,KAAAJ,QAAA3E,UAAAA,IAAAiT,OAAAS,EAAAvR,EAAAwP,QACA,IAGA5S,EAAAyY,GAAA,CACAlJ,OAAA7N,EACAuN,SAAA/N,IAGAN,EAAA4O,QAAAC,SAAA7N,EAAA6W,IAEA,IACAI,GAAAvY,EAAAuY,OACAC,GAAAvY,EACAwY,GAAAtY,EAEAuY,GAAArL,EAAAjI,OAAA,CACAuT,SAAA,SAAAtE,GACA3O,KAAApB,SAAA3D,UAAAA,IAAAiT,OAAAS,EAAA3O,KAAA4M,QACA,EAEA7E,QAAA,WACA,IACAhE,EADA/D,KACA+D,MACA3G,EAFA4C,KAEA5C,QACAwV,EAAA7O,EAAAyK,UAAApR,EAAA0K,WACA6K,EAAA5O,EAAAyK,UAAApR,EAAApB,QAEA,IAAAoB,EAAAyG,UAAA/B,YACA9B,KAAAiT,SAAAN,GAEA,IAAAF,GAAAzS,KAAApB,SAAA9E,EAAAsD,EAAAyG,UAAA,CACA+O,SAAAA,EACAD,SAAAA,KACA3I,MAEA,EAEA5D,OAAA,WACA,IACArC,EADA/D,KACA+D,MACA3G,EAFA4C,KAEA5C,QACAwB,EAAA,IAAAkU,GAeA,OAbA,IAAA1V,EAAAyG,WACA/J,EAAAsD,EAAAyG,UAAA,CACA4K,WAAA,EACA7B,OAAA7I,EAAA2J,IAAAd,OACAjH,QAAA5B,EAAA3G,QAAAuI,UAIA/G,EAAAC,OAAAmB,KAAAkT,gBAAAlT,KAAAmT,cAEAnT,KAAApB,SAAAA,EACAoB,KAAAiT,SAAA3X,GAEAsD,CACA,EAEA0D,OAAA,SAAAoL,GACA,IAAAd,EAAA5M,KAAA4M,OAAAc,EAAAd,OACA/L,EAAA3G,EAAA8F,KAAA5C,QAAAyD,QAAA,EAAA,GAAA,KACAgN,EAAA7N,KAAA6N,OAAAH,EAAAI,aAAAjN,EACAuS,EAAApT,KAAAoT,QAAA7X,KAAAlB,MAAAwT,EAAA7N,KAAA5C,QAAAiW,IAAAlX,MAEA6D,KAAAjE,KAAAjB,EAAAwY,WAAA,IAAAvY,EAAA6R,EAAArQ,EAAA6W,EAAAxG,EAAAnQ,EAAA2W,GACA,IAAArY,EAAA6R,EAAArQ,EAAA6W,EAAAxG,EAAAnQ,EAAA2W,GACA,EAEAF,cAAA,WACA,IAAAzB,EAAAzR,KAAA+D,MAAA3G,QAAAyJ,WAAA1K,KACAyQ,EAAA5M,KAAA4M,OACA2G,EAAAvT,KAAA5C,QAAAe,MAEAqV,EAAA,IAAAT,GAAA,CACA7U,KAAA,CAAAC,MAAAoV,GACAxV,OAAA,CAAAI,MAAAoV,EAAA3W,MAAAvB,KAQA,OALAmY,EAAA7O,OAAAiI,EAAArQ,EAAAyD,KAAA6N,OAAA4D,EAAA7E,EAAAnQ,GACAmI,OAAAgI,EAAArQ,EAAAqQ,EAAAnQ,EAAAuD,KAAAoT,QAAA,GACAxO,OAAAgI,EAAArQ,EAAAqQ,EAAAnQ,EAAAuD,KAAAoT,QAAA,GACAlJ,QAEAsJ,CACA,EAEAL,WAAA,WACA,IAAA/V,EAAA4C,KAAA5C,QACAqW,EAAArW,EAAAiW,IAAAlV,OAAAf,EAAAe,MACAuV,EAAA,IAAA7Y,EAAAgY,OAAA7S,KAAA4M,OAAA5M,KAAAoT,SAOA,OALA,IAAAP,GAAAa,EAAA,CACAxV,KAAA,CAAAC,MAAAsV,GACA1V,OAAA,CAAAI,MAAAsV,IAIA,IAGAzZ,EAAAgZ,GAAA,CACAK,IAAA,CACAlX,KA7FA,KA+FAwX,MAAA,CACA/W,MAAA,GACAE,OAAA,IAEA+G,UAAA,CACAlB,KAAA/G,EACAqN,SAAA/N,KAIA,IAAA0Y,GAAArZ,EAEAsZ,GAAArU,EAAAE,OAAA,CACA4C,OAAA,SAAAvG,GACA,IAAA4K,EAAA3G,KAEAW,EAAAX,KAAAW,SACAX,KAAA+D,MAAAzB,OAAAvG,GACAiE,KAAA8T,iBAAA9T,KAAA+D,MAAAhI,KAEA,IAAA,IAAAuF,EAAA,EAAAA,EAAAX,EAAAE,OAAAS,IACAX,EAAAW,GAAAgB,OAAAqE,EAAA5C,MAAA2J,KACA/G,EAAAmN,iBAAAhZ,EAAAsV,MAAAzJ,EAAAmN,iBAAAnT,EAAAW,GAAAvF,MAGAiE,KAAA+T,SAAAhY,GACAiE,KAAAgU,WAAAjY,GACAiE,KAAAsM,aAAAtM,KAAAkC,UAAAvB,EAAAX,KAAA+D,OACA/D,KAAAe,OACA,EAEAuL,aAAA,SAAApK,EAAAvB,EAAAoD,GACA,IAAAwI,EAAAvM,KAAAkB,SAAA,IAAA0S,GAEArH,EAAA1N,OAAAqD,GACAqK,EAAA1N,OAAAkF,EAAAsD,OACAkF,EAAA1N,OAAAkF,EAAA0C,QACAzG,KAAAiU,eAAAtT,GACA4L,EAAA1N,OAAAkF,EAAAuK,cACA,EAEA2F,eAAA,SAAAtT,GAGA,IAFA,IAEAW,EAAA,EAAAA,EAAAX,EAAAE,OAAAS,IAAA,CACA,IAAAkI,EAAA7I,EAAAW,GACAkI,EAAApD,SAJApG,KAKAkB,SAAArC,OAAA2K,EAAA5K,UAEA4K,EAAAxN,MAAAwN,EAAApM,QAAApB,MACA,CACA,EAEA+X,SAAA,SAAAhY,GAYA,IAXA,IAOAmY,EAAAC,EAAAC,EAAAC,EAAAC,EAPA3N,EAAA3G,KAEA0N,EAAA1N,KAAA+D,MAAA2J,IACAb,EAAA7M,KAAA8T,iBACAzO,EAAA9J,KAAAiP,IAAAxK,KAAAuU,QAAA1H,EAAA9Q,IACAiD,EAAA3E,EAAAgL,EAAAzL,GACAqF,EAAA5E,GAAAgL,EAAAzL,GAEA4a,EAAA,EACAlT,EAAA,MAEAA,IAAA,OACAkT,EAAAF,IAAAF,EAAAI,EAAA,EAAA,GAEA,GAIAxV,IAAAqV,GAEA,IADAH,EAAAvN,EAAA8N,WAAAzV,EAAAjD,EAAA2R,KACAwG,GAAA,GAKAjV,IAAAoV,GAEA,IADAD,EAAAzN,EAAA8N,WAAAxV,EAAAlD,EAAA2R,KACA0G,GAAA,IAMAC,EADAH,EAAA,GAAAE,EAAA,EACA,EAAApV,EACAkV,EAAA,GAAAE,EAAA,EACA,EAAAnV,EAEA5E,GAAA2E,EAAAC,GAAA,GAAA,EAAArF,GAIA,IADAua,EAAAxN,EAAA8N,WAAAJ,EAAAtY,EAAA2R,KACAyG,GAAA,KAIAG,EAAAF,EAEAD,EAAA,GACAlV,EAAAoV,EACAD,EAAAD,IAEAnV,EAAAqV,EACAH,EAAAC,EAGA,EAEAM,WAAA,SAAApP,EAAAtJ,EAAA2R,GACA,IAEA3J,EAAA/D,KAAA+D,MACApD,EAAAX,KAAAW,SACAkN,EAAAH,EAAAI,aACA4G,EAAAhH,EAAArP,QAEAqW,EAAAtF,WAAAvB,EAAAxI,GAAAgK,WAAAxB,EAAAxI,GAEAtB,EAAA2J,IAAAgH,EACA3Q,EAAAzB,OAAAvG,GACAiE,KAAA2U,SAAA5Q,EAAAhI,KAEA,IAAA,IAAAuF,EAAA,EAAAA,EAAAX,EAAAE,OAAAS,IACAX,EAAAW,GAAAgB,OAAAoS,GAdA1U,KAeA2U,SAAA7Z,EAAAsV,MAfApQ,KAeA2U,SAAAhU,EAAAW,GAAAvF,MAGA,OAAAiE,KAAAuU,QAAAvU,KAAA2U,SAAA5Y,EACA,EAEAwY,QAAA,SAAAK,EAAAtX,GACA,OAAA/B,KAAAyD,IAAA1B,EAAAV,QAAAgY,EAAAhY,QAAAU,EAAAR,SAAA8X,EAAA9X,SACA,EAEAkX,WAAA,SAAAjY,GACA,IAEA8Y,EAAA7U,KAAA2U,SAAA/H,SACAD,EAAA5Q,EAAA6Q,SACAkI,EAAAD,EAAAtY,EAAAoQ,EAAApQ,EACAwY,EAAAF,EAAApY,EAAAkQ,EAAAlQ,EAEAsH,EADA/D,KACA+D,MACApD,EAFAX,KAEAW,SAEAoD,EAAA2J,IAAAd,OAAArQ,GAAAuY,EACA/Q,EAAA2J,IAAAd,OAAAnQ,GAAAsY,EAEAhR,EAAAzB,OAAAvG,GAEA,IAAA,IAAAuF,EAAA,EAAAA,EAAAX,EAAAE,OAAAS,IACAX,EAAAW,GAAAgB,OAAAyB,EAAA2J,KAhBA1N,KAiBA2U,SAAA7Z,EAAAsV,MAAArM,EAAAhI,KAAA4E,EAAAW,GAAAvF,KAEA,EAEAqG,aAAA,WACA,IAEAhF,EAAA4C,KAAA5C,QACAuD,EAAAvD,EAAAsD,QACAqD,EAAA/D,KAAA+D,MAAA,IAAAqK,GAAAhR,EAAA2G,MAAA/D,KAAAC,gBAEAD,KAAAW,SAAA,GAGA,IADA,IAAAqU,EAAAjb,EAAA4G,GAAAA,EAAA,CAAAA,GACAW,EAAA,EAAAA,EAAA0T,EAAAnU,OAAAS,IAAA,CACA,IAAAkI,EAAA,IAAAwJ,GAAAjP,EAAAjK,EAAA,CAAA,EAAAkb,EAAA1T,GAAA,CACAuC,UAAA,CACA/B,YAAA1E,EAAA0E,gBAZA9B,KAgBAW,SAAAY,KAAAiI,EACA,CACA,IAGAxP,EAAA6Z,GAAA,CACA/R,aAAA,EACAI,UAAA,CACAxE,WAAA,MAIA,IAAAuX,GAAA7G,GAAA1O,OAAA,CACAgR,cAAA,WACA,IAAA9I,EAAA5H,KAAA5C,QAMA,MAAA,CAAA,CAAA8B,KALA0I,EAAA5I,IAKAI,GAJAwI,EAAA3I,IAIAd,MAHAyJ,EAAAuJ,sBAGAxS,QAFAiJ,EAAAsN,cAGA,EAEAtG,UAAA,WACA,OAAA,CACA,EAEAuG,sBAAA,SAAAxG,GACA,IAAAyG,EAAApV,KAAAyG,OAAAjJ,SAAA,GAAA3C,WAEAmF,KAAA5C,QAAAuI,QACAyP,EAAAC,YAAA1G,GAEAyG,EAAAE,cAAA3G,EAEA,EAEA4G,SAAA,SAAArW,EAAAE,EAAAhC,GACA,IAAAuI,EAAA3F,KAAA5C,QAAAuI,QAEA8I,EAAAzO,KAAAwO,UAAA7I,EAAAvG,EAAAF,GACAwP,EAAA1O,KAAAwO,UAAA7I,EAAAzG,EAAAE,GAEAL,EAAAiB,KAAA8Q,YAAArC,EAAAC,EAAA1O,KAAAsQ,iBAAAlT,GAIA,OAFA4C,KAAAyG,OAAA5H,OAAAE,GAEAA,CACA,IAGA/E,EAAAib,GAAA,CACAjW,IAAA,EACAC,IAAA,IAEAqI,WAAA,CACArC,SAAA,GAGA4B,WAAA,CACA5B,SAAA,GAGAgB,OAAA,CACAhB,SAAA,GAGAwJ,WAAA,EACAC,SAAA,IACAwG,aAAA,UAGA,IAEAM,GAAA7a,EAAA+E,OAAA,CACAC,KAAA,SAAAC,EAAAxC,GACAzC,EAAAiL,GAAAjG,KAAAkG,KAAA7F,KAAAJ,EAAAxC,GAEA,IAAAsV,EAAA1S,KAAA5C,QACA6L,EAAA1N,KAAAiP,IAAAkI,EAAAC,SAAAD,EAAAE,UAAAF,EAAAzJ,SAAA,IACAyJ,EAAAzJ,SAAA/O,EAAA+O,EAAA/N,EARA,KAUA,IAAAua,EAAA7V,EAAAhB,SAAAxB,QAAAsY,IAAA,gBACAvX,EAAAyB,EAAA+V,eACAF,IAAAtX,IACA6B,KAAAyV,WAAA,IAAAnc,MAAAsc,MAAAH,GACAzV,KAAA7B,MAAA,IAAA7E,MAAAsc,MAAAzX,GAEA,EAEAkH,KAAA,SAAA8D,GACA,IAAAvB,EAAA5H,KACA5C,EAAAwK,EAAAxK,QACAqY,EAAA7N,EAAA6N,WACAtX,EAAAyJ,EAAAzJ,MACAwQ,EAAAvU,EAAAgD,EAAAwV,SAAAxV,EAAAuV,SAAAxJ,GAGA,GAFAnJ,KAAAJ,QAAA+O,MAAAA,GAEAxQ,EAAA,CACA,IAAA0X,EAAAxb,EAAAD,EAAAqb,EAAAI,EAAA1X,EAAA0X,EAAA1M,IACA2M,EAAAzb,EAAAD,EAAAqb,EAAAK,EAAA3X,EAAA2X,EAAA3M,IACA4M,EAAA1b,EAAAD,EAAAqb,EAAAM,EAAA5X,EAAA4X,EAAA5M,IAEAnJ,KAAAJ,QAAA7B,OAAA,IAAAzE,MAAAsc,MAAAC,EAAAC,EAAAC,GAAAC,QACA,CACA,IAGAhc,EAAAwb,GAAA,CACAjM,OAAA7N,EACAuN,SAAA/N,IAGAN,EAAA4O,QAAAC,SAAA5N,EAAA2Z,IAEA,IAAAS,GAAAtO,EAAAjI,OAAA,CACAqI,QAAA,WACA,IACAhE,EADA/D,KACA+D,MACA3G,EAFA4C,KAEA5C,QACAwV,EAAA7O,EAAAyK,UAAApR,EAAA0K,WACA6K,EAAA5O,EAAAyK,UAAApR,EAAApB,OAEAgE,KAAA6D,WACA7D,KAAA6D,UAAAqS,SAGA,IAAA9Y,EAAAyG,UAAA/B,aACA9B,KAAA2O,MAAAgE,GACA3S,KAAAjC,OAAAiC,KAAA2V,kBAEA3V,KAAA6D,UAAA,IAAA2R,GAAAxV,KAAAlG,EAAAsD,EAAAyG,UAAA,CACA+O,SAAAA,EACAD,SAAAA,KAGA3S,KAAA6D,UAAAmG,OAEA,EAEA2E,MAAA,SAAA3S,GACA,IAAAoZ,EAAApV,KAAApB,SAAA/D,WACAmF,KAAA+D,MAAA3G,QAAAuI,QACAyP,EAAAE,cAAAtZ,GAEAoZ,EAAAC,YAAArZ,GAEAgE,KAAA+D,MAAAoR,sBAAAnZ,EACA,EAEA+B,OAAA,SAAA/B,GACAgE,KAAApB,SAAAb,OAAA/B,EACA,EAEAoK,OAAA,WACA,IAAApG,KAAApB,SAAA,CAIA,IACAmF,EADA/D,KACA+D,MACA3G,EAFA4C,KAEA5C,SAEA,IAAAA,EAAAyG,WACA/J,EAAAsD,EAAAyG,UAAA,CACA4K,WAAA,EACA7B,OAAA7I,EAAA2J,IAAAd,OACAjH,QAAA5B,EAAA3G,QAAAuI,UAIA3F,KAAApB,SAAAmF,EAAAwR,SAAAxR,EAAA3G,QAAA4B,IAAAgB,KAAA5C,QAAApB,MAAA,CACAmC,MAAA6B,KAAA2V,eACAnX,QAAApB,EAAAoB,QACAG,QAAAoF,EAAA3G,QAAA8X,cAjBA,CAmBA,EAEAS,aAAA,WACA,IAAA/N,EAAA5H,KAAA+D,MAAA3G,QACA4B,EAAA4I,EAAA5I,IACAC,EAAA2I,EAAA3I,IACAoJ,EAAArI,KAAA5C,QACA+Y,EAAA9N,EAAA8N,OACAhY,EAAAkK,EAAAlK,MACAnC,EAAAqM,EAAArM,MACAoa,EAAA7c,EAAAkI,SAAAzF,GAAAA,EAAAgD,EAEA,GAAAmX,EACA,IAAA,IAAAE,EAAA,EAAAA,EAAAF,EAAAtV,OAAAwV,IAAA,CACA,IAAAC,EAAAH,EAAAE,GACAE,EAAAD,EAAAnY,MACAe,EAAAoX,EAAApX,UAAA,IAAAA,IAAAA,EAAAF,GACA,IAAAI,EAAAkX,EAAAlX,GAEA,QAFA,IAAAA,IAAAA,EAAAH,GAEAC,GAAAkX,GAAAA,GAAAhX,EACA,OAAAmX,CAEA,CAGA,OAAApY,CACA,EAEAmE,OAAA,WACAtC,KAAAoG,SAEApG,KAAAjE,KAAAiE,KAAApB,SAAA7C,MACA,IAGA/B,EAAAic,GAAA,CACApS,UAAA,CACAlB,KAAA9G,EACAoN,SAAA/N,KAIA,IAAAsb,GAAA3C,GAAAnU,OAAA,CACAU,WAAA,SAAAN,GACA+T,GAAAjO,GAAAxF,WAAAyF,KAAA7F,KAAAF,GAEAE,KAAA5C,QAAAe,MAAA6B,KAAA5C,QAAAe,QAAA6B,KAAAF,MAAAY,SAAA,CAAA,GAAAvC,KACA,EAEAiE,aAAA,WACA,IAAAhF,EAAA4C,KAAA5C,QACA2G,EAAA/D,KAAA+D,MAAA,IAAAkR,GAAA7X,EAAA2G,MAAA/D,KAAAC,gBAEAS,EAAA,IAAAuV,GAAAlS,EAAAjK,EAAA,CAAA,EAAA,CACAqc,OAAA/Y,EAAA+Y,OACAhY,MAAAf,EAAAe,MACAnC,MAAAoB,EAAApB,MACAwC,QAAApB,EAAAoB,QACAqF,UAAA,CACA/B,YAAA1E,EAAA0E,gBAIA9B,KAAAW,SAAA,CAAAD,EACA,EAEAuT,eAAA,SAAAtT,GACA,IAAA,IAAAW,EAAA,EAAAA,EAAAX,EAAAE,OAAAS,IAAA,CACA,IAAAkI,EAAA7I,EAAAW,GACAkI,EAAApD,SAEAoD,EAAAxN,MAAAwN,EAAApM,QAAApB,MACA,CACA,EAEA8E,iBAAA,SAAA9E,GACAgE,KAAA5C,QAAApB,MAAAA,CACA,EAEA2Z,aAAA,WACA,IAAAjV,EAAAV,KAAAW,SAAA,GACA,GAAAD,EACA,OAAAA,EAAAiV,cAEA,EAEAc,oBAAA,SAAA7Z,EAAAE,GACA,IAAAX,EAAA6D,KAAA5D,UACAwQ,EAAA5M,KAAA+D,MAAA2J,IAAAd,OAEApQ,EAAAoQ,EAAArQ,EAAAK,EAAA,EACAF,EAAAkQ,EAAAnQ,EAAAK,EAAA,EAEA,GAAAF,EAAAT,EAAAS,MAAA,CACA,IAAAC,EAAAL,EAAAI,EAEAJ,EAAAjB,KAAA0D,IAAAzC,EAAA,GAEAK,EAAAV,EAAAS,QACAJ,GAAAK,EAAAV,EAAAS,MAEA,CAEA,GAAAE,EAAAX,EAAAW,OAAA,CACA,IAAAf,EAAAiE,KAAA+D,MAAAhI,KACA2a,EAAA3a,EAAA4a,cAAAla,EACAM,EAAAL,EAAAI,EAEAJ,EAAAnB,KAAA0D,IAAAvC,EAAAX,EAAAE,OAAAQ,GAEAM,EAAA2Z,IACAha,GAAAK,EAAA2Z,EAEA,CAEA,MAAA,CACAla,KAAAA,EACAE,IAAAA,EAEA,IAKAka,GAAAJ,GAAA9W,OAAA,CACA0C,aAAA,WACA,IAAAsD,EAAA1F,KAAA5C,QAAA2G,MACA,iBAAA2B,EAAA+I,aACA/I,EAAA+I,WANA,IASA/I,EAAAgJ,SAAAhJ,EAAA+I,WAAA,IAEA+H,GAAA5Q,GAAAxD,aAAAyD,KAAA7F,KACA,IAGA1G,MAAAQ,WAAAR,MAAAC,QAAA,CACAiG,MAAAA,EACAuM,YAAAA,GACA/D,cAAAA,EACA4B,mBAAAA,GACAoB,iBAAAA,GACAxF,YAAAA,EACAqO,YAAAA,GACAb,cAAAA,GACA5E,YAAAA,GACAoI,SAAAA,GACAP,aAAAA,GACAhB,SAAAA,GACA2B,cAAAA,IAGA,CApwEA,CAowEAvd,OAAAC,MAAAud,QAEA,SAAAzd,GACA,IAAAE,EAAAD,OAAAC,MACAwd,EAAAxd,EAAAyd,GAAAD,OACAvd,EAAAD,EAAAC,QACAwS,EAAAxS,EAAAwS,YACA8H,EAAAta,EAAAsa,YACA2C,EAAAjd,EAAAid,SACAI,EAAArd,EAAAqd,cACA3V,EAAA3H,EAAAgB,QAEA,SAAA0c,EAAA5Z,GACA,IAAA6Z,EAAA1d,EAAAwd,GAAAE,QAAA,CAAA,EACAC,EAAA9Z,EAAA0C,OAAA,GACAqX,EAAAD,EAAAE,cAEA,OAAA,GAAA7d,EAAA8d,YAAAC,QAAAH,GACA5d,EAAAge,YAAAC,OAGAP,EAAAC,IAAAD,EAAAE,IAAA,CAAA,GAAAK,KACA,CAEA,IAAAhY,EAAAsX,EAAApX,OAAA,CACAC,KAAA,SAAAC,EAAAC,GACAvG,EAAAgH,QAAAV,GACAxG,EAAAwG,GAAA6X,QAEAX,EAAAlR,GAAAjG,KAAAkG,KAAA7F,KAAAJ,GAEAI,KAAA5C,QAAA9D,EAAAQ,WAAAkG,KAAA5C,QAAAyC,GAEAG,KAAArC,QAAAqC,KAAAJ,QACAI,KAAA0X,kBAEA1X,KAAAJ,QAAA+X,SAAA,WAEAre,EAAAse,OAAA5X,KAAAzG,EAAAwd,GACA,EAEA3Z,QAAA,CACA0C,MAAA,OACAqD,SAAA,GACAzC,QAAA,CAAA,EACAqD,MAAA,CAAA,EACA7B,UAAA,CACAxE,WAAA,IAEAoE,aAAA,GAGAS,WAAA,SAAAnF,GACA4C,KAAA6X,UAAAtV,WAAAnF,EAAA4Z,EAAA5Z,IAEA4C,KAAA8X,aACA,EAEAzX,OAAA,WACAL,KAAA6X,UAAAxX,SACAL,KAAA8X,aACA,EAEAxX,QAAA,WACAwW,EAAAlR,GAAAtF,QAAAuF,KAAA7F,MACAA,KAAA6X,UAAAvX,SACA,EAEAoX,gBAAA,WACA,IAAAK,EAAA/X,KAAAgY,aACAhY,KAAA6X,UAAA,IAAAE,EAAA/X,KAAAJ,QAAA,GAAAI,KAAA5C,QAAA4Z,EAAAhX,KAAA5C,UACA4C,KAAA8X,aACA,EAEAA,YAAA,WACA9X,KAAAG,iBAAAH,KAAA6X,UAAA1X,iBACAH,KAAA5C,QAAA4C,KAAA6X,UAAAza,QACA4C,KAAAO,QAAAP,KAAA6X,UAAAtX,QACAP,KAAAjE,KAAAiE,KAAA6X,UAAA9b,KACAiE,KAAAkC,UAAAlC,KAAA6X,UAAA3V,UACAlC,KAAAW,SAAAX,KAAA6X,UAAAlX,SACAX,KAAA+D,MAAA/D,KAAA6X,UAAA9T,KACA,EAEAkU,QAAA,WACAjY,KAAA6X,UAAAjW,QACA,IAGAsW,EAAA,CAAA,UAAA,QAAA,YAAA,gBAEA,SAAAC,EAAAC,GACA5Y,EAAAoG,GAAAwS,GAAA,WACA,OAAApY,KAAA6X,UAAAO,GAAAC,MAAArY,KAAA6X,UAAAjX,UACA,CACA,CAEA,IAAA,IAAAyV,EAAA,EAAAA,EAAA6B,EAAArX,OAAAwV,IACA8B,EAAAD,EAAA7B,IAGA9c,EAAA+e,YAAA5Y,OAAAF,EAAAoG,IAEA,IAAA2S,EAAA/Y,EAAAE,OAAA,CAEAtC,QAAA,CACAgb,KAAA,eAGAJ,WAAA,WACA,OAAAnE,CACA,IAGA2E,EAAAhZ,EAAAE,OAAA,CAEAtC,QAAA,CACAgb,KAAA,cACArU,MAAA,CACAW,UAAA,IAIAsT,WAAA,WACA,OAAAjM,CACA,IAGA0M,EAAAjZ,EAAAE,OAAA,CACAC,KAAA,SAAAC,EAAAC,GACAL,EAAAoG,GAAAjG,KAAAkG,KAAA7F,KAAAJ,EAAAC,GAEAG,KAAAJ,QAAA8Y,IAAA,WAAA,YACA1Y,KAAAJ,QAAA+X,SAAA,cAEA3X,KAAA2Y,iBACA,EAEAvb,QAAA,CACAgb,KAAA,YAGA7V,WAAA,SAAAnF,GACAoC,EAAAoG,GAAArD,WAAAsD,KAAA7F,KAAA5C,GACA4C,KAAA2Y,iBACA,EAEAtY,OAAA,WACAb,EAAAoG,GAAAvF,OAAAwF,KAAA7F,MACAA,KAAA2Y,iBACA,EAEA3c,MAAA,SAAAA,GACA,IAAA4c,EAAA5Y,KAAA6X,UACA,GAAA,IAAAjX,UAAAC,OACA,OAAA+X,EAAA5c,QAGA4c,EAAA5c,MAAAA,GAEAgE,KAAA2Y,iBACA,EAEArY,QAAA,WACAd,EAAAoG,GAAAtF,QAAAuF,KAAA7F,aACAA,KAAA6Y,cACA,EAEA1X,aAAA,WACA,OAAAnB,KAAA6Y,gBAIArZ,EAAAoG,GAAAzE,aAAA0E,KAAA7F,KACA,EAEAiY,QAAA,WACAjY,KAAA6X,UAAAjW,SAEA5B,KAAA2Y,iBACA,EAEAA,gBAAA,WACA,GAAA3Y,KAAA5C,QAAA0b,eAAA,CACA,IAAAC,EAAAzf,EAAAyf,SAAA/Y,KAAA5C,QAAA0b,gBAEAF,EAAA5Y,KAAA6X,UACAmB,EAAAhZ,KAAAiZ,oBAEAD,EAAAE,KAAAH,EAAA,CAAA5a,MAAAya,EAAAjD,eAAA3Z,MAAA4c,EAAA5c,WAEA,IAAAuI,EAAAqU,EAAAnC,oBAAAuC,EAAApc,QAAAoc,EAAAlc,UAEAkc,EAAAN,IAAAnU,EACA,MAAAvE,KAAA6Y,iBACA7Y,KAAA6Y,eAAAM,SACAnZ,KAAA6Y,eAAA,KAEA,EAEAI,kBAAA,WACA,IAAAD,EAAAhZ,KAAA6Y,eAMA,OALAG,IACAA,EAAAhZ,KAAA6Y,eAAAzf,EAAA,eAAAue,SAAA,oBACA3X,KAAAJ,QAAAf,OAAAma,IAGAA,CACA,EAEAhB,WAAA,WACA,OAAAxB,CACA,IAGA4C,EAAAX,EAAA/Y,OAAA,CACAtC,QAAA,CACAgb,KAAA,iBAGAJ,WAAA,WACA,OAAApB,CACA,IAGA,SAAAyC,EAAAjB,GACAK,EAAA7S,GAAAwS,GAAA,SAAAhb,GACA,IAAAoa,EAAAxX,KACAsZ,EAAArY,EAAAmX,GAEA,OAAAZ,EAAAqB,eAIA5X,EAAAsY,QAAA/B,EAAA5X,SAAA4Z,MAAA,SAAAC,GACA,OAAAH,EAAAG,EAAArc,EACA,IALAkc,EAAA9B,EAAArW,eAAA/D,EAMA,CACA,CAEA,IAAAsc,EAAA,CAAA,YAAA,cAAA,aAEA,IAAArD,EAAA,EAAAA,EAAAqD,EAAA7Y,OAAAwV,IACAgD,EAAAK,EAAArD,IAGA9c,EAAAwd,GAAA4C,OAAAnB,GACAjf,EAAAwd,GAAA4C,OAAApB,GACAhf,EAAAwd,GAAA4C,OAAAlB,GACAlf,EAAAwd,GAAA4C,OAAAP,GAEA9f,EAAAQ,WAAAP,EAAA,CACAiG,MAAAA,EACAuM,YAAAyM,EACA3E,YAAA0E,EACA/B,SAAAiC,EACA7B,cAAAwC,GAGA,CAjQA,CAiQA/f,OAAAC,MAAAud,QAEA,IAAA+C,SAAA,CACAC,GAAA,gBACAzB,KAAA,QACA0B,SAAA,UACAC,YAAA,iCACAC,QAAA,CAAA,eAAA,mBAGAC,QAAA3gB,aAEA2gB","file":"kendo.dataviz.gauge.js","sourcesContent":["import './kendo.core.js';\nimport './kendo.color.js';\nimport './kendo.drawing.js';\nimport './kendo.dataviz.core.js';\nimport './kendo.dataviz.themes.js';\n\n/***********************************************************************\n * WARNING: this file is auto-generated.  If you change it directly,\n * your modifications will eventually be lost.  The source code is in\n * `kendo-charts` repository, you should make your changes there and\n * run `src-modules/sync.sh` in this repository.\n */\n\n(function($) {\n/* eslint-disable space-before-blocks, space-before-function-paren */\n\nwindow.kendo.dataviz = window.kendo.dataviz || {};\nvar dataviz = kendo.dataviz;\nvar getSpacing = dataviz.getSpacing;\nvar defined = dataviz.defined;\nvar constants = dataviz.constants;\nvar BLACK = constants.BLACK;\nvar COORD_PRECISION = constants.COORD_PRECISION;\nvar services = dataviz.services;\nvar deepExtend = dataviz.deepExtend;\nvar isArray = dataviz.isArray;\nvar setDefaultOptions = dataviz.setDefaultOptions;\nvar NumericAxis = dataviz.NumericAxis;\nvar limitValue = dataviz.limitValue;\nvar Box = dataviz.Box;\nvar interpolateValue = dataviz.interpolateValue;\nvar round = dataviz.round;\nvar drawing = kendo.drawing;\nvar DrawingGroup = drawing.Group;\nvar DrawingPath = drawing.Path;\nvar Animation = drawing.Animation;\nvar AnimationFactory = drawing.AnimationFactory;\nvar geometry = kendo.geometry;\nvar Rect = geometry.Rect;\nvar GeometryPoint = geometry.Point;\nvar transform = geometry.transform;\n\nvar ANGULAR_SPEED = 150;\nvar LINEAR_SPEED = 250;\nvar ARROW = \"arrow\";\nvar ARROW_POINTER = \"arrowPointer\";\nvar BAR_POINTER = \"barPointer\";\nvar DEFAULT_HEIGHT = 200;\nvar DEFAULT_LINE_WIDTH = 0.5;\nvar DEFAULT_WIDTH = 200;\nvar DEGREE = Math.PI / 180;\nvar INSIDE = \"inside\";\nvar LINEAR = \"linear\";\nvar OUTSIDE = \"outside\";\nvar RADIAL_POINTER = \"radialPointer\";\nvar RADIAL_RANGE_POINTER = \"radialRangePointer\";\n\nfunction pad(bbox, value) {\n    var origin = bbox.getOrigin();\n    var size = bbox.getSize();\n    var spacing = getSpacing(value);\n\n    bbox.setOrigin([ origin.x - spacing.left, origin.y - spacing.top ]);\n    bbox.setSize([ size.width + (spacing.left + spacing.right), size.height + (spacing.top + spacing.bottom) ]);\n\n    return bbox;\n}\n\nvar Group = DrawingGroup;\nvar Path$1 = DrawingPath;\nvar Text = drawing.Text;\n\nfunction buildLabelElement(label, options) {\n    var labelBox = label.box;\n    var textBox = label.children[0].box;\n    var border = options.border || {};\n    var background = options.background || \"\";\n\n    var wrapper = Path$1.fromRect(new Rect([ labelBox.x1, labelBox.y1 ], [ labelBox.width(), labelBox.height() ]), {\n        stroke: {}\n    });\n\n    var text = new Text(label.text, new GeometryPoint(textBox.x1, textBox.y1), {\n        font: options.font,\n        fill: { color: options.color }\n    });\n\n    var styleGeometry = pad(text.bbox().clone(), options.padding);\n\n    var styleBox = Path$1.fromRect(styleGeometry, {\n        stroke: {\n            color: border.width ? border.color : \"\",\n            width: border.width,\n            opacity: border.opacity,\n            dashType: border.dashType,\n            lineJoin: \"round\",\n            lineCap: \"round\"\n        },\n        fill: {\n            color: background\n        }\n    });\n\n    var elements = new Group();\n    elements.append(wrapper);\n    elements.append(styleBox);\n    elements.append(text);\n\n    return elements;\n}\n\nfunction getRange(range, min, max) {\n    var from = defined(range.from) ? range.from : constants.MIN_VALUE;\n    var to = defined(range.to) ? range.to : constants.MAX_VALUE;\n\n    range.from = Math.max(Math.min(to, from), min);\n    range.to = Math.min(Math.max(to, from), max);\n\n    return range;\n}\n\nfunction unpad(bbox, value) {\n    var spacing = getSpacing(value);\n\n    spacing.left = -spacing.left; spacing.top = -spacing.top;\n    spacing.right = -spacing.right; spacing.bottom = -spacing.bottom;\n\n    return pad(bbox, spacing);\n}\n\nvar DEFAULT_MARGIN = 5;\nvar Path = DrawingPath;\nvar Surface = drawing.Surface;\n\nvar Gauge = dataviz.Class.extend({\n    init: function(element, userOptions, theme, context) {\n        if (context === void 0) { context = {}; }\n\n        this.element = element;\n        this.theme = theme;\n        this.contextService = new services.ChartService(this, context);\n        this._originalOptions = deepExtend({}, this.options, userOptions);\n        this.options = deepExtend({}, this._originalOptions);\n        this._initTheme(theme);\n\n        this.redraw();\n    },\n\n    destroy: function() {\n        if (this.surface) {\n            this.surface.destroy();\n            this.surface = null;\n        }\n\n        delete this.element;\n        delete this.surfaceElement;\n    },\n\n    value: function(pointerValue) {\n        var pointer = this.pointers[0];\n\n        if (arguments.length === 0) {\n            return pointer.value();\n        }\n\n        pointer.value(pointerValue);\n        this._setValueOptions(pointerValue);\n    },\n\n    _draw: function() {\n        var surface = this.surface;\n\n        surface.clear();\n        surface.draw(this._visuals);\n    },\n\n    exportVisual: function() {\n        return this._visuals;\n    },\n\n    allValues: function(values) {\n        var pointers = this.pointers;\n        var allValues = [];\n\n        if (arguments.length === 0) {\n            for (var i = 0; i < pointers.length; i++) {\n                allValues.push(pointers[i].value());\n            }\n\n            return allValues;\n        }\n\n        if (isArray(values)) {\n            for (var i$1 = 0; i$1 < values.length; i$1++) {\n                if (dataviz.isNumber(values[i$1])) {\n                    pointers[i$1].value(values[i$1]);\n                }\n            }\n        }\n\n        this._setValueOptions(values);\n    },\n\n    _setValueOptions: function(values) {\n        var pointers = [].concat(this.options.pointer);\n        var arrayValues = [].concat(values);\n\n        for (var i = 0; i < arrayValues.length; i++) {\n            pointers[i].value = arrayValues[i];\n        }\n    },\n\n    resize: function() {\n        this.noTransitionsRedraw();\n    },\n\n    noTransitionsRedraw: function() {\n        var transitions = this.options.transitions;\n\n        this._toggleTransitions(false);\n\n        this.redraw();\n\n        this._toggleTransitions(transitions);\n    },\n\n    redraw: function() {\n        var size = this._surfaceSize();\n        var wrapper = new Rect([ 0, 0 ], [ size.width, size.height ]);\n\n        this._initSurface();\n\n        this.gaugeArea = this._createGaugeArea();\n\n        this._createModel();\n\n        var bbox = unpad(wrapper.bbox(), this._gaugeAreaMargin);\n        this.reflow(bbox);\n    },\n\n    setOptions: function(options, theme) {\n        this._originalOptions = deepExtend(this._originalOptions, options);\n        this.options = deepExtend({}, this._originalOptions);\n\n        this._initTheme(theme);\n\n        this.redraw();\n    },\n\n    setDirection: function(rtl) {\n        this.contextService.rtl = Boolean(rtl);\n        if (this.surface && this.surface.type === 'svg') {\n            this.surface.destroy();\n            this.surface = null;\n        }\n    },\n\n    setIntlService: function(intl) {\n        this.contextService.intl = intl;\n    },\n\n    _initTheme: function(theme) {\n        var currentTheme = theme || this.theme || {};\n        this.theme = currentTheme;\n\n        this.options = deepExtend({}, currentTheme, this.options);\n        var options = this.options;\n        var pointer = options.pointer;\n\n        if (isArray(pointer)) {\n            var pointers = [];\n            for (var i = 0; i < pointer.length; i++) {\n                pointers.push(deepExtend({}, currentTheme.pointer, pointer[i]));\n            }\n            options.pointer = pointers;\n        }\n    },\n\n    _createGaugeArea: function() {\n        var options = this.options.gaugeArea;\n        var size = this.surface.size();\n        var border = options.border || {};\n        var areaGeometry = new Rect([ 0, 0 ], [ size.width, size.height ]);\n\n        this._gaugeAreaMargin = options.margin || DEFAULT_MARGIN;\n\n        if (border.width > 0) {\n            areaGeometry = unpad(areaGeometry, border.width);\n        }\n\n        var gaugeArea = Path.fromRect(areaGeometry, {\n            stroke: {\n                color: border.width ? border.color : \"\",\n                width: border.width,\n                opacity: border.opacity,\n                dashType: border.dashType,\n                lineJoin: \"round\",\n                lineCap: \"round\"\n            },\n            fill: {\n                color: options.background\n            }\n        });\n\n        return gaugeArea;\n    },\n\n    _initSurface: function() {\n        var ref = this;\n        var options = ref.options;\n        var surface = ref.surface;\n        var element = this._surfaceElement();\n        var size = this._surfaceSize();\n\n        dataviz.elementSize(element, size);\n\n        if (!surface || surface.options.type !== options.renderAs) {\n            if (surface) {\n                surface.destroy();\n            }\n\n            this.surface = Surface.create(element, {\n                type: options.renderAs\n            });\n        } else {\n            this.surface.clear();\n            this.surface.resize();\n        }\n    },\n\n    _surfaceSize: function() {\n        var options = this.options;\n        var size = this._getSize();\n\n        if (options.gaugeArea) {\n            deepExtend(size, options.gaugeArea);\n        }\n\n        return size;\n    },\n\n    _surfaceElement: function() {\n        if (!this.surfaceElement) {\n            this.surfaceElement = document.createElement('div');\n            this.element.appendChild(this.surfaceElement);\n        }\n\n        return this.surfaceElement;\n    },\n\n    getSize: function() {\n        return this._getSize();\n    },\n\n    _getSize: function() {\n        var element = this.element;\n        var defaultSize = this._defaultSize();\n        var width = element.offsetWidth;\n        var height = element.offsetHeight;\n\n        if (!width) {\n            width = defaultSize.width;\n        }\n\n        if (!height) {\n            height = defaultSize.height;\n        }\n\n        return { width: width, height: height };\n    },\n\n    _defaultSize: function() {\n        return {\n            width: DEFAULT_WIDTH,\n            height: DEFAULT_HEIGHT\n        };\n    },\n\n    _toggleTransitions: function(value) {\n        var this$1$1 = this;\n\n        this.options.transitions = value;\n        for (var i = 0; i < this.pointers.length; i++) {\n            this$1$1.pointers[i].options.animation.transitions = value;\n        }\n    }\n});\n\nsetDefaultOptions(Gauge, {\n    plotArea: {},\n    theme: \"sass\",\n    renderAs: \"\",\n    pointer: {},\n    scale: {},\n    gaugeArea: {}\n});\n\nvar Path$2 = DrawingPath;\nvar Group$2 = DrawingGroup;\nvar Point = GeometryPoint;\n\nfunction renderAxisTick(tickRenderOptions, tickOptions) {\n    var position = tickRenderOptions.position;\n    var tickX = tickRenderOptions.tickX;\n    var tickY = tickRenderOptions.tickY;\n    var start, end;\n\n    if (tickRenderOptions.vertical) {\n        start = new Point(tickX, position);\n        end = new Point(tickX + tickOptions.size, position);\n    } else {\n        start = new Point(position, tickY);\n        end = new Point(position, tickY + tickOptions.size);\n    }\n\n    var tickPath = new Path$2({\n        stroke: {\n            color: tickOptions.color,\n            width: tickOptions.width\n        }\n    }).moveTo(start).lineTo(end);\n\n    return tickPath;\n}\n\nfunction renderTicks(tickGroup, tickPositions, tickRenderOptions, tickOptions) {\n    var count = tickPositions.length;\n\n    if (tickOptions.visible) {\n        var mirror = tickRenderOptions.mirror;\n        var lineBox = tickRenderOptions.lineBox;\n        for (var i = tickOptions.skip; i < count; i += tickOptions.step) {\n            if (i % tickOptions.skipUnit === 0) {\n                continue;\n            }\n\n            tickRenderOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;\n            tickRenderOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;\n            tickRenderOptions.position = tickPositions[i];\n\n            tickGroup.append(renderAxisTick(tickRenderOptions, tickOptions));\n        }\n    }\n}\n\nvar LinearScale = NumericAxis.extend({\n    init: function(options, service) {\n        var scaleOptions = options || {};\n        if (!defined(scaleOptions.reverse) && scaleOptions.vertical === false && (service || {}).rtl) {\n            scaleOptions = $.extend({}, scaleOptions, {\n                reverse: true\n            });\n        }\n\n        NumericAxis.fn.init.call(this, 0, 1, scaleOptions, service);\n\n        this.options.minorUnit = this.options.minorUnit || this.options.majorUnit / 10;\n    },\n\n    initUserOptions: function(options) {\n        var scaleOptions = deepExtend({}, this.options, options);\n        scaleOptions = deepExtend({}, scaleOptions , { labels: { mirror: scaleOptions.mirror } });\n        scaleOptions.majorUnit = scaleOptions.majorUnit || dataviz.autoMajorUnit(scaleOptions.min, scaleOptions.max);\n\n        return scaleOptions;\n    },\n\n    initFields: function() {\n    },\n\n    render: function() {\n        var elements = this.elements = new Group$2();\n        var labels = this.renderLabels();\n        var scaleLine = this.renderLine();\n        var scaleTicks = this.renderTicks();\n        var ranges = this.renderRanges();\n\n        elements.append(scaleLine, labels, scaleTicks, ranges);\n\n        return elements;\n    },\n\n    renderRanges: function() {\n        var this$1$1 = this;\n\n        var options = this.options;\n        var min = options.min;\n        var max = options.max;\n        var vertical = options.vertical;\n        var mirror = options.labels.mirror;\n        var ranges = options.ranges || [];\n        var elements = new Group$2();\n        var count = ranges.length;\n        var rangeSize = options.rangeSize || options.minorTicks.size / 2;\n\n        for (var i = 0; i < count; i++) {\n            var range = getRange(ranges[i], min, max);\n            var slot = this$1$1.getSlot(range.from, range.to);\n            var slotX = vertical ? this$1$1.lineBox() : slot;\n            var slotY = vertical ? slot : this$1$1.lineBox();\n            if (vertical) {\n                slotX.x1 -= rangeSize * (mirror ? -1 : 1);\n            } else {\n                slotY.y2 += rangeSize * (mirror ? -1 : 1);\n            }\n\n            elements.append(Path$2.fromRect(new Rect([ slotX.x1, slotY.y1 ], [ slotX.x2 - slotX.x1, slotY.y2 - slotY.y1 ]), {\n                fill: { color: range.color, opacity: range.opacity },\n                stroke: { }\n            }));\n        }\n\n        return elements;\n    },\n\n    renderLabels: function() {\n        var ref = this;\n        var labels = ref.labels;\n        var options = ref.options;\n        var elements = new Group$2();\n\n        for (var i = 0; i < labels.length; i++) {\n            elements.append(buildLabelElement(labels[i], options.labels));\n        }\n\n        return elements;\n    },\n\n    renderLine: function() {\n        var line = this.options.line;\n        var lineBox = this.lineBox();\n        var elements = new Group$2();\n\n        if (line.width > 0 && line.visible) {\n            var linePath = new Path$2({\n                stroke: {\n                    color: line.color,\n                    dashType: line.dashType,\n                    width: line.width\n                }\n            });\n\n            linePath.moveTo(lineBox.x1, lineBox.y1).lineTo(lineBox.x2, lineBox.y2);\n            elements.append(linePath);\n        }\n\n        return elements;\n    },\n\n    renderTicks: function() {\n        var ticks = new Group$2();\n        var options = this.options;\n        var majorUnit = options.majorTicks.visible ? options.majorUnit : 0;\n        var tickRenderOptions = {\n            vertical: options.vertical,\n            mirror: options.labels.mirror,\n            lineBox: this.lineBox()\n        };\n\n        renderTicks(ticks, this.getMajorTickPositions(), tickRenderOptions, options.majorTicks);\n        renderTicks(ticks, this.getMinorTickPositions(), tickRenderOptions, deepExtend({}, {\n            skipUnit: majorUnit / options.minorUnit\n        }, options.minorTicks));\n\n        return ticks;\n    }\n});\n\nsetDefaultOptions(LinearScale, {\n    min: 0,\n    max: 50,\n\n    majorTicks: {\n        size: 15,\n        align: INSIDE,\n        color: BLACK,\n        width: DEFAULT_LINE_WIDTH,\n        visible: true\n    },\n\n    minorTicks: {\n        size: 10,\n        align: INSIDE,\n        color: BLACK,\n        width: DEFAULT_LINE_WIDTH,\n        visible: true\n    },\n\n    line: {\n        width: DEFAULT_LINE_WIDTH\n    },\n\n    labels: {\n        position: INSIDE,\n        padding: 2\n    },\n    mirror: false,\n    _alignLines: false\n});\n\nvar Pointer = dataviz.Class.extend({\n    init: function(scale, userOptions) {\n\n        var ref = scale.options;\n        var min = ref.min;\n        var max = ref.max;\n        var options = this.options = deepExtend({}, this.options, userOptions);\n\n        options.fill = options.color;\n\n        this.scale = scale;\n\n        if (defined(options.value)) {\n            options.value = limitValue(options.value, min, max);\n        } else {\n            options.value = min;\n        }\n    },\n\n    value: function(newValue) {\n        var options = this.options;\n        var value = options.value;\n\n        if (arguments.length === 0) {\n            return value;\n        }\n\n        var ref = this.scale.options;\n        var min = ref.min;\n        var max = ref.max;\n\n        options._oldValue = defined(options._oldValue) ? options.value : min;\n        options.value = limitValue(newValue, min, max);\n\n        if (this.elements) {\n            this.repaint();\n        }\n    }\n});\n\nsetDefaultOptions(Pointer, {\n    color: BLACK\n});\n\nvar LinearPointer = Pointer.extend({\n    init: function(scale, options) {\n        Pointer.fn.init.call(this, scale, options);\n\n        this.options = deepExtend({\n            track: {\n                visible: defined(options.track)\n            }\n        }, this.options);\n    },\n\n    reflow: function() {\n        var ref = this;\n        var options = ref.options;\n        var scale = ref.scale;\n        var ref$1 = scale.options;\n        var mirror = ref$1.mirror;\n        var vertical = ref$1.vertical;\n        var scaleLine = scale.lineBox();\n        var trackSize = options.track.size || options.size;\n        var pointerHalfSize = options.size / 2;\n        var margin = getSpacing(options.margin);\n        var space = vertical ?\n            margin[mirror ? \"left\" : \"right\"] :\n            margin[mirror ? \"bottom\" : \"top\"];\n        var pointerBox, pointerRangeBox, trackBox;\n\n        space = mirror ? -space : space;\n\n        if (vertical) {\n            trackBox = new Box(\n                scaleLine.x1 + space, scaleLine.y1,\n                scaleLine.x1 + space, scaleLine.y2);\n\n            if (mirror) {\n                trackBox.x1 -= trackSize;\n            } else {\n                trackBox.x2 += trackSize;\n            }\n\n            if (options.shape !== BAR_POINTER) {\n                pointerRangeBox = new Box(\n                    scaleLine.x2 + space, scaleLine.y1 - pointerHalfSize,\n                    scaleLine.x2 + space, scaleLine.y2 + pointerHalfSize\n                );\n                pointerBox = pointerRangeBox;\n            }\n        } else {\n            trackBox = new Box(\n                scaleLine.x1, scaleLine.y1 - space,\n                scaleLine.x2, scaleLine.y1 - space);\n\n            if (mirror) {\n                trackBox.y2 += trackSize;\n            } else {\n                trackBox.y1 -= trackSize;\n            }\n\n            if (options.shape !== BAR_POINTER) {\n                pointerRangeBox = new Box(\n                    scaleLine.x1 - pointerHalfSize, scaleLine.y1 - space,\n                    scaleLine.x2 + pointerHalfSize, scaleLine.y1 - space\n                );\n                pointerBox = pointerRangeBox;\n            }\n        }\n\n        this.trackBox = trackBox;\n        this.pointerRangeBox = pointerRangeBox;\n        this.box = pointerBox || trackBox.clone().pad(options.border.width);\n    },\n\n    getElementOptions: function() {\n        var options = this.options;\n\n        return {\n            fill: {\n                color: options.color,\n                opacity: options.opacity\n            },\n            stroke: defined(options.border) ? {\n                color: options.border.width ? options.border.color || options.color : \"\",\n                width: options.border.width,\n                dashType: options.border.dashType,\n                opacity: options.opacity\n            } : null\n        };\n    },\n\n    _margin: function() {\n        var ref = this;\n        var scale = ref.scale;\n        var options = ref.options;\n        var ref$1 = scale.options;\n        var mirror = ref$1.mirror;\n        var vertical = ref$1.vertical;\n        var margin = getSpacing(options.margin);\n\n        var space = vertical ?\n            margin[mirror ? \"left\" : \"right\"] :\n            margin[mirror ? \"bottom\" : \"top\"];\n\n        return space;\n    }\n});\n\nsetDefaultOptions(LinearPointer, {\n    shape: BAR_POINTER,\n\n    track: {\n        border: {\n            width: 1\n        }\n    },\n\n    color: BLACK,\n    border: {\n        width: 1\n    },\n    opacity: 1,\n\n    margin: getSpacing(3),\n    animation: {\n        type: BAR_POINTER\n    },\n    visible: true\n});\n\nvar ArrowLinearPointerAnimation = Animation.extend({\n    setup: function() {\n        var options = this.options;\n        var margin = options.margin;\n        var from = options.from;\n        var to = options.to;\n        var vertical = options.vertical;\n        var axis = vertical ? \"x1\" : \"y1\";\n\n        if (options.mirror === vertical) {\n            from[axis] -= margin; to[axis] -= margin;\n        } else {\n            from[axis] += margin; to[axis] += margin;\n        }\n\n        var fromScale = this.fromScale = new GeometryPoint(from.x1, from.y1);\n        var toScale = this.toScale = new GeometryPoint(to.x1, to.y1);\n\n        if (options.duration !== 0) {\n            options.duration = Math.max((fromScale.distanceTo(toScale) / options.duration) * 1000, 1);\n        }\n    },\n\n    step: function(pos) {\n        var translateX = interpolateValue(this.fromScale.x, this.toScale.x, pos);\n        var translateY = interpolateValue(this.fromScale.y, this.toScale.y, pos);\n\n        this.element.transform(transform().translate(translateX, translateY));\n    }\n});\n\nsetDefaultOptions(ArrowLinearPointerAnimation, {\n    easing: LINEAR,\n    duration: LINEAR_SPEED\n});\n\nAnimationFactory.current.register(ARROW_POINTER, ArrowLinearPointerAnimation);\n\nvar Point$1 = GeometryPoint;\nvar Path$3 = DrawingPath;\n\nvar ArrowLinearPointer = LinearPointer.extend({\n    init: function(scale, options) {\n        LinearPointer.fn.init.call(this, scale, options);\n\n        if (!defined(this.options.size)) {\n            this.options.size = this.scale.options.majorTicks.size * 0.6;\n        }\n    },\n\n    pointerShape: function() {\n        var ref = this;\n        var scale = ref.scale;\n        var size = ref.options.size;\n        var halfSize = size / 2;\n        var sign = (scale.options.mirror ? -1 : 1);\n        var shape;\n\n        if (scale.options.vertical) {\n            shape = [\n                new Point$1(0, 0 - halfSize), new Point$1(0 - sign * size, 0), new Point$1(0, 0 + halfSize)\n            ];\n        } else {\n            shape = [\n                new Point$1(0 - halfSize, 0), new Point$1(0, 0 + sign * size), new Point$1(0 + halfSize, 0)\n            ];\n        }\n\n        return shape;\n    },\n\n    repaint: function() {\n        var ref = this;\n        var scale = ref.scale;\n        var options = ref.options;\n        var animation = new ArrowLinearPointerAnimation(this.elements, deepExtend(options.animation, {\n            vertical: scale.options.vertical,\n            mirror: scale.options.mirror,\n            margin: this._margin(options.margin),\n            from: scale.getSlot(options._oldValue),\n            to: scale.getSlot(options.value)\n        }));\n\n        if (options.animation.transitions === false) {\n            animation.options.duration = 0;\n        }\n\n        animation.setup();\n        animation.play();\n    },\n\n    render: function() {\n        var ref = this;\n        var scale = ref.scale;\n        var options = ref.options;\n        var elementOptions = this.getElementOptions();\n        var shape = this.pointerShape(options.value);\n\n        options.animation.type = ARROW_POINTER;\n\n        var elements = new Path$3({\n            stroke: elementOptions.stroke,\n            fill: elementOptions.fill\n        }).moveTo(shape[0]).lineTo(shape[1]).lineTo(shape[2]).close();\n\n        var slot = scale.getSlot(options.value);\n        elements.transform(transform().translate(slot.x1, slot.y1));\n\n        this.elements = elements;\n\n        return elements;\n    }\n});\n\nvar BarLinearPointerAnimation = Animation.extend({\n    setup: function() {\n        var options = this.options;\n        var axis = this.axis = options.vertical ? constants.Y : constants.X;\n        var to = this.to = options.newPoints[0][axis];\n        var from = this.from = options.oldPoints[0][axis];\n\n        if (options.duration !== 0) {\n            options.duration = Math.max((Math.abs(to - from) / options.speed) * 1000, 1);\n        }\n\n        this._set(from);\n    },\n\n    step: function(pos) {\n        var value = interpolateValue(this.from, this.to, pos);\n        this._set(value);\n    },\n\n    _set: function(value) {\n        var setter = \"set\" + this.axis.toUpperCase();\n        var points = this.options.newPoints;\n\n        points[0][setter](value);\n        points[1][setter](value);\n    }\n});\n\nsetDefaultOptions(BarLinearPointerAnimation, {\n    easing: LINEAR,\n    speed: LINEAR_SPEED\n});\n\nAnimationFactory.current.register(BAR_POINTER, BarLinearPointerAnimation);\n\nvar Group$3 = DrawingGroup;\nvar Path$4 = DrawingPath;\n\nvar BarLinearPointer = LinearPointer.extend({\n    init: function(scale, options) {\n        LinearPointer.fn.init.call(this, scale, options);\n\n        if (!defined(this.options.size)) {\n            this.options.size = this.scale.options.majorTicks.size * 0.3;\n        }\n    },\n\n    pointerShape: function(value) {\n        var ref = this;\n        var scale = ref.scale;\n        var options = ref.options;\n        var ref$1 = scale.options;\n        var mirror = ref$1.mirror;\n        var vertical = ref$1.vertical;\n        var dir = mirror === vertical ? -1 : 1;\n        var size = options.size * dir;\n        var minSlot = scale.getSlot(scale.options.min);\n        var slot = scale.getSlot(value);\n        var axis = vertical ? constants.Y : constants.X;\n        var sizeAxis = vertical ? constants.X : constants.Y;\n        var margin = this._margin() * dir;\n\n        var p1 = new GeometryPoint();\n        p1[axis] = minSlot[axis + \"1\"];\n        p1[sizeAxis] = minSlot[sizeAxis + \"1\"];\n\n        var p2 = new GeometryPoint();\n        p2[axis] = slot[axis + \"1\"];\n        p2[sizeAxis] = slot[sizeAxis + \"1\"];\n\n        if (vertical) {\n            p1.translate(margin, 0);\n            p2.translate(margin, 0);\n        } else {\n            p1.translate(0, margin);\n            p2.translate(0, margin);\n        }\n\n        var p3 = p2.clone();\n        var p4 = p1.clone();\n\n        if (vertical) {\n            p3.translate(size, 0);\n            p4.translate(size, 0);\n        } else {\n            p3.translate(0, size);\n            p4.translate(0, size);\n        }\n\n        return [ p1, p2, p3, p4 ];\n    },\n\n    repaint: function() {\n        var ref = this;\n        var scale = ref.scale;\n        var options = ref.options;\n        var shape = this.pointerShape(options.value);\n        var pointerPath = this.pointerPath;\n        var oldShape = this.pointerShape(options._oldValue);\n\n        pointerPath.moveTo(shape[0]).lineTo(shape[1]).lineTo(shape[2]).lineTo(shape[3]).close();\n\n        var animation = new BarLinearPointerAnimation(pointerPath, deepExtend(options.animation, {\n            reverse: scale.options.reverse,\n            vertical: scale.options.vertical,\n            oldPoints: [ oldShape[1], oldShape[2] ],\n            newPoints: [ shape[1], shape[2] ]\n        }));\n\n        if (options.animation.transitions === false) {\n            animation.options.duration = 0;\n        }\n\n        animation.setup();\n        animation.play();\n    },\n\n    render: function() {\n        var group = new Group$3();\n        var elementOptions = this.getElementOptions();\n\n        if (this.options.track.visible) {\n            group.append(this.renderTrack());\n        }\n\n        var pointer = this.pointerPath = new Path$4({\n            stroke: elementOptions.stroke,\n            fill: elementOptions.fill\n        });\n\n        group.append(pointer);\n\n        this.elements = group;\n\n        return group;\n    },\n\n    renderTrack: function() {\n        var trackOptions = this.options.track;\n        var border = trackOptions.border || {};\n        var trackBox = this.trackBox.clone().pad(border.width || 0);\n\n        return new Path$4.fromRect(trackBox.toRect(), {\n            fill: {\n                color: trackOptions.color,\n                opacity: trackOptions.opacity\n            },\n            stroke: {\n                color: border.width ? border.color || trackOptions.color : \"\",\n                width: border.width,\n                dashType: border.dashType\n            }\n        });\n    }\n});\n\nvar DEFAULT_MIN_WIDTH = 60;\nvar DEFAULT_MIN_HEIGHT = 60;\n\nvar Group$1 = DrawingGroup;\n\nvar LinearGauge = Gauge.extend({\n    reflow: function(bbox) {\n        var pointers = this.pointers;\n        var bboxX = bbox.origin.x;\n        var bboxY = bbox.origin.y;\n\n        var box = new Box(bboxX, bboxY, bboxX + bbox.width(), bboxY + bbox.height());\n\n        this.scale.reflow(box);\n        this._shrinkScaleWidth(box);\n\n        for (var i = 0; i < pointers.length; i++) {\n            pointers[i].reflow();\n        }\n\n        this.bbox = this._getBox(box);\n        this._alignElements();\n        this._shrinkElements();\n        this._buildVisual();\n        this._draw();\n    },\n\n    _buildVisual: function() {\n        var visuals = new Group$1();\n        var scaleElements = this.scale.render();\n        var pointers = this.pointers;\n\n        visuals.append(this.gaugeArea);\n        visuals.append(scaleElements);\n\n        for (var i = 0; i < pointers.length; i++) {\n            var current = pointers[i];\n            visuals.append(current.render());\n            current.value(current.options.value);\n        }\n\n        this._visuals = visuals;\n    },\n\n    _createModel: function() {\n        var this$1$1 = this;\n\n        var options = this.options;\n        var scale = this.scale = new LinearScale(options.scale, this.contextService);\n\n        this.pointers = [];\n\n        var pointers = options.pointer;\n        pointers = isArray(pointers) ? pointers : [ pointers ];\n\n        for (var i = 0; i < pointers.length; i++) {\n            var currentOptions = deepExtend({}, pointers[i], {\n                animation: {\n                    transitions: options.transitions\n                }\n            });\n            var pointerType = currentOptions.shape === ARROW ? ArrowLinearPointer : BarLinearPointer;\n\n            this$1$1.pointers.push(new pointerType(scale, currentOptions));\n        }\n    },\n\n    _defaultSize: function() {\n        var vertical = this.options.scale.vertical;\n\n        return {\n            width: vertical ? DEFAULT_MIN_WIDTH : DEFAULT_WIDTH,\n            height: vertical ? DEFAULT_HEIGHT : DEFAULT_MIN_HEIGHT\n        };\n    },\n\n    _getBox: function(box) {\n        var ref = this;\n        var scale = ref.scale;\n        var pointers = ref.pointers;\n        var boxCenter = box.center();\n        var plotAreaBox = pointers[0].box.clone().wrap(scale.box);\n\n        for (var i = 0; i < pointers.length; i++) {\n            plotAreaBox.wrap(pointers[i].box.clone());\n        }\n\n        var size;\n        if (scale.options.vertical) {\n            size = plotAreaBox.width() / 2;\n            plotAreaBox = new Box(\n                boxCenter.x - size, box.y1,\n                boxCenter.x + size, box.y2\n            );\n        } else {\n            size = plotAreaBox.height() / 2;\n            plotAreaBox = new Box(\n                box.x1, boxCenter.y - size,\n                box.x2, boxCenter.y + size\n            );\n        }\n\n        return plotAreaBox;\n    },\n\n    _alignElements: function() {\n        var this$1$1 = this;\n\n        var ref = this;\n        var scale = ref.scale;\n        var pointers = ref.pointers;\n        var scaleBox = scale.box;\n        var box = pointers[0].box.clone().wrap(scale.box);\n        var plotAreaBox = this.bbox;\n\n        for (var i = 0; i < pointers.length; i++) {\n            box.wrap(pointers[i].box.clone());\n        }\n\n        var diff;\n        if (scale.options.vertical) {\n            diff = plotAreaBox.center().x - box.center().x;\n            scale.reflow(new Box(\n                scaleBox.x1 + diff, plotAreaBox.y1,\n                scaleBox.x2 + diff, plotAreaBox.y2\n            ));\n        } else {\n            diff = plotAreaBox.center().y - box.center().y;\n            scale.reflow(new Box(\n                scaleBox.x1, scaleBox.y1 + diff,\n                scaleBox.x2, scaleBox.y2 + diff\n            ));\n        }\n\n        for (var i$1 = 0; i$1 < pointers.length; i$1++) {\n            pointers[i$1].reflow(this$1$1.bbox);\n        }\n    },\n\n    _shrinkScaleWidth: function(bbox) {\n        var ref = this;\n        var scale = ref.scale;\n        if (!scale.options.vertical) {\n            var overflow = scale.contentBox().width() - bbox.width();\n            if (overflow > 0) {\n                scale.box.shrink(overflow, 0);\n                scale.box.alignTo(bbox, 'center');\n                scale.reflow(scale.box);\n            }\n        }\n    },\n\n    _shrinkElements: function() {\n        var this$1$1 = this;\n\n        var ref = this;\n        var scale = ref.scale;\n        var pointers = ref.pointers;\n        var scaleBox = scale.box.clone();\n        var pos = scale.options.vertical ? \"y\" : \"x\";\n        var pointerBox = pointers[0].box;\n\n        for (var i = 0; i < pointers.length; i++) {\n            pointerBox.wrap(pointers[i].box.clone());\n        }\n\n        scaleBox[pos + 1] += Math.max(scaleBox[pos + 1] - pointerBox[pos + 1], 0);\n        scaleBox[pos + 2] -= Math.max(pointerBox[pos + 2] - scaleBox[pos + 2], 0);\n\n        scale.reflow(scaleBox);\n\n        for (var i$1 = 0; i$1 < pointers.length; i$1++) {\n            pointers[i$1].reflow(this$1$1.bbox);\n        }\n    }\n});\n\nsetDefaultOptions(LinearGauge, {\n    transitions: true,\n    gaugeArea: {\n        background: \"\"\n    },\n    scale: {\n        vertical: true\n    }\n});\n\nvar GEO_ARC_ADJUST_ANGLE = 180;\n\nvar Arc = drawing.Arc;\nvar Path$5 = DrawingPath;\nvar Group$5 = DrawingGroup;\n\nfunction drawTicks(arc, tickAngles, unit, tickOptions) {\n    var ticks = new Group$5();\n    var center = arc.center;\n    var radius = arc.getRadiusX();\n\n    if (tickOptions.visible) {\n        for (var i = 0; i < tickAngles.length; i++) {\n            var tickStart = arc.pointAt(tickAngles[i]);\n            var tickEnd = new GeometryPoint(center.x + radius - tickOptions.size, center.y).rotate(tickAngles[i], center);\n\n            ticks.append(new Path$5({\n                stroke: {\n                    color: tickOptions.color,\n                    width: tickOptions.width\n                }\n            }).moveTo(tickStart).lineTo(tickEnd));\n        }\n    }\n\n    return ticks;\n}\n\nfunction rangeSegment(from, to, color, opacity) {\n    return { from: from, to: to, color: color, opacity: opacity };\n}\n\nvar RadialScale = NumericAxis.extend({\n    init: function(options, service) {\n        NumericAxis.fn.init.call(this, 0, 1, options, service);\n    },\n\n    initUserOptions: function(options) {\n        var scaleOptions = deepExtend({}, this.options, options);\n        scaleOptions.majorUnit = scaleOptions.majorUnit || dataviz.autoMajorUnit(scaleOptions.min, scaleOptions.max);\n        scaleOptions.minorUnit = scaleOptions.minorUnit || scaleOptions.majorUnit / 10;\n\n        return scaleOptions;\n    },\n\n    initFields: function() {\n    },\n\n    render: function(center, radius) {\n        var arc = this.renderArc(center, radius);\n\n        this.bbox = arc.bbox();\n        this.labelElements = this.renderLabels();\n        this.ticks = this.renderTicks();\n        this.ranges = this.renderRanges();\n    },\n\n    reflow: function(bbox) {\n        var center = bbox.center();\n        var radius = Math.min(bbox.height(), bbox.width()) / 2;\n\n        if (defined(this.bbox)) {\n            this.bbox = this.arc.bbox();\n            this.radius(this.arc.getRadiusX());\n            this.repositionRanges();\n            this.renderLabels();\n        } else {\n            return this.render(center, radius);\n        }\n    },\n\n    slotAngle: function(value) {\n        var ref = this.options;\n        var min = ref.min;\n        var max = ref.max;\n        var reverse = ref.reverse;\n        var startAngle = ref.startAngle;\n        var endAngle = ref.endAngle;\n        var angle = endAngle - startAngle;\n        var result;\n\n        if (reverse) {\n            result = endAngle - (value - min) / (max - min) * angle;\n        } else {\n            result = ((value - min) / (max - min) * angle) + startAngle;\n        }\n\n        return result + GEO_ARC_ADJUST_ANGLE;\n    },\n\n    hasRanges: function() {\n        var ranges = this.options.ranges;\n\n        return ranges && ranges.length;\n    },\n\n    ticksSize: function() {\n        var ref = this.options;\n        var majorTicks = ref.majorTicks;\n        var minorTicks = ref.minorTicks;\n        var size = 0;\n        if (majorTicks.visible) {\n            size = majorTicks.size;\n        }\n\n        if (minorTicks.visible) {\n            size = Math.max(minorTicks.size, size);\n        }\n\n        return size;\n    },\n\n    labelsCount: function() {\n        var count = NumericAxis.fn.labelsCount.call(this);\n        var options = this.options;\n        var angle = options.endAngle - options.startAngle;\n\n        if (angle >= 360 && (options.max % options.majorUnit === 0)) {\n            count -= 1;\n        }\n\n        return count;\n    },\n\n    renderLabels: function() {\n        var this$1$1 = this;\n\n        var options = this.options;\n        var arc = this.arc.clone();\n        var radius = arc.getRadiusX();\n        var tickAngles = this.tickAngles(arc, options.majorUnit);\n        var rangeSize = options.rangeSize = options.rangeSize || radius * 0.1;\n        var labelsGroup = new Group$5();\n\n        var rangeDistance = radius * 0.05;\n        if (defined(options.rangeDistance)) {\n            rangeDistance = options.rangeDistance;\n        } else {\n            options.rangeDistance = rangeDistance;\n        }\n\n        var labelsOptions = options.labels;\n        var isInside = labelsOptions.position === INSIDE;\n        var hasLabelElements = defined(this.labelElements);\n\n        if (isInside) {\n            radius -= this.ticksSize();\n\n            if (this.hasRanges() && !hasLabelElements) {\n                radius -= rangeSize + rangeDistance;\n            }\n            arc.setRadiusX(radius).setRadiusY(radius);\n        }\n\n        var labels = this.labels;\n        var count = labels.length;\n        var padding = getSpacing(labelsOptions.padding);\n        var paddingWidth = (padding.left + padding.right) / 2;\n        var paddingHeight = (padding.top + padding.bottom) / 2;\n\n        for (var i = 0; i < count; i++) {\n            var label = labels[i];\n            var halfWidth = label.box.width() / 2;\n            var halfHeight = label.box.height() / 2;\n            var angle = tickAngles[i];\n            var labelAngle = (angle - GEO_ARC_ADJUST_ANGLE) * DEGREE;\n\n            var lp = arc.pointAt(angle);\n            var cx = lp.x + (Math.cos(labelAngle) * (halfWidth + paddingWidth) * (isInside ? 1 : -1));\n            var cy = lp.y + (Math.sin(labelAngle) * (halfHeight + paddingHeight) * (isInside ? 1 : -1));\n\n            label.reflow(new Box(cx - halfWidth, cy - halfHeight, cx + halfWidth, cy + halfHeight));\n            var labelPos = new GeometryPoint(label.box.x1, label.box.y1);\n\n            var labelElement = (void 0);\n            if (!hasLabelElements) {\n                labelElement = buildLabelElement(label, options.labels);\n                labelsGroup.append(labelElement);\n            } else {\n                labelElement = this$1$1.labelElements.children[i];\n                var prevLabelPos = labelElement.bbox().origin;\n\n                var labelTransform = labelElement.transform() || transform();\n                labelTransform.translate(labelPos.x - prevLabelPos.x, labelPos.y - prevLabelPos.y);\n                labelElement.transform(labelTransform);\n            }\n\n            this$1$1.bbox = Rect.union(this$1$1.bbox, labelElement.bbox());\n        }\n\n        return labelsGroup;\n    },\n\n    repositionRanges: function() {\n        var ranges = this.ranges.children;\n\n        if (ranges.length > 0) {\n            var ref = this.options;\n            var rangeDistance = ref.rangeDistance;\n            var rangeSize = ref.rangeSize;\n            var rangeRadius = this.getRangeRadius();\n\n            if (this.options.labels.position === INSIDE) {\n                rangeRadius += rangeSize + rangeDistance;\n            }\n\n            var newRadius = rangeRadius + (rangeSize / 2);\n\n            for (var i = 0; i < ranges.length; i++) {\n                ranges[i]._geometry.setRadiusX(newRadius).setRadiusY(newRadius);\n            }\n\n            this.bbox = Rect.union(this.bbox, this.ranges.bbox());\n        }\n    },\n\n    renderRanges: function() {\n        var this$1$1 = this;\n\n        var segments = this.rangeSegments();\n        var segmentsCount = segments.length;\n        var result = new Group$5();\n\n        if (segmentsCount) {\n            var ref = this.options;\n            var rangeSize = ref.rangeSize;\n            var reverse = ref.reverse;\n            var rangeDistance = ref.rangeDistance;\n            var rangeRadius = this.getRangeRadius();\n\n            // move the ticks with a range distance and a range size\n            this.radius(this.radius() - rangeSize - rangeDistance);\n\n            for (var i = 0; i < segmentsCount; i++) {\n                var segment = segments[i];\n                var from = this$1$1.slotAngle(segment[reverse ? \"to\" : \"from\"]);\n                var to = this$1$1.slotAngle(segment[!reverse ? \"to\" : \"from\"]);\n\n                if (to - from !== 0) {\n                    result.append(this$1$1.createRange(from, to, rangeRadius, segment));\n                }\n            }\n        }\n\n        return result;\n    },\n\n    createRange: function(startAngle, endAngle, rangeRadius, options) {\n        var rangeSize = this.options.rangeSize;\n        var rangeGeom = new geometry.Arc(this.arc.center, {\n            radiusX: rangeRadius + (rangeSize / 2),\n            radiusY: rangeRadius + (rangeSize / 2),\n            startAngle: startAngle,\n            endAngle: endAngle\n        });\n\n        return new Arc(rangeGeom, {\n            stroke: {\n                width: rangeSize,\n                color: options.color,\n                opacity: options.opacity,\n                lineCap: options.lineCap\n            }\n        });\n    },\n\n    rangeSegments: function() {\n        var options = this.options;\n        var ranges = options.ranges || [];\n        var count = ranges.length;\n        var segments = [];\n\n        if (count) {\n            var min = options.min;\n            var max = options.max;\n            var defaultColor = options.rangePlaceholderColor;\n            segments.push(rangeSegment(min, max, defaultColor));\n\n            for (var i = 0; i < count; i++) {\n                var range = getRange(ranges[i], min, max);\n                var segmentsCount = segments.length;\n\n                for (var j = 0; j < segmentsCount; j++) {\n                    var segment = segments[j];\n\n                    if (segment.from <= range.from && range.from <= segment.to) {\n                        segments.push(rangeSegment(range.from, range.to, range.color, range.opacity));\n\n                        if (segment.from <= range.to && range.to <= segment.to) {\n                            segments.push(rangeSegment(range.to, segment.to, defaultColor, range.opacity));\n                        }\n\n                        segment.to = range.from;\n\n                        break;\n                    }\n                }\n            }\n        }\n\n        return segments;\n    },\n\n    getRangeRadius: function() {\n        var ref = this;\n        var arc = ref.arc;\n        var options = ref.options;\n        var rangeSize = options.rangeSize;\n        var rangeDistance = options.rangeDistance;\n        var majorTickSize = options.majorTicks.size;\n        var radius;\n\n        if (options.labels.position === OUTSIDE) {\n            radius = arc.getRadiusX() - majorTickSize - rangeDistance - rangeSize;\n        } else {\n            radius = arc.getRadiusX() - rangeSize;\n        }\n\n        return radius;\n    },\n\n    renderArc: function(center, radius) {\n        var options = this.options;\n\n        var arc = this.arc = new geometry.Arc(center, {\n            radiusX: radius,\n            radiusY: radius,\n            startAngle: options.startAngle + GEO_ARC_ADJUST_ANGLE,\n            endAngle: options.endAngle + GEO_ARC_ADJUST_ANGLE\n        });\n\n        return arc;\n    },\n\n    renderTicks: function() {\n        var ref = this;\n        var arc = ref.arc;\n        var options = ref.options;\n        var tickArc = arc.clone();\n\n        this.majorTickAngles = this.tickAngles(arc, options.majorUnit);\n        this.majorTicks = drawTicks(tickArc, this.majorTickAngles, options.majorUnit, options.majorTicks);\n\n        var allTicks = new Group$5();\n        allTicks.append(this.majorTicks);\n\n        var majorTickSize = options.majorTicks.size;\n        var minorTickSize = options.minorTicks.size;\n\n        this._tickDifference = majorTickSize - minorTickSize;\n\n        if (options.labels.position === OUTSIDE) {\n            var radius = tickArc.getRadiusX();\n            tickArc.setRadiusX(radius - majorTickSize + minorTickSize)\n                .setRadiusY(radius - majorTickSize + minorTickSize);\n        }\n\n        this.minorTickAngles = this.normalizeTickAngles(this.tickAngles(arc, options.minorUnit));\n        this.minorTicks = drawTicks(tickArc, this.minorTickAngles, options.minorUnit, options.minorTicks);\n        allTicks.append(this.minorTicks);\n\n        return allTicks;\n    },\n\n    normalizeTickAngles: function(angles) {\n        var options = this.options;\n        var skip = options.majorUnit / options.minorUnit;\n\n        for (var i = angles.length - 1; i >= 0; i--) {\n            if (i % skip === 0) {\n                angles.splice(i, 1);\n            }\n        }\n\n        return angles;\n    },\n\n    tickAngles: function(ring, stepValue) {\n        var options = this.options;\n        var reverse = options.reverse;\n        var range = options.max - options.min;\n        var angle = ring.endAngle - ring.startAngle;\n        var tickCount = range / stepValue;\n        var pos = ring.startAngle;\n        var step = angle / tickCount;\n\n        if (reverse) {\n            pos += angle;\n            step = -step;\n        }\n\n        if (angle >= 360 && (options.max % stepValue === 0)) {\n            tickCount -= 1;\n        }\n\n        var positions = [];\n        for (var i = 0; i < tickCount; i++) {\n            positions.push(round(pos, COORD_PRECISION));\n            pos += step;\n        }\n\n        if (round(pos) <= ring.endAngle) {\n            positions.push(pos);\n        }\n\n        return positions;\n    },\n\n    radius: function(value) {\n        if (value) {\n            this.arc.setRadiusX(value).setRadiusY(value);\n            this.repositionTicks(this.majorTicks.children, this.majorTickAngles);\n            this.repositionTicks(this.minorTicks.children, this.minorTickAngles, true);\n        } else {\n            return this.arc.getRadiusX();\n        }\n    },\n\n    repositionTicks: function(ticks, tickAngles, minor) {\n        var diff = minor ? (this._tickDifference || 0) : 0;\n        var tickArc = this.arc;\n        var radius = tickArc.getRadiusX();\n\n        if (minor && this.options.labels.position === OUTSIDE && diff !== 0) {\n            tickArc = this.arc.clone();\n            tickArc.setRadiusX(radius - diff).setRadiusY(radius - diff);\n        }\n\n        for (var i = 0; i < ticks.length; i++) {\n            var newPoint = tickArc.pointAt(tickAngles[i]);\n            var segments = ticks[i].segments;\n            var xDiff = newPoint.x - segments[0].anchor().x;\n            var yDiff = newPoint.y - segments[0].anchor().y;\n\n            ticks[i].transform(new transform().translate(xDiff, yDiff));\n        }\n    }\n});\n\nsetDefaultOptions(RadialScale, {\n    min: 0,\n    max: 100,\n\n    majorTicks: {\n        size: 15,\n        align: INSIDE,\n        color: BLACK,\n        width: DEFAULT_LINE_WIDTH,\n        visible: true\n    },\n\n    minorTicks: {\n        size: 10,\n        align: INSIDE,\n        color: BLACK,\n        width: DEFAULT_LINE_WIDTH,\n        visible: true\n    },\n\n    startAngle: -30,\n    endAngle: 210,\n\n    labels: {\n        position: INSIDE,\n        padding: 2\n    }\n});\n\nvar RadialPointerAnimation = Animation.extend({\n    init: function(element, options) {\n        Animation.fn.init.call(this, element, options);\n\n        var animationOptions = this.options;\n\n        animationOptions.duration = Math.max((Math.abs(animationOptions.newAngle - animationOptions.oldAngle) / animationOptions.duration) * 1000, 1);\n    },\n\n    step: function(pos) {\n        var options = this.options;\n        var angle = interpolateValue(options.oldAngle, options.newAngle, pos);\n\n        this.element.transform(transform().rotate(angle, options.center));\n    }\n});\n\nsetDefaultOptions(RadialPointerAnimation, {\n    easing: LINEAR,\n    duration: ANGULAR_SPEED\n});\n\nAnimationFactory.current.register(RADIAL_POINTER, RadialPointerAnimation);\n\nvar CAP_SIZE = 0.05;\nvar Circle = drawing.Circle;\nvar Group$6 = DrawingGroup;\nvar Path$6 = DrawingPath;\n\nvar RadialPointer = Pointer.extend({\n    setAngle: function(angle) {\n        this.elements.transform(transform().rotate(angle, this.center));\n    },\n\n    repaint: function() {\n        var ref = this;\n        var scale = ref.scale;\n        var options = ref.options;\n        var oldAngle = scale.slotAngle(options._oldValue);\n        var newAngle = scale.slotAngle(options.value);\n\n        if (options.animation.transitions === false) {\n            this.setAngle(newAngle);\n        } else {\n            new RadialPointerAnimation(this.elements, deepExtend(options.animation, {\n                oldAngle: oldAngle,\n                newAngle: newAngle\n            })).play();\n        }\n    },\n\n    render: function() {\n        var ref = this;\n        var scale = ref.scale;\n        var options = ref.options;\n        var elements = new Group$6();\n\n        if (options.animation !== false) {\n            deepExtend(options.animation, {\n                startAngle: 0,\n                center: scale.arc.center,\n                reverse: scale.options.reverse\n            });\n        }\n\n        elements.append(this._renderNeedle(), this._renderCap());\n\n        this.elements = elements;\n        this.setAngle(DEGREE);\n\n        return elements;\n    },\n\n    reflow: function(arc) {\n        var center = this.center = arc.center;\n        var length = limitValue(this.options.length || 1, 0.1, 1.5);\n        var radius = this.radius = arc.getRadiusX() * length;\n        var capSize = this.capSize = Math.round(radius * this.options.cap.size);\n\n        this.bbox = Rect.fromPoints(new GeometryPoint(center.x - capSize, center.y - capSize),\n            new GeometryPoint(center.x + capSize, center.y + capSize));\n    },\n\n    _renderNeedle: function() {\n        var minorTickSize = this.scale.options.minorTicks.size;\n        var center = this.center;\n        var needleColor = this.options.color;\n\n        var needlePath = new Path$6({\n            fill: { color: needleColor },\n            stroke: { color: needleColor, width: DEFAULT_LINE_WIDTH }\n        });\n\n        needlePath.moveTo(center.x + this.radius - minorTickSize, center.y)\n            .lineTo(center.x, center.y - (this.capSize / 2))\n            .lineTo(center.x, center.y + (this.capSize / 2))\n            .close();\n\n        return needlePath;\n    },\n\n    _renderCap: function() {\n        var options = this.options;\n        var capColor = options.cap.color || options.color;\n        var circle = new geometry.Circle(this.center, this.capSize);\n\n        var cap = new Circle(circle, {\n            fill: { color: capColor },\n            stroke: { color: capColor }\n        });\n\n        return cap;\n    }\n});\n\nsetDefaultOptions(RadialPointer, {\n    cap: {\n        size: CAP_SIZE\n    },\n    arrow: {\n        width: 16,\n        height: 14\n    },\n    animation: {\n        type: RADIAL_POINTER,\n        duration: ANGULAR_SPEED\n    }\n});\n\nvar Group$4 = DrawingGroup;\n\nvar RadialGauge = Gauge.extend({\n    reflow: function(bbox) {\n        var this$1$1 = this;\n\n        var pointers = this.pointers;\n        this.scale.reflow(bbox);\n        this._initialPlotArea = this.scale.bbox;\n\n        for (var i = 0; i < pointers.length; i++) {\n            pointers[i].reflow(this$1$1.scale.arc);\n            this$1$1._initialPlotArea = Rect.union(this$1$1._initialPlotArea, pointers[i].bbox);\n        }\n\n        this.fitScale(bbox);\n        this.alignScale(bbox);\n        this._buildVisual(this.gaugeArea, pointers, this.scale);\n        this._draw();\n    },\n\n    _buildVisual: function(gaugeArea, pointers, scale) {\n        var visuals = this._visuals = new Group$4();\n\n        visuals.append(gaugeArea);\n        visuals.append(scale.ticks);\n        visuals.append(scale.ranges);\n        this._buildPointers(pointers);\n        visuals.append(scale.labelElements);\n    },\n\n    _buildPointers: function(pointers) {\n        var this$1$1 = this;\n\n        for (var i = 0; i < pointers.length; i++) {\n            var current = pointers[i];\n            current.render();\n            this$1$1._visuals.append(current.elements);\n\n            current.value(current.options.value);\n        }\n    },\n\n    fitScale: function(bbox) {\n        var this$1$1 = this;\n\n        var arc = this.scale.arc;\n        var plotAreaBox = this._initialPlotArea;\n        var step = Math.abs(this.getDiff(plotAreaBox, bbox));\n        var min = round(step, COORD_PRECISION);\n        var max = round(-step, COORD_PRECISION);\n        var minDiff, midDiff, maxDiff, mid, oldDiff;\n        var staleFlag = 0;\n        var i = 0;\n\n        while (i++ < 100) {\n            staleFlag = (oldDiff === maxDiff) ? (staleFlag + 1) : 0;\n\n            if (staleFlag > 5) {\n                break;\n            }\n\n            if (min !== mid) {\n                minDiff = this$1$1.getPlotBox(min, bbox, arc);\n                if (0 <= minDiff && minDiff <= 2) {\n                    break;\n                }\n            }\n\n            if (max !== mid) {\n                maxDiff = this$1$1.getPlotBox(max, bbox, arc);\n                if (0 <= maxDiff && maxDiff <= 2) {\n                    break;\n                }\n            }\n\n            if (minDiff > 0 && maxDiff > 0) {\n                mid = min * 2;\n            } else if (minDiff < 0 && maxDiff < 0) {\n                mid = max * 2;\n            } else {\n                mid = round(((min + max) / 2) || 1, COORD_PRECISION);\n            }\n\n            midDiff = this$1$1.getPlotBox(mid, bbox, arc);\n            if (0 <= midDiff && midDiff <= 2) {\n                break;\n            }\n\n            oldDiff = maxDiff;\n\n            if (midDiff > 0) {\n                max = mid;\n                maxDiff = midDiff;\n            } else {\n                min = mid;\n                minDiff = midDiff;\n            }\n        }\n    },\n\n    getPlotBox: function(step, bbox, arc) {\n        var this$1$1 = this;\n\n        var scale = this.scale;\n        var pointers = this.pointers;\n        var radius = arc.getRadiusX();\n        var scaleArc = arc.clone();\n\n        scaleArc.setRadiusX(radius + step).setRadiusY(radius + step);\n\n        scale.arc = scaleArc;\n        scale.reflow(bbox);\n        this.plotBbox = scale.bbox;\n\n        for (var i = 0; i < pointers.length; i++) {\n            pointers[i].reflow(scaleArc);\n            this$1$1.plotBbox = Rect.union(this$1$1.plotBbox, pointers[i].bbox);\n        }\n\n        return this.getDiff(this.plotBbox, bbox);\n    },\n\n    getDiff: function(plotBox, box) {\n        return Math.min(box.width() - plotBox.width(), box.height() - plotBox.height());\n    },\n\n    alignScale: function(bbox) {\n        var this$1$1 = this;\n\n        var plotBoxCenter = this.plotBbox.center();\n        var boxCenter = bbox.center();\n        var paddingX = plotBoxCenter.x - boxCenter.x;\n        var paddingY = plotBoxCenter.y - boxCenter.y;\n        var ref = this;\n        var scale = ref.scale;\n        var pointers = ref.pointers;\n\n        scale.arc.center.x -= paddingX;\n        scale.arc.center.y -= paddingY;\n\n        scale.reflow(bbox);\n\n        for (var i = 0; i < pointers.length; i++) {\n            pointers[i].reflow(scale.arc);\n            this$1$1.plotBbox = Rect.union(scale.bbox, pointers[i].bbox);\n        }\n    },\n\n    _createModel: function() {\n        var this$1$1 = this;\n\n        var options = this.options;\n        var pointers = options.pointer;\n        var scale = this.scale = new RadialScale(options.scale, this.contextService);\n\n        this.pointers = [];\n\n        var pointersArr = isArray(pointers) ? pointers : [ pointers ];\n        for (var i = 0; i < pointersArr.length; i++) {\n            var current = new RadialPointer(scale, deepExtend({}, pointersArr[i], {\n                animation: {\n                    transitions: options.transitions\n                }\n            }));\n\n            this$1$1.pointers.push(current);\n        }\n    }\n});\n\nsetDefaultOptions(RadialGauge, {\n    transitions: true,\n    gaugeArea: {\n        background: \"\"\n    }\n});\n\nvar ArcScale = RadialScale.extend({\n    rangeSegments: function() {\n        var ref = this.options;\n        var min = ref.min;\n        var max = ref.max;\n        var rangePlaceholderColor = ref.rangePlaceholderColor;\n        var rangeLineCap = ref.rangeLineCap;\n\n        return [ { from: min, to: max, color: rangePlaceholderColor, lineCap: rangeLineCap } ];\n    },\n\n    hasRanges: function() {\n        return true;\n    },\n\n    placeholderRangeAngle: function(angle) {\n        var geometry$$1 = this.ranges.children[0].geometry();\n\n        if (this.options.reverse) {\n            geometry$$1.setEndAngle(angle);\n        } else {\n            geometry$$1.setStartAngle(angle);\n        }\n    },\n\n    addRange: function(from, to, options) {\n        var reverse = this.options.reverse;\n\n        var startAngle = this.slotAngle(reverse ? to : from);\n        var endAngle = this.slotAngle(reverse ? from : to);\n\n        var range = this.createRange(startAngle, endAngle, this.getRangeRadius(), options);\n\n        this.ranges.append(range);\n\n        return range;\n    }\n});\n\nsetDefaultOptions(ArcScale, {\n    min: 0,\n    max: 100,\n\n    majorTicks: {\n        visible: false\n    },\n\n    minorTicks: {\n        visible: false\n    },\n\n    labels: {\n        visible: false\n    },\n\n    startAngle: 0,\n    endAngle: 180,\n    rangeLineCap: 'round'\n});\n\nvar MAX_DURATION = 800;\n\nvar RangePointerAnimation = Animation.extend({\n    init: function(element, options) {\n        Animation.fn.init.call(this, element, options);\n\n        var animationOptions = this.options;\n        var duration = (Math.abs(animationOptions.newAngle - animationOptions.oldAngle) / animationOptions.duration) * 1000;\n        animationOptions.duration = limitValue(duration, ANGULAR_SPEED, MAX_DURATION);\n\n        var startColor = element.elements.options.get(\"stroke.color\");\n        var color = element.currentColor();\n        if (startColor !== color) {\n            this.startColor = new kendo.Color(startColor);\n            this.color = new kendo.Color(color);\n        }\n    },\n\n    step: function(pos) {\n        var ref = this;\n        var options = ref.options;\n        var startColor = ref.startColor;\n        var color = ref.color;\n        var angle = interpolateValue(options.oldAngle, options.newAngle, pos);\n        this.element.angle(angle);\n\n        if (color) {\n            var r = round(interpolateValue(startColor.r, color.r, pos));\n            var g = round(interpolateValue(startColor.g, color.g, pos));\n            var b = round(interpolateValue(startColor.b, color.b, pos));\n\n            this.element.stroke(new kendo.Color(r, g, b).toHex());\n        }\n    }\n});\n\nsetDefaultOptions(RangePointerAnimation, {\n    easing: LINEAR,\n    duration: ANGULAR_SPEED\n});\n\nAnimationFactory.current.register(RADIAL_RANGE_POINTER, RangePointerAnimation);\n\nvar RangePointer = Pointer.extend({\n    repaint: function() {\n        var ref = this;\n        var scale = ref.scale;\n        var options = ref.options;\n        var oldAngle = scale.slotAngle(options._oldValue);\n        var newAngle = scale.slotAngle(options.value);\n\n        if (this.animation) {\n            this.animation.abort();\n        }\n\n        if (options.animation.transitions === false) {\n            this.angle(newAngle);\n            this.stroke(this.currentColor());\n        } else {\n            this.animation = new RangePointerAnimation(this, deepExtend(options.animation, {\n                oldAngle: oldAngle,\n                newAngle: newAngle\n            }));\n\n            this.animation.play();\n        }\n    },\n\n    angle: function(value) {\n        var geometry$$1 = this.elements.geometry();\n        if (this.scale.options.reverse) {\n            geometry$$1.setStartAngle(value);\n        } else {\n            geometry$$1.setEndAngle(value);\n        }\n        this.scale.placeholderRangeAngle(value);\n    },\n\n    stroke: function(value) {\n        this.elements.stroke(value);\n    },\n\n    render: function() {\n        if (this.elements) {\n            return;\n        }\n\n        var ref = this;\n        var scale = ref.scale;\n        var options = ref.options;\n\n        if (options.animation !== false) {\n            deepExtend(options.animation, {\n                startAngle: 0,\n                center: scale.arc.center,\n                reverse: scale.options.reverse\n            });\n        }\n\n        this.elements = scale.addRange(scale.options.min, this.options.value, {\n            color: this.currentColor(),\n            opacity: options.opacity,\n            lineCap: scale.options.rangeLineCap\n        });\n    },\n\n    currentColor: function() {\n        var ref = this.scale.options;\n        var min = ref.min;\n        var max = ref.max;\n        var ref$1 = this.options;\n        var colors = ref$1.colors;\n        var color = ref$1.color;\n        var value = ref$1.value;\n        var currentValue = dataviz.isNumber(value) ? value : min;\n\n        if (colors) {\n            for (var idx = 0; idx < colors.length; idx++) {\n                var ref$2 = colors[idx];\n                var rangeColor = ref$2.color;\n                var from = ref$2.from; if (from === void 0) { from = min; }\n                var to = ref$2.to; if (to === void 0) { to = max; }\n\n                if (from <= currentValue && currentValue <= to) {\n                    return rangeColor;\n                }\n            }\n        }\n\n        return color;\n    },\n\n    reflow: function() {\n        this.render();\n\n        this.bbox = this.elements.bbox();\n    }\n});\n\nsetDefaultOptions(RangePointer, {\n    animation: {\n        type: RADIAL_RANGE_POINTER,\n        duration: ANGULAR_SPEED\n    }\n});\n\nvar ArcGauge = RadialGauge.extend({\n    _initTheme: function(theme) {\n        RadialGauge.fn._initTheme.call(this, theme);\n\n        this.options.color = this.options.color || (this.theme.pointer || {}).color;\n    },\n\n    _createModel: function() {\n        var options = this.options;\n        var scale = this.scale = new ArcScale(options.scale, this.contextService);\n\n        var pointer = new RangePointer(scale, deepExtend({}, {\n            colors: options.colors,\n            color: options.color,\n            value: options.value,\n            opacity: options.opacity,\n            animation: {\n                transitions: options.transitions\n            }\n        }));\n\n        this.pointers = [ pointer ];\n    },\n\n    _buildPointers: function(pointers) {\n        for (var i = 0; i < pointers.length; i++) {\n            var current = pointers[i];\n            current.render();\n\n            current.value(current.options.value);\n        }\n    },\n\n    _setValueOptions: function(value) {\n        this.options.value = value;\n    },\n\n    currentColor: function() {\n        var pointer = this.pointers[0];\n        if (pointer) {\n            return pointer.currentColor();\n        }\n    },\n\n    centerLabelPosition: function(width, height) {\n        var size = this.getSize();\n        var center = this.scale.arc.center;\n\n        var left = center.x - width / 2;\n        var top = center.y - height / 2;\n\n        if (width < size.width) {\n            var right = left + width;\n\n            left = Math.max(left, 0);\n\n            if (right > size.width) {\n                left -= right - size.width;\n            }\n        }\n\n        if (height < size.height) {\n            var bbox = this.scale.bbox;\n            var yLimit = bbox.bottomRight().y;\n            var bottom = top + height;\n\n            top = Math.max(top, bbox.origin.y);\n\n            if (bottom > yLimit) {\n                top -= bottom - yLimit;\n            }\n        }\n\n        return {\n            left: left,\n            top: top\n        };\n    }\n});\n\nvar defaultStartAngle = 90;\n\nvar CircularGauge = ArcGauge.extend({\n    _createModel: function() {\n        var scaleOptions = this.options.scale;\n        if (typeof scaleOptions.startAngle !== 'number') {\n            scaleOptions.startAngle = defaultStartAngle;\n        }\n\n        scaleOptions.endAngle = scaleOptions.startAngle + 360;\n\n        ArcGauge.fn._createModel.call(this);\n    }\n});\n\nkendo.deepExtend(kendo.dataviz, {\n    Gauge: Gauge,\n    LinearGauge: LinearGauge,\n    LinearPointer: LinearPointer,\n    ArrowLinearPointer: ArrowLinearPointer,\n    BarLinearPointer: BarLinearPointer,\n    LinearScale: LinearScale,\n    RadialGauge: RadialGauge,\n    RadialPointer: RadialPointer,\n    RadialScale: RadialScale,\n    ArcGauge: ArcGauge,\n    RangePointer: RangePointer,\n    ArcScale: ArcScale,\n    CircularGauge: CircularGauge\n});\n\n})(window.kendo.jQuery);\n\n(function($) {\n    var kendo = window.kendo;\n    var Widget = kendo.ui.Widget;\n    var dataviz = kendo.dataviz;\n    var LinearGauge = dataviz.LinearGauge;\n    var RadialGauge = dataviz.RadialGauge;\n    var ArcGauge = dataviz.ArcGauge;\n    var CircularGauge = dataviz.CircularGauge;\n    var draw = kendo.drawing;\n\n    function themeOptions(options) {\n        var themes = dataviz.ui.themes || {};\n        var themeName = options.theme || \"\";\n        var lowerName = themeName.toLowerCase();\n\n        if (dataviz.SASS_THEMES.indexOf(lowerName) != -1) {\n            return dataviz.autoTheme().gauge;\n        }\n\n        return (themes[themeName] || themes[lowerName] || {}).gauge;\n    }\n\n    var Gauge = Widget.extend({\n        init: function(element, userOptions) {\n            kendo.destroy(element);\n            $(element).empty();\n\n            Widget.fn.init.call(this, element);\n\n            this.options = kendo.deepExtend(this.options, userOptions);\n\n            this.wrapper = this.element;\n            this._createInstance();\n\n            this.element.addClass('k-gauge');\n\n            kendo.notify(this, dataviz.ui);\n        },\n\n        options: {\n            theme: \"sass\",\n            renderAs: \"\",\n            pointer: {},\n            scale: {},\n            gaugeArea: {\n                background: \"\"\n            },\n            transitions: true\n        },\n\n        setOptions: function(options) {\n            this._instance.setOptions(options, themeOptions(options));\n\n            this._copyFields();\n        },\n\n        redraw: function() {\n            this._instance.redraw();\n            this._copyFields();\n        },\n\n        destroy: function() {\n            Widget.fn.destroy.call(this);\n            this._instance.destroy();\n        },\n\n        _createInstance: function() {\n            var gaugeType = this._gaugeType();\n            this._instance = new gaugeType(this.element[0], this.options, themeOptions(this.options));\n            this._copyFields();\n        },\n\n        _copyFields: function() {\n            this._originalOptions = this._instance._originalOptions;\n            this.options = this._instance.options;\n            this.surface = this._instance.surface;\n            this.bbox = this._instance.bbox;\n            this.gaugeArea = this._instance.gaugeArea;\n            this.pointers = this._instance.pointers;\n            this.scale = this._instance.scale;\n        },\n\n        _resize: function() {\n            this._instance.resize();\n        }\n    });\n\n    var proxyMembers = [\"getSize\", \"value\", \"allValues\", \"exportVisual\"];\n\n    function createProxyMember(name) {\n        Gauge.fn[name] = function() {\n            return this._instance[name].apply(this._instance, arguments);\n        };\n    }\n\n    for (var idx = 0; idx < proxyMembers.length; idx++) {\n        createProxyMember(proxyMembers[idx]);\n    }\n\n    dataviz.ExportMixin.extend(Gauge.fn);\n\n    var RadialGaugeWidget = Gauge.extend({\n\n        options: {\n            name: \"RadialGauge\"\n        },\n\n        _gaugeType: function() {\n            return RadialGauge;\n        }\n    });\n\n    var LinearGaugeWidget = Gauge.extend({\n\n        options: {\n            name: \"LinearGauge\",\n            scale: {\n                vertical: true\n            }\n        },\n\n        _gaugeType: function() {\n            return LinearGauge;\n        }\n    });\n\n    var ArcGaugeWidget = Gauge.extend({\n        init: function(element, userOptions) {\n            Gauge.fn.init.call(this, element, userOptions);\n\n            this.element.css('position', 'relative');\n            this.element.addClass('k-arcgauge');\n\n            this._centerTemplate();\n        },\n\n        options: {\n            name: \"ArcGauge\"\n        },\n\n        setOptions: function(options) {\n            Gauge.fn.setOptions.call(this, options);\n            this._centerTemplate();\n        },\n\n        redraw: function() {\n            Gauge.fn.redraw.call(this);\n            this._centerTemplate();\n        },\n\n        value: function(value) {\n            var instance = this._instance;\n            if (arguments.length === 0) {\n                return instance.value();\n            }\n\n            instance.value(value);\n\n            this._centerTemplate();\n        },\n\n        destroy: function() {\n            Gauge.fn.destroy.call(this);\n            delete this._centerElement;\n        },\n\n        exportVisual: function() {\n            if (this._centerElement) {\n                return false;\n            }\n\n            return Gauge.fn.exportVisual.call(this);\n        },\n\n        _resize: function() {\n            this._instance.resize();\n\n            this._centerTemplate();\n        },\n\n        _centerTemplate: function() {\n            if (this.options.centerTemplate) {\n                var template = kendo.template(this.options.centerTemplate);\n\n                var instance = this._instance;\n                var centerElement = this._getCenterElement();\n\n                centerElement.html(template({ color: instance.currentColor(), value: instance.value() }));\n\n                var position = instance.centerLabelPosition(centerElement.width(), centerElement.height());\n\n                centerElement.css(position);\n            } else if (this._centerElement) {\n                this._centerElement.remove();\n                this._centerElement = null;\n            }\n        },\n\n        _getCenterElement: function() {\n            var centerElement = this._centerElement;\n            if (!centerElement) {\n                centerElement = this._centerElement = $('<div></div>').addClass('k-arcgauge-label');\n                this.element.append(centerElement);\n            }\n\n            return centerElement;\n        },\n\n        _gaugeType: function() {\n            return ArcGauge;\n        }\n    });\n\n    var CircularGaugeWidget = ArcGaugeWidget.extend({\n        options: {\n            name: \"CircularGauge\"\n        },\n\n        _gaugeType: function() {\n            return CircularGauge;\n        }\n    });\n\n    function createExportMethod(name) {\n        ArcGaugeWidget.fn[name] = function(options) {\n            var gauge = this;\n            var method = draw[name];\n\n            if (!gauge._centerElement) {\n                return method(gauge.exportVisual(), options);\n            }\n\n            return draw.drawDOM(gauge.element).then(function(visual) {\n                return method(visual, options);\n            });\n        };\n    }\n\n    var exportMethods = ['exportSVG', 'exportImage', 'exportPDF'];\n\n    for (idx = 0; idx < exportMethods.length; idx++) {\n        createExportMethod(exportMethods[idx]);\n    }\n\n    dataviz.ui.plugin(LinearGaugeWidget);\n    dataviz.ui.plugin(RadialGaugeWidget);\n    dataviz.ui.plugin(ArcGaugeWidget);\n    dataviz.ui.plugin(CircularGaugeWidget);\n\n    kendo.deepExtend(dataviz, {\n        Gauge: Gauge,\n        LinearGauge: LinearGaugeWidget,\n        RadialGauge: RadialGaugeWidget,\n        ArcGauge: ArcGaugeWidget,\n        CircularGauge: CircularGaugeWidget\n    });\n\n})(window.kendo.jQuery);\n\nvar __meta__ = {\n    id: \"dataviz.gauge\",\n    name: \"Gauge\",\n    category: \"dataviz\",\n    description: \"Linear, Radial and Arc gauges.\",\n    depends: [ \"dataviz.core\", \"dataviz.themes\" ]\n};\n\nvar kendo$1 = kendo;\n\nexport { kendo$1 as default };\n"]}